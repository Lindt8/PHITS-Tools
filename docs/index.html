<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>PHITS_tools API documentation</title>
<meta name="description" content="This module contains a variety of tools used for parsing PHITS output files â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:120ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>PHITS_tools</code></h1>
</header>
<section id="section-intro">
<p>This module contains a variety of tools used for parsing PHITS output files.</p>
<p>Specifically, it seeks to be a (nearly) universal PHITS output parser, supporting output from
all tallies, both normal "standard" output as well as dump file outputs (in ASCII and binary formats).
It is also capable of automatically parsing all such PHITS output files in a directory.
If a DCHAIN input file (output from the [T-Dchain] tally) or DCHAIN output <code>*.act</code> file is provided
to the main tally output processing function, an attempt will be made to import the <a href="https://github.com/Lindt8/DCHAIN-Tools">DCHAIN Tools module</a>
and process the found DCHAIN output files too.</p>
<p>The functions contained in this module and brief descriptions of their functions are included below.
However, provided first is a description of the three different ways one can use and interface with this module.</p>
<h3 id="how-to-use-the-phits_toolspy-module"><strong>How to use the PHITS_tools.py module</strong></h3>
<p>There are three main ways one can use this Python module:</p>
<ol>
<li>As an <strong>imported Python module</strong><ul>
<li>In your own Python scripts, you can import this module as <code>from PHITS_tools import *</code> and call its main functions,
which are listed in the next section below, or any of its other functions documented here.</li>
</ul>
</li>
<li>As a <strong>command line interface (CLI)</strong><ul>
<li>This module can be ran on the command line with the individual PHITS output file to be parsed (or a directory
containing multiple files to be parsed) as the required argument.
Execute <code>python PHITS_tools.py --help</code> to see all of the different options that can be used with this module
to parse standard or dump PHITS output files (individually and directories containing them) via the CLI.</li>
</ul>
</li>
<li>As a <strong>graphical user interface (GUI)</strong><ul>
<li>When the module is executed without any additional arguments, <code>python PHITS_tools.py</code>, (or with the <code>--GUI</code> or <code>-g</code> flag in the CLI)
a GUI will be launched to step you through selecting what "mode" you would like to run PHITS Tools in (<code>STANDARD</code>, <code>DUMP</code>, or <code>DIRECTORY</code>),
selecting a file to be parsed (or a directory containing multiple files to be parsed), and the various options for each mode.</li>
</ul>
</li>
</ol>
<p>The CLI and GUI options result in the parsed file's contents being saved to a pickle (or dill) file, which can be reopened
and used later in a Python script.
When using the main functions below within a Python script which has imported the PHITS_tools
module, you can optionally choose not to save the pickle files (if desired) and only have the tally output/dump parsing
functions return the data objects they produce for your own further analyses.</p>
<h3 id="main-phits-output-parsing-functions"><strong>Main PHITS Output Parsing Functions</strong></h3>
<ul>
<li><code><a title="PHITS_tools.parse_tally_output_file" href="#PHITS_tools.parse_tally_output_file">parse_tally_output_file()</a></code>
: general parser for standard output files for all PHITS tallies</li>
<li><code><a title="PHITS_tools.parse_tally_dump_file" href="#PHITS_tools.parse_tally_dump_file">parse_tally_dump_file()</a></code>
: parser for dump files from "dump" flag in PHITS [T-Cross], [T-Time], and [T-Track] tallies</li>
<li><code><a title="PHITS_tools.parse_all_tally_output_in_dir" href="#PHITS_tools.parse_all_tally_output_in_dir">parse_all_tally_output_in_dir()</a></code>
: run <code><a title="PHITS_tools.parse_tally_output_file" href="#PHITS_tools.parse_tally_output_file">parse_tally_output_file()</a></code> over all standard output files in a directory (and, optionally, <code><a title="PHITS_tools.parse_tally_dump_file" href="#PHITS_tools.parse_tally_dump_file">parse_tally_dump_file()</a></code> over all dump files too)</li>
</ul>
<h3 id="general-purpose-functions">General Purpose Functions</h3>
<ul>
<li><code><a title="PHITS_tools.fetch_MC_material" href="#PHITS_tools.fetch_MC_material">fetch_MC_material()</a></code>
: returns a string of a formatted material for PHITS or MCNP</li>
<li><code><a title="PHITS_tools.tally" href="#PHITS_tools.tally">tally()</a></code>
: tally/histogram values (and their indices) falling within a desired binning structure</li>
<li><code><a title="PHITS_tools.rebinner" href="#PHITS_tools.rebinner">rebinner()</a></code>
: rebin a set of y-data to a new x-binning structure (edges not necessarily preserved)</li>
<li><code><a title="PHITS_tools.is_number" href="#PHITS_tools.is_number">is_number()</a></code>
: returns Boolean denoting whether provided string is that of a number</li>
<li><code><a title="PHITS_tools.ZZZAAAM_to_nuclide_plain_str" href="#PHITS_tools.ZZZAAAM_to_nuclide_plain_str">ZZZAAAM_to_nuclide_plain_str()</a></code>
: returns a nuclide plaintext string for a given "ZZZAAAM" number (1000Z+10A+M)</li>
<li><code><a title="PHITS_tools.nuclide_plain_str_to_latex_str" href="#PHITS_tools.nuclide_plain_str_to_latex_str">nuclide_plain_str_to_latex_str()</a></code>
: convert a plaintext string for a nuclide to a LaTeX formatted raw string</li>
<li><code><a title="PHITS_tools.Element_Z_to_Sym" href="#PHITS_tools.Element_Z_to_Sym">Element_Z_to_Sym()</a></code>
: return an elemental symbol string given its proton number Z</li>
<li><code><a title="PHITS_tools.Element_Sym_to_Z" href="#PHITS_tools.Element_Sym_to_Z">Element_Sym_to_Z()</a></code>
: returns an atomic number Z provided the elemental symbol</li>
<li><code><a title="PHITS_tools.find" href="#PHITS_tools.find">find()</a></code>
: return index of the first instance of a value in a list</li>
<li><code><a title="PHITS_tools.ICRP116_effective_dose_coeff" href="#PHITS_tools.ICRP116_effective_dose_coeff">ICRP116_effective_dose_coeff()</a></code>
: returns effective dose of a mono-energetic particle of some species and some geometry</li>
</ul>
<h3 id="subfunctions-for-phits-output-parsing">Subfunctions for PHITS output parsing</h3>
<p>(These are meant as dependencies more so than for standalone usage.)</p>
<ul>
<li><code><a title="PHITS_tools.split_into_header_and_content" href="#PHITS_tools.split_into_header_and_content">split_into_header_and_content()</a></code>
: initial reading of PHITS tally output, dividing it into header and "content" sections</li>
<li><code><a title="PHITS_tools.extract_data_from_header_line" href="#PHITS_tools.extract_data_from_header_line">extract_data_from_header_line()</a></code>
: extract metadata key/value pairs from tally output header lines</li>
<li><code><a title="PHITS_tools.data_row_to_num_list" href="#PHITS_tools.data_row_to_num_list">data_row_to_num_list()</a></code>
: extract numeric values from a line in the tally content section</li>
<li><code><a title="PHITS_tools.parse_group_string" href="#PHITS_tools.parse_group_string">parse_group_string()</a></code>
: split a string containing "groups" (e.g., regions) into a list of them</li>
<li><code><a title="PHITS_tools.parse_tally_header" href="#PHITS_tools.parse_tally_header">parse_tally_header()</a></code>
: extract metadata from tally output header section</li>
<li><code><a title="PHITS_tools.initialize_tally_array" href="#PHITS_tools.initialize_tally_array">initialize_tally_array()</a></code>
: initialize NumPy array for storing tally results</li>
<li><code><a title="PHITS_tools.calculate_tally_absolute_errors" href="#PHITS_tools.calculate_tally_absolute_errors">calculate_tally_absolute_errors()</a></code> : calculate absolute uncertainties from read values and relative errors</li>
<li><code><a title="PHITS_tools.split_str_of_equalities" href="#PHITS_tools.split_str_of_equalities">split_str_of_equalities()</a></code>
: split a string containing equalities (e.g., <code>reg = 100</code>) into a list of them</li>
<li><code><a title="PHITS_tools.parse_tally_content" href="#PHITS_tools.parse_tally_content">parse_tally_content()</a></code>
: extract tally results/values from tally content section</li>
<li><code><a title="PHITS_tools.build_tally_Pandas_dataframe" href="#PHITS_tools.build_tally_Pandas_dataframe">build_tally_Pandas_dataframe()</a></code>
: make Pandas dataframe from the main results NumPy array and the metadata</li>
<li><code><a title="PHITS_tools.search_for_dump_parameters" href="#PHITS_tools.search_for_dump_parameters">search_for_dump_parameters()</a></code>
: attempt to auto find "dump" parameters via possible standard tally output file</li>
<li><code><a title="PHITS_tools.determine_PHITS_output_file_type" href="#PHITS_tools.determine_PHITS_output_file_type">determine_PHITS_output_file_type()</a></code> : determine if a file is standard tally output or ASCII/binary dump file</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;

This module contains a variety of tools used for parsing PHITS output files.

Specifically, it seeks to be a (nearly) universal PHITS output parser, supporting output from
all tallies, both normal &#34;standard&#34; output as well as dump file outputs (in ASCII and binary formats).
It is also capable of automatically parsing all such PHITS output files in a directory.
If a DCHAIN input file (output from the [T-Dchain] tally) or DCHAIN output `*.act` file is provided
to the main tally output processing function, an attempt will be made to import the [DCHAIN Tools module](https://github.com/Lindt8/DCHAIN-Tools)
and process the found DCHAIN output files too.

The functions contained in this module and brief descriptions of their functions are included below.
However, provided first is a description of the three different ways one can use and interface with this module.

### **How to use the PHITS_tools.py module**

There are three main ways one can use this Python module:

 1. As an **imported Python module**
      - In your own Python scripts, you can import this module as `from PHITS_tools import *` and call its main functions,
         which are listed in the next section below, or any of its other functions documented here.
 2. As a **command line interface (CLI)**
      - This module can be ran on the command line with the individual PHITS output file to be parsed (or a directory
          containing multiple files to be parsed) as the required argument.
          Execute `python PHITS_tools.py --help` to see all of the different options that can be used with this module
          to parse standard or dump PHITS output files (individually and directories containing them) via the CLI.
 3. As a **graphical user interface (GUI)**
      - When the module is executed without any additional arguments, `python PHITS_tools.py`, (or with the `--GUI` or `-g` flag in the CLI)
          a GUI will be launched to step you through selecting what &#34;mode&#34; you would like to run PHITS Tools in (`STANDARD`, `DUMP`, or `DIRECTORY`),
          selecting a file to be parsed (or a directory containing multiple files to be parsed), and the various options for each mode.

The CLI and GUI options result in the parsed file&#39;s contents being saved to a pickle (or dill) file, which can be reopened
and used later in a Python script.  When using the main functions below within a Python script which has imported the PHITS_tools
module, you can optionally choose not to save the pickle files (if desired) and only have the tally output/dump parsing
functions return the data objects they produce for your own further analyses.

### **Main PHITS Output Parsing Functions**

- `parse_tally_output_file`         : general parser for standard output files for all PHITS tallies
- `parse_tally_dump_file`           : parser for dump files from &#34;dump&#34; flag in PHITS [T-Cross], [T-Time], and [T-Track] tallies
- `parse_all_tally_output_in_dir`   : run `parse_tally_output_file()` over all standard output files in a directory (and, optionally, `parse_tally_dump_file()` over all dump files too)

### General Purpose Functions

- `fetch_MC_material`               : returns a string of a formatted material for PHITS or MCNP
- `tally`                           : tally/histogram values (and their indices) falling within a desired binning structure
- `rebinner`                        : rebin a set of y-data to a new x-binning structure (edges not necessarily preserved)
- `is_number`                       : returns Boolean denoting whether provided string is that of a number
- `ZZZAAAM_to_nuclide_plain_str`    : returns a nuclide plaintext string for a given &#34;ZZZAAAM&#34; number (1000Z+10A+M)
- `nuclide_plain_str_to_latex_str`  : convert a plaintext string for a nuclide to a LaTeX formatted raw string
- `Element_Z_to_Sym`                : return an elemental symbol string given its proton number Z
- `Element_Sym_to_Z`                : returns an atomic number Z provided the elemental symbol
- `find`                            : return index of the first instance of a value in a list
- `ICRP116_effective_dose_coeff`    : returns effective dose of a mono-energetic particle of some species and some geometry

### Subfunctions for PHITS output parsing
(These are meant as dependencies more so than for standalone usage.)

- `split_into_header_and_content`   : initial reading of PHITS tally output, dividing it into header and &#34;content&#34; sections
- `extract_data_from_header_line`   : extract metadata key/value pairs from tally output header lines
- `data_row_to_num_list`            : extract numeric values from a line in the tally content section
- `parse_group_string`              : split a string containing &#34;groups&#34; (e.g., regions) into a list of them
- `parse_tally_header`              : extract metadata from tally output header section
- `initialize_tally_array`          : initialize NumPy array for storing tally results
- `calculate_tally_absolute_errors` : calculate absolute uncertainties from read values and relative errors
- `split_str_of_equalities`         : split a string containing equalities (e.g., `reg = 100`) into a list of them
- `parse_tally_content`             : extract tally results/values from tally content section
- `build_tally_Pandas_dataframe`    : make Pandas dataframe from the main results NumPy array and the metadata
- `search_for_dump_parameters`      : attempt to auto find &#34;dump&#34; parameters via possible standard tally output file
- `determine_PHITS_output_file_type` : determine if a file is standard tally output or ASCII/binary dump file

&#39;&#39;&#39;
&#39;&#39;&#39;
Each function beings with a comment block containing the following sections:

    Description:


    Dependencies:


    Inputs:


    Outputs:

(&#34;Dependencies:&#34; is omitted when there are none.)        
&#39;&#39;&#39;

import sys
import os
import numpy as np
from munch import *
from pathlib import Path


# default program settings
launch_GUI = False
run_with_CLI_inputs = False
in_debug_mode = False # toggles printing of debug messages throughout the code
#in_debug_mode = True # toggles printing of debug messages throughout the code
test_explicit_files_dirs = False # used for testing specific files at the bottom of this file
#test_explicit_files_dirs = True

if __name__ == &#34;__main__&#34;:
    #in_debug_mode = True

    if test_explicit_files_dirs:
        in_debug_mode = True
        pass
    elif len(sys.argv) == 1:
        launch_GUI = True
    else:
        if &#39;-g&#39; in sys.argv or &#39;--GUI&#39; in sys.argv:
            launch_GUI = True
        else:
            run_with_CLI_inputs = True
            # CLI for PHITS Tools
            import argparse


if in_debug_mode:
    import pprint
    import time
    # Timer start
    start = time.time()



# use Path, get extension, check for existence of filename_err.extension


def parse_tally_output_file(tally_output_filepath, make_PandasDF = True, calculate_absolute_errors = True,
                            save_output_pickle = True, prefer_reading_existing_pickle = False):
    &#39;&#39;&#39;
    Description:
        Parse any PHITS tally output file, returning tally metadata and an array of its values (and optionally
        this data inside of a Pandas dataframe too).  Note the separate `parse_tally_dump_file` function for
        parsing PHITS dump files.  If a DCHAIN input file (output from the [T-Dchain] tally) or DCHAIN output
        `*.act` file is provided, an attempt will be made to import the [DCHAIN Tools module](https://github.com/Lindt8/DCHAIN-Tools) and process the found
        DCHAIN output files, returning the output dictionary object and (optionally) saving it to a pickle file.

    Dependencies:
        - `import numpy as np`
        - `import pandas as pd` (if `make_PandasDF = True`)
        - `import pickle` (if `save_output_pickle = True`)
        - `from munch import *`
        - `from pathlib import Path`

    Inputs:
       (required)

        - `tally_output_filepath` = file or filepath to the tally output file to be parsed

    Inputs:
       (optional)

       - `make_PandasDF` = A Boolean determining whether a Pandas dataframe of the tally data array will be made (D=`True`)
       - `calculate_absolute_errors` = A Boolean determining whether the absolute uncertainty of each tally output value
                      is to be calculated (simply as the product of the value and relative error); if `False`, the final
                      dimension of `tally_data`, `ierr`, will be of length-2 rather than length-3 (D=`True`)
       - `save_output_pickle` = A Boolean determining whether the `tally_output` dictionary object is saved as a pickle file;
                      if `True`, the file will be saved with the same path and name as the provided PHITS tally output file
                      but with the .pickle extension. (D=`True`)
       - `prefer_reading_existing_pickle` = A Boolean determining what this function does if the pickle file this function
                      seeks to generate already exists.  If `False` (default behavior), this function will parse the PHITS
                      output files as usual and overwrite the existing pickle file.  If `True`, this function will instead
                      simply just read the existing found pickle file and return its stored `tally_output` contents. (D=`False`)

    Output:
        - `tally_output` = a dictionary object with the below keys and values:
            - `&#39;tally_data&#39;` = a 10-dimensional NumPy array containing all tally results, explained in more detail below
            - `&#39;tally_metadata&#39;` = a dictionary/Munch object with various data extracted from the tally output file, such as axis binning and units
            - `&#39;tally_dataframe&#39;` = (optionally included if setting `make_PandasDF = True`) a Pandas dataframe version of `tally_data`


    Notes:

       Many quantities can be scored across the various tallies in the PHITS code.  This function outputs a &#34;universal&#34;
       array `tally_data` that can accomodate all of the different scoring geometry meshes, physical quantities with
       assigned meshes, and output axes provided within PHITS.  This is achieved with a 10-dimensional array accessible as

       `tally_data[ ir, iy, iz, ie, it, ia, il, ip, ic, ierr ]`, with indices explained below:

       Tally data indices and corresponding mesh/axis:

        - `0` | `ir`, Geometry mesh: `reg` / `x` / `r` / `tet` ([T-Cross] `ir surf` if `mesh=r-z` with `enclos=0`)
        - `1` | `iy`, Geometry mesh:  `1` / `y` / `1`
        - `2` | `iz`, Geometry mesh:  `1` / `z` / `z` ([T-Cross] `iz surf` if `mesh=xyz` or `mesh=r-z` with `enclos=0`)
        - `3` | `ie`, Energy mesh: `eng` ([T-Deposit2] `eng1`)
        - `4` | `it`, Time mesh
        - `5` | `ia`, Angle mesh
        - `6` | `il`, LET mesh
        - `7` | `ip`, Particle type (`part = `)
        - `8` | `ic`, Special: [T-Deposit2] `eng2`; [T-Yield] `mass`, `charge`, `chart`; [T-Interact] `act`
        - `9` | `ierr = 0/1/2`, Value / relative uncertainty / absolute uncertainty (expanded to `3/4/5`, or `2/3` if
        `calculate_absolute_errors = False`, for [T-Cross] `mesh=r-z` with `enclos=0` case; see notes further below)

       -----

       By default, all array dimensions are length-1 (except `ierr`, which is length-3).  These dimensions are set/corrected
       automatically when parsing the tally output file.  Thus, for very simple tallies, most of these indices will be
       set to 0 when accessing tally results, e.g. `tally_data[2,0,0,:,0,0,0,:,0,:]` to access the full energy spectrum
       in the third region for all scored particles / particle groups with the values and uncertainties.

       The output `tally_metadata` dictionary contains all information needed to identify every bin along every
       dimension: region numbers/groups, particle names/groups, bin edges and midpoints for all mesh types
       (x, y, z, r, energy, angle, time, and LET) used in the tally.

       The `tally_dataframe` Pandas dataframe output functions as normal.  Note that a dictionary containing supplemental
       information that is common to all rows of the dataframe can be accessed with `tally_dataframe.attrs`.

       -----

       **Unsupported tallies and DCHAIN**

       At present, the following tallies are NOT supported by this function: [T-WWG], [T-WWBG], [T-Volume],
       [T-Userdefined], [T-Gshow], [T-Rshow], [T-3Dshow], [T-4Dtrack], and [T-Dchain]&amp;dagger;.

       &amp;dagger;If provided with the output file of [T-Dchain] (the input file for the DCHAIN code) or the `*.act` main
       output file produced by the DCHAIN code, this function will attempt to import the [DCHAIN Tools module](https://github.com/Lindt8/DCHAIN-Tools)
       and process the found DCHAIN output files, returning the output dictionary object and (optionally) saving it to a pickle file.
       Otherwise, for [T-Dchain] or [T-Yield] with `axis = dchain`, you can manually use the separate suite of parsing
       functions included in the [DCHAIN Tools](https://github.com/Lindt8/DCHAIN-Tools) module.

       -----

       **[T-Cross] special case**

       The [T-Cross] tally is unique (scoring across region boundaries rather than within regions), creating some
       additional challenges.
       In the `mesh = reg` case, much is the same except each region number is composed of the `r-from` and `r-to` values, e.g. `&#39;100 - 101&#39;`.

       For `xyz` and `r-z` meshes, an additional parameter is at play: `enclos`.
       By default, `enclos=0`.
       In the event `enclos=1` is set, the total number of geometric regions is still either `nx*ny*nz` or `nr*nz` for
       `xyz` and `r-z` meshes, respectively.
       For `enclos=0` in the `mesh = xyz` case, the length of the z dimension (`iz` index) is instead equal to `nzsurf`,
       which is simply one greater than `nz` (# regions = `nx*ny*(nz+1)`).

       For `enclos=0` in the `mesh = r-z` case, this is much more complicated as PHITS will output every combination of
       `nr*nzsurf` AND `nrsurf*nz`, noting `nzsurf=nz+1` and `nrsurf=nr+1` (or `nrsurf=nr` if the first radius bin edge
       is `r=0.0`).
       The solution implemented here is to, for only this circumstance (in only the `enclos=0 mesh=r-z` case),
       set the length of the `ir` and `iz` dimensions to `nrsurf` and `nzsurf`, respectively, and also
       to expand the length of the final dimension of `tally_data` from 3 to 6 (or from 2 to 4 if `calculate_absolute_errors=False`), where:

        - `ierr = 0/1/2` refer to the combinations of `nr` and `nzsurf` (or `0/1` if `calculate_absolute_errors=False`)
        - `ierr = 3/4/5` refer to the combinations of `nrsurf` and `nz` (or `2/3` if `calculate_absolute_errors=False`)

       In this case, the Pandas dataframe, if enabled, will contain 3 (or 2) extra columns `value2` and `rel.err.2` [and `abs.err.2`],
       which correspond to the combinations of `nrsurf` and `nz` (while the original columns without the &#34;2&#34; refer to
       values for combinations of and `nr` and `nzsurf`).

       -----

       **[T-Yield] special case**

       [T-Yield] is also a bit exceptional.  When setting the `axis` parameter equal to `charge`, `mass`, or `chart`,
       the `ic` dimension of `tally_data` is used for each entry of charge (proton number, Z), mass (A), or
       isotope/isomer, respectively.

       In the case of `axis = charge` or `axis = mass`, the value of `ic` refers to the actual charge/proton number Z
       or mass number A when accessing `tally_data`; for instance, `tally_data[:,:,:,:,:,:,:,:,28,:]`
       references results from nuclei with Z=28 if `axis = charge` or A=28 if `axis = mass`.  The length of the `ic`
       dimension is initialized as 130 or 320 but is later reduced to only just include the highest charge or mass value.

       In the case of `axis = chart`, the length of the `ic` dimension is initially set equal to the `mxnuclei` parameter
       in the [T-Yield] tally.  If `mxnuclei = 0` is set, then the length of the `ic` dimension is initially set to 10,000.
       This `ic` dimension length is later reduced to the total number of unique nuclides found in the output.
       Owing to the huge number of possible nuclides, a list of found nuclides with nonzero yield is assembled and
       added to `tally_metadata` under the keys `nuclide_ZZZAAAM_list` and `nuclide_isomer_list`, i.e.
       `tally_metadata[&#39;nuclide_ZZZAAAM_list&#39;]` and `tally_metadata[&#39;nuclide_isomer_list&#39;]`.
       These lists should be referenced to see what nuclide each of index `ic` refers to.
       The entries of the ZZZAAAM list are intergers calculated with the formula 10000\*Z + 10\*A + M, where M is the
       metastable state of the isomer (0 = ground state, 1 = 1st metastable/isomeric state, etc.).  The entries
       of the isomer list are these same nuclides in the same order but written as plaintext strings, e.g. `&#39;Al-28&#39;` and `&#39;Xe-133m1&#39;`.
       The lists are ordered in the same order nuclides are encountered while parsing the output file.
       Thus, to sensibly access the yield of a specific nuclide, one must first find its index `ic` in one of the two
       metadata lists of ZZZAAAM values or isomer names and then use that to access `tally_data`.  For example, to get
       the yield results of production of carbon-14 (C-14), one would use the following code:

       `ic = tally_metadata[&#39;nuclide_ZZZAAAM_list&#39;].index(60140)`

       OR

       `ic = tally_metadata[&#39;nuclide_isomer_list&#39;].index(&#39;C-14&#39;)`

       then

       `my_yield_values = tally_data[:,:,:,:,:,:,:,:,ic,:]`


    &#39;&#39;&#39;

    &#39;&#39;&#39;
    The old [T-Cross] mesh=r-z enclos=0 solution is written below:
        The solution implemented here uses `ir` to iterate `nr`, `iy` to iterate `nrsurf`, `iz` to
        iterate `nz`, and `ic` to iterate `nzsurf`.  Since only `rsurf*z [iy,iz]` and `r*zsurf [ir,ic]` pairs exist,
        when one pair is being written, the other will be `[-1,-1]`, thus the lengths of these dimensions for the array
        are increased by an extra 1 to prevent an overlap in the data written.
    &#39;&#39;&#39;
    pickle_filepath = Path(tally_output_filepath.parent, tally_output_filepath.stem + &#39;.pickle&#39;)
    if prefer_reading_existing_pickle and os.path.isfile(pickle_filepath):
        import pickle
        print(&#39;Reading found pickle file: &#39;, pickle_filepath)
        with open(pickle_filepath, &#39;rb&#39;) as handle:
            tally_output = pickle.load(handle)
        return tally_output

    # main toggled settings
    #calculate_absolute_errors = True
    construct_Pandas_frame_from_array = make_PandasDF
    #process_all_tally_out_files_in_directory = False
    save_pickle_files_of_output = save_output_pickle  # save metadata, array, and Pandas frame in a pickled dictionary object

    if construct_Pandas_frame_from_array: import pandas as pd

    # Check if is _err or _dmp file (or normal value file)
    is_val_file = False
    is_err_file = False
    is_dmp_file = False
    if tally_output_filepath.stem[-4:] == &#39;_err&#39;:
        is_err_file = True
    elif tally_output_filepath.stem[-4:] == &#39;_dmp&#39;:
        is_dmp_file = True
    else:
        is_val_file = True

    if is_dmp_file:
        print(&#39;ERROR: The provided file is a &#34;dump&#34; output file. Use the function titled &#34;parse_tally_dump_file&#34; to process it instead.&#39;)
        return None

    if is_err_file:
        print(&#39;WARNING: Provided file contains just relative uncertainties.&#39;,str(tally_output_filepath))
        potential_val_file = Path(tally_output_filepath.parent, tally_output_filepath.stem.replace(&#39;_err&#39;,&#39;&#39;) + tally_output_filepath.suffix)
        if potential_val_file.is_file():
            print(&#39;\t Instead, both it and the file with tally values will be parsed.&#39;)
            potential_err_file = tally_output_filepath
            tally_output_filepath = potential_val_file
            is_val_file = True
            is_err_file = False
        else:
            print(&#39;\t The corresponding file with tally values could not be found, so only these uncertainties will be parsed.&#39;)

    # Split content of output file into header and content
    if in_debug_mode: print(&#34;\nSplitting output into header and content...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    tally_header, tally_content = split_into_header_and_content(tally_output_filepath)
    if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    # print(len(tally_content))

    # Check if *_err file exists
    potential_err_file = Path(tally_output_filepath.parent, tally_output_filepath.stem + &#39;_err&#39; + tally_output_filepath.suffix)
    is_err_in_separate_file = potential_err_file.is_file()  # for some tallies/meshes, uncertainties are stored in a separate identically-formatted file

    # Extract tally metadata
    if in_debug_mode: print(&#34;\nExtracting tally metadata...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    tally_metadata = parse_tally_header(tally_header, tally_content)
    if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    if in_debug_mode: pprint.pp(dict(tally_metadata))
    # Check if tally_type is among those supported.
    unsupported_tally_types = [&#39;[T-WWG]&#39;, &#39;[T-WWBG]&#39;, &#39;[T-Volume]&#39;, &#39;[T-Userdefined]&#39;, &#39;[T-Gshow]&#39;, &#39;[T-Rshow]&#39;,
                               &#39;[T-3Dshow]&#39;, &#39;[T-4Dtrack]&#39;, &#39;[T-Dchain]&#39;, &#39;UNKNOWN&#39;]
    if tally_metadata[&#39;tally_type&#39;] in unsupported_tally_types:
        print(&#39;ERROR! tally type&#39;,tally_metadata[&#39;tally_type&#39;],&#39;is not supported by this function!&#39;)
        if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Dchain]&#39; or tally_output_filepath.suffix == &#39;.act&#39;:
            print(&#39;Instead, the DCHAIN Tools module is used to process the DCHAIN output files with the same basename of the provided file.&#39;)
            dchain_tools_url = &#39;github.com/Lindt8/DCHAIN-Tools&#39;
            dchain_tools_go_to_github_str = &#39;The DCHAIN Tools module ( &#39;+dchain_tools_url+&#39; ) is capable of parsing all DCHAIN-related output.&#39;
            if tally_output_filepath.suffix != &#39;.act&#39;:
                act_filepath = Path(tally_output_filepath.parent, tally_output_filepath.stem + &#39;.act&#39;)
                if not act_filepath.is_file():
                    # DCHAIN output is not present in directory
                    print(&#39;Failed to find the main DCHAIN *.act output file:&#39;,act_filepath)
                    print(&#39;Aborting this process...&#39;)
                    return None
            try:
                from dchain_tools import process_dchain_simulation_output
            except:
                print(&#39;Failed to import the DCHAIN Tools module; to parse DCHAIN output via PHITS Tools, please install DCHAIN Tools and configure it in your Python environment&#39;)
                return None
            simulation_folder_path = str(Path(tally_output_filepath.parent)) + &#39;\\&#39;
            simulation_basename = str(tally_output_filepath.stem)
            dchain_output = process_dchain_simulation_output(simulation_folder_path,simulation_basename,process_DCS_file=True)
            if save_output_pickle:
                import pickle
                path_to_pickle_file = Path(tally_output_filepath.parent, tally_output_filepath.stem + &#39;.pickle&#39;)
                if in_debug_mode: print(&#34;\nWriting output to pickle file...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
                with open(path_to_pickle_file, &#39;wb&#39;) as handle:
                    pickle.dump(dchain_output, handle, protocol=pickle.HIGHEST_PROTOCOL)
                    print(&#39;Pickle file written:&#39;, path_to_pickle_file, &#39;\n&#39;)
                if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
            return dchain_output
        else:
            return None
    if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Yield]&#39; and tally_metadata[&#39;axis&#39;] == &#39;dchain&#39;:
        dchain_tools_url = &#39;github.com/Lindt8/DCHAIN-Tools&#39;
        print(&#39;This function does not support [T-Yield] with setting &#34;axis = dchain&#34;.&#39;)
        print(&#39;However, the DCHAIN Tools module (&#39;, dchain_tools_url, &#39;) is capable of parsing all DCHAIN-related output.&#39;)
        return None

    # Initialize tally data array with zeros
    tally_data = initialize_tally_array(tally_metadata, include_abs_err=calculate_absolute_errors)

    # Parse tally data
    if is_val_file:
        err_mode = False
    else: # if is_err_file
        err_mode = True
    if in_debug_mode: print(&#34;\nParsing tally data...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    if tally_metadata[&#39;tally_type&#39;]==&#39;[T-Yield]&#39; and tally_metadata[&#39;axis&#39;] in [&#39;chart&#39;,&#39;charge&#39;,&#39;mass&#39;]: # need to update metadata too
        tally_data, tally_metadata = parse_tally_content(tally_data, tally_metadata, tally_content, is_err_in_separate_file, err_mode=err_mode)
    else:
        tally_data = parse_tally_content(tally_data, tally_metadata, tally_content, is_err_in_separate_file, err_mode=err_mode)
    if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    err_data_found = True
    if tally_metadata[&#39;axis_dimensions&#39;] == 2 and tally_metadata[&#39;2D-type&#39;] != 4:
        if is_err_file:
            err_data_found = False
        elif is_err_in_separate_file:
            err_tally_header, err_tally_content = split_into_header_and_content(potential_err_file)
            if in_debug_mode: print(&#34;\nParsing tally error...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
            if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Yield]&#39; and tally_metadata[&#39;axis&#39;] in [&#39;chart&#39;,&#39;charge&#39;,&#39;mass&#39;]:  # need to update metadata too
                tally_data, tally_metadata = parse_tally_content(tally_data, tally_metadata, err_tally_content, is_err_in_separate_file,err_mode=True)
            else:
                tally_data = parse_tally_content(tally_data, tally_metadata, err_tally_content, is_err_in_separate_file, err_mode=True)
            if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
        else:
            print(&#39;WARNING: A separate file ending in &#34;_err&#34; containing uncertainties should exist but was not found.&#39;)
            err_data_found = False
    if calculate_absolute_errors:
        if err_data_found:
            if in_debug_mode: print(&#34;\nCalculating absolute errors...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
            tally_data = calculate_tally_absolute_errors(tally_data)
            if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
        elif is_err_file:
            print(&#39;WARNING: Absolute errors not calculated since the main tally values file was not found.&#39;)
        else:
            print(&#39;WARNING: Absolute errors not calculated since the _err file was not found.&#39;)
    # Generate Pandas dataframe of tally results
    if construct_Pandas_frame_from_array:
        if in_debug_mode: print(&#34;\nConstructing Pandas dataframe...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
        tally_Pandas_df = build_tally_Pandas_dataframe(tally_data, tally_metadata)
        if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    else:
        tally_Pandas_df = None

    tally_output = {
        &#39;tally_data&#39;: tally_data,
        &#39;tally_metadata&#39;: tally_metadata,
        &#39;tally_dataframe&#39;: tally_Pandas_df,
    }

    if save_output_pickle:
        import pickle
        path_to_pickle_file = Path(tally_output_filepath.parent, tally_output_filepath.stem + &#39;.pickle&#39;)
        if in_debug_mode: print(&#34;\nWriting output to pickle file...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
        with open(path_to_pickle_file, &#39;wb&#39;) as handle:
            pickle.dump(tally_output, handle, protocol=pickle.HIGHEST_PROTOCOL)
            print(&#39;Pickle file written:&#39;, path_to_pickle_file, &#39;\n&#39;)
        if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))

    return tally_output



def parse_tally_dump_file(path_to_dump_file, dump_data_number=None , dump_data_sequence=None, return_directional_info=False,
                          use_degrees=False,max_entries_read=None,return_namedtuple_list=True,
                          return_Pandas_dataframe=True, save_namedtuple_list=False, save_Pandas_dataframe=False):
    &#39;&#39;&#39;
    Description:
        Parses the dump file of a [T-Cross], [T-Product], or [T-Time] tally generated by PHITS, in ASCII or binary format.

    Dependencies:
        - `from collections import namedtuple`
        - `from scipy.io import FortranFile`
        - `import pandas as pd` (if `return_Pandas_dataframe = True`)
        - `import dill` (if `save_namedtuple_list = True`)
        - `import lzma` (if `save_namedtuple_list = True`)

    Inputs:
       (required)

        - `path_to_dump_file` = string or Path object denoting the path to the dump tally output file to be parsed
        - `dump_data_number` = integer number of data per row in dump file, binary if &gt;0 and ASCII if &lt;0.
                 This should match the value following `dump=` in the tally creating the dump file. (D=`None`)
                 If not specified, the search_for_dump_parameters() function will attempt to find it automatically.
        - `dump_data_sequence` = string or list of integers with the same number of entries as `dump_data_number`,
                 mapping each column in the dump file to their physical quantities.  (D=`None`)
                 This should match the line following the `dump=` line in the tally creating the dump file.
                 See PHITS manual section &#34;6.7.22 dump parameter&#34; for further explanations of these values.
                 If not specified, the search_for_dump_parameters() function will attempt to find it automatically.

    Inputs:
       (optional)

        - `return_directional_info` = (optional, D=`False`) Boolean designating whether extra directional information
                 should be calculated and returned; these include: radial distance `r` from the origin in cm,
                 radial distance `rho` from the z-axis in cm,
                 polar angle `theta` between the direction vector and z-axis in radians [0,pi] (or degrees), and
                 azimuthal angle `phi` of the direction vector in radians [-pi,pi] (or degrees).
                 Note: This option requires all position and direction values [x,y,z,u,v,w] to be included in the dump file.
        - `use_degrees` = (optional, D=`False`) Boolean designating whether angles `theta` and `phi` are returned
                 in units of degrees. Default setting is to return angles in radians.
        - `max_entries_read` = (optional, D=`None`) integer number specifying the maximum number of entries/records
                 of the dump file to be read.  By default, all records in the dump file are read.
        - `return_namedtuple_list` = (optional, D=`True`) Boolean designating whether `dump_data_list` is returned.
        - `return_Pandas_dataframe` = (optional, D=`True`) Boolean designating whether `dump_data_frame` is returned.
        - `save_namedtuple_list` = (optional, D=`False`) Boolean designating whether `dump_data_list` is saved to a dill file,
                which will be compressed with LZMA (built-in with Python)
                (for complicated reasons, objects containing namedtuples cannot be easily saved with pickle but can with dill).
                This *.dill.xz file can then be opened (after importing `dill` and `lzma`) as:
                `with lzma.open(path_to_dillxz_file, &#39;rb&#39;) as file: dump_data_list = dill.load(file)`
        - `save_Pandas_dataframe` = (optional, D=`False`) Boolean designating whether `dump_data_frame` is saved to a pickle
                file (via Pandas .to_pickle()).

    Outputs:
        - `dump_data_list` = List of length equal to the number of records contained in the file. Each entry in the list
                 is a namedtuple containing all of the physical information in the dump file for a given particle event,
                 in the same order as specified in `dump_data_sequence` and using the same naming conventions for keys as
                 described in the PHITS manual section &#34;6.7.22 dump parameter&#34;
                 (`kf`, `x`, `y`, `z`, `u`, `v`, `w`, `e`, `wt`, `time`, `c1`, `c2`, `c3`, `sx`, `sy`, `sz`, `name`, `nocas`, `nobch`, `no`).
                 If `return_directional_info = True`, `r`, `rho`, `theta`, and `phi` are appended to the end of this namedtuple, in that order.
        - `dump_data_frame` = A Pandas dataframe created from `dump_data_list` with columns for each physical quantity
                 and rows for each record included in the dump file.
    &#39;&#39;&#39;

    from collections import namedtuple
    from typing import NamedTuple
    from scipy.io import FortranFile
    if return_Pandas_dataframe or save_Pandas_dataframe:
        import pandas as pd
    if save_Pandas_dataframe or save_namedtuple_list:
        #import pickle
        import dill

    if not return_namedtuple_list and not return_Pandas_dataframe and not save_namedtuple_list and not save_Pandas_dataframe:
        raise ValueError(&#39;ERROR: All &#34;return_namedtuple_list&#34;, &#34;return_Pandas_dataframe&#34;, &#34;save_namedtuple_list&#34;, and &#34;save_Pandas_dataframe&#34; are False. Enable at least one to use this function.&#39;)

    if dump_data_number == None or dump_data_sequence == None:
        dump_data_number, dump_data_sequence = search_for_dump_parameters(path_to_dump_file)
    if dump_data_number == None or dump_data_sequence == None:
        raise ValueError(&#34;Please manually specify &#39;dump_data_number&#39; and &#39;dump_data_sequence&#39;; these were not inputted and could not be automatically found from an origin tally standard output file.&#34;)
        #return None

    if isinstance(dump_data_sequence, str):
        dump_data_sequence = dump_data_sequence.split()
        dump_data_sequence = [int(i) for i in dump_data_sequence]
    dump_file_is_binary = True if (dump_data_number &gt; 0) else False  # if not binary, file will be ASCII
    data_values_per_line = abs(dump_data_number)
    if data_values_per_line != len(dump_data_sequence):
        raise ValueError(&#39;ERROR: Number of values in &#34;dump_data_sequence&#34; is not equal to &#34;dump_data_number&#34;&#39;)

    # Generate NamedTuple for storing record information
    # See PHITS manual section &#34;6.7.22 dump parameter&#34; for descriptions of these values
    dump_quantities = [&#39;kf&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;e&#39;, &#39;wt&#39;, &#39;time&#39;, &#39;c1&#39;, &#39;c2&#39;, &#39;c3&#39;, &#39;sx&#39;, &#39;sy&#39;, &#39;sz&#39;,
                       &#39;name&#39;, &#39;nocas&#39;, &#39;nobch&#39;, &#39;no&#39;]
    ordered_record_entries_list = [dump_quantities[i - 1] for i in dump_data_sequence]
    rawRecord = namedtuple(&#39;rawRecord&#39;, ordered_record_entries_list)
    if return_directional_info:
        ordered_record_entries_list += [&#39;r&#39;, &#39;rho&#39;, &#39;theta&#39;, &#39;phi&#39;]
        angle_units_mult = 1
        if use_degrees: angle_units_mult = 180 / np.pi
    Record = namedtuple(&#39;Record&#39;, ordered_record_entries_list)

    records_list = []
    if dump_file_is_binary:
        # Read binary dump file; extract each record (particle)
        file_size_bytes = os.path.getsize(path_to_dump_file)
        record_size_bytes = (data_values_per_line + 1) * 8  # each record has 8 bytes per data value plus an 8-byte record end
        num_records = int(file_size_bytes / record_size_bytes)
        if max_entries_read != None:
            if max_entries_read &lt; num_records:
                num_records = max_entries_read
        # print(num_records)
        current_record_count = 0
        if return_directional_info:
            with FortranFile(path_to_dump_file, &#39;r&#39;) as f:
                while current_record_count &lt; num_records:
                    current_record_count += 1
                    raw_values = f.read_reals(float)
                    rawrecord = rawRecord(*raw_values)
                    # calculate r, rho, theta (w.r.t. z-axis), and phi (w.r.t. x axis)
                    r = np.sqrt(rawrecord.x ** 2 + rawrecord.y ** 2 + rawrecord.z ** 2)
                    rho = np.sqrt(rawrecord.x ** 2 + rawrecord.y ** 2)
                    dir_vector = [rawrecord.u, rawrecord.v, rawrecord.w]
                    theta = np.arccos(np.clip(np.dot(dir_vector, [0, 0, 1]), -1.0, 1.0)) * angle_units_mult
                    phi = np.arctan2(rawrecord.y, rawrecord.x) * angle_units_mult
                    record = Record(*raw_values, r, rho, theta, phi)
                    records_list.append(record)
        else: # just return data in dump file
            with FortranFile(path_to_dump_file, &#39;r&#39;) as f:
                while current_record_count &lt; num_records:
                    current_record_count += 1
                    raw_values = f.read_reals(float)
                    record = Record(*raw_values)
                    records_list.append(record)
    else: # file is ASCII
        if max_entries_read == None:
            max_entries_read = np.inf
        if return_directional_info:
            with open(path_to_dump_file, &#39;r&#39;) as f:
                current_record_count = 0
                for line in f:
                    current_record_count += 1
                    if current_record_count &gt; max_entries_read: break
                    line_str_values = line.replace(&#39;D&#39;, &#39;E&#39;).split()
                    raw_values = [float(i) for i in line_str_values]
                    rawrecord = rawRecord(*raw_values)
                    # calculate r, rho, theta (w.r.t. z-axis), and phi (w.r.t. x axis)
                    r = np.sqrt(rawrecord.x ** 2 + rawrecord.y ** 2 + rawrecord.z ** 2)
                    rho = np.sqrt(rawrecord.x ** 2 + rawrecord.y ** 2)
                    dir_vector = [rawrecord.u, rawrecord.v, rawrecord.w]
                    theta = np.arccos(np.clip(np.dot(dir_vector, [0, 0, 1]), -1.0, 1.0)) * angle_units_mult
                    phi = np.arctan2(rawrecord.y, rawrecord.x) * angle_units_mult
                    record = Record(*raw_values, r, rho, theta, phi)
                    records_list.append(record)
        else: # just return data in dump file
            with open(path_to_dump_file, &#39;r&#39;) as f:
                current_record_count = 0
                for line in f:
                    current_record_count += 1
                    if current_record_count &gt; max_entries_read: break
                    line_str_values = line.replace(&#39;D&#39;, &#39;E&#39;).split()
                    raw_values = [float(i) for i in line_str_values]
                    record = Record(*raw_values)
                    records_list.append(record)
    #print(record)

    if save_namedtuple_list:
        import lzma
        path_to_dump_file = Path(path_to_dump_file)
        pickle_path = Path(path_to_dump_file.parent, path_to_dump_file.stem + &#39;_namedtuple_list.dill.xz&#39;)
        with lzma.open(pickle_path, &#39;wb&#39;) as handle:
            dill.dump(records_list, handle, protocol=dill.HIGHEST_PROTOCOL)
            print(&#39;Pickle file written:&#39;, pickle_path, &#39;\n&#39;)

    if return_Pandas_dataframe or save_Pandas_dataframe:
        # Make Pandas dataframe from list of records
        records_df = pd.DataFrame(records_list, columns=Record._fields)
        if save_Pandas_dataframe:
            path_to_dump_file= Path(path_to_dump_file)
            pickle_path = Path(path_to_dump_file.parent, path_to_dump_file.stem + &#39;_Pandas_df.pickle&#39;)
            records_df.to_pickle(pickle_path)
            #with open(pickle_path, &#39;wb&#39;) as handle:
            #    pickle.dump(records_df, handle, protocol=pickle.HIGHEST_PROTOCOL)
            #    print(&#39;Pickle file written:&#39;, pickle_path, &#39;\n&#39;)

    if return_namedtuple_list and return_Pandas_dataframe:
        return records_list, records_df
    elif return_namedtuple_list:
        return records_list
    elif return_Pandas_dataframe:
        return records_df
    else:
        return None




def parse_all_tally_output_in_dir(tally_output_dirpath, output_file_suffix = &#39;.out&#39;, output_file_prefix = &#39;&#39;,
                                  output_file_required_string=&#39;&#39;, include_subdirectories=False,  return_tally_output=False,
                                  make_PandasDF=True, calculate_absolute_errors=True,
                                  save_output_pickle=True, prefer_reading_existing_pickle=False,
                                  include_dump_files=False,
                                  dump_data_number=None , dump_data_sequence=None,
                                  dump_return_directional_info=False, dump_use_degrees=False,
                                  dump_max_entries_read=None,
                                  dump_save_namedtuple_list=True, dump_save_Pandas_dataframe=True
                                  ):
    &#39;&#39;&#39;
    Description:
        Parse all standard PHITS tally output files in a directory, returning either a list of dictionaries containing
        tally metadata and an array of values from each tally output (and optionally this data inside of a Pandas dataframe too)
        or a list of filepaths to pickle files containing these dictionaries, as created with the `parse_tally_output_file()` function.
        This function allows selective processing of files in the directory by specification of strings which must
        appear at the start, end, and/or anywhere within each filename.
        Even if a file satisfies all of these naming criteria, the function will also check the first line of the file
        to determine if it is a valid tally output file (meaning, it will skip files such as phits.out and batch.out).
        It will also skip over &#34;_err&#34; uncertainty files as these are automatically found by the `parse_tally_output_file()`
        function after it processes that tally&#39;s main output file.
        This function will mainly process standard tally output files, but it can optionally process tally &#34;dump&#34; files too,
        though it can only save the dump outputs to its dill/pickle files and not return the (quite large) dump data objects.
        The filenames of saved dump data will not be included in the returned list.

    Dependencies:
        - `import os`
        - `import numpy as np`
        - `import pandas as pd` (if `make_PandasDF = True`)
        - `import pickle` (if `save_output_pickle = True`)
        - `from munch import *`
        - `from pathlib import Path`

    Inputs:
       (required)

        - `tally_output_dirpath` = Path (string or path object) to the tally output directory to be searched and parsed

    Inputs:
       (optional)

       - `output_file_suffix` = A string specifying what characters processed filenames (including the file extension)
                      must end in to be included.  This condition is not enforced if set to an empty string `&#39;&#39;`. (D=`&#39;.out&#39;`)
       - `output_file_prefix` = A string specifying what characters processed filenames (including the file extension)
                      must begin with to be included.  This condition is not enforced if set to an empty string `&#39;&#39;`. (D=`&#39;&#39;`)
       - `output_file_required_string` = A string which must be present anywhere within processed filenames (including the
                      file extension) to be included.  This condition is not enforced if set to an empty string `&#39;&#39;`. (D=`&#39;&#39;`)
       - `include_subdirectories` = A Boolean determining whether this function searches and processes all included
                      tally output files in this directory AND deeper subdirectories if set to `True`
                      or only the files directly within the provided directory `tally_output_dirpath` if set to `False` (D=`False`)
       - `return_tally_output` = A Boolean determining whether this function returns a list of `tally_output` dictionaries
                      if set to `True` or just a list of filepaths to the pickle files containing these dictionaries
                      if set to `False` (D=`False`)
       - `include_dump_files` = A Boolean determining whether dump files will be processed too or skipped. (D=`False`)
                      Settings to be applied to all encountered dump files can be specified per the optional inputs
                      detailed below which are simply passed to the `parse_tally_dump_file()` function.  Note that parameters
                      `return_namedtuple_list` and `return_Pandas_dataframe` will always be `False` when dump files are
                      processed in a directory with this function; instead, `save_namedtuple_list` and `save_Pandas_dataframe`
                      are by default set to `True` when parsing dump files in a directory with this function.  (Be warned,
                      if the dump file is large, the produced files from parsing them will be too.)

    Inputs:
       (optional, the same as in and directly passed to the `parse_tally_output_file()` function)

       - `make_PandasDF` = A Boolean determining whether a Pandas dataframe of the tally data array will be made (D=`True`)
       - `calculate_absolute_errors` = A Boolean determining whether the absolute uncertainty of each tally output value
                      is to be calculated (simply as the product of the value and relative error); if `False`, the final
                      dimension of `tally_data`, `ierr`, will be of length-2 rather than length-3 (D=`True`)
       - `save_output_pickle` = A Boolean determining whether the `tally_output` dictionary object is saved as a pickle file;
                      if `True`, the file will be saved with the same path and name as the provided PHITS tally output file
                      but with the .pickle extension. (D=`True`)
       - `prefer_reading_existing_pickle` = A Boolean determining what this function does if the pickle file this function
                      seeks to generate already exists.  If `False` (default behavior), this function will parse the PHITS
                      output files as usual and overwrite the existing pickle file.  If `True`, this function will instead
                      simply just read the existing found pickle file and return its stored `tally_output` contents. (D=`False`)

    Inputs:
       (optional, the same as in and directly passed to the `parse_tally_dump_file()` function)

       - `dump_data_number` = integer number of data per row in dump file, binary if &gt;0 and ASCII if &lt;0.
                This should match the value following `dump=` in the tally creating the dump file. (D=`None`)
                If not specified, the search_for_dump_parameters() function will attempt to find it automatically.
       - `dump_data_sequence` = string or list of integers with the same number of entries as `dump_data_number`,
                mapping each column in the dump file to their physical quantities.  (D=`None`)
                This should match the line following the `dump=` line in the tally creating the dump file.
                See PHITS manual section &#34;6.7.22 dump parameter&#34; for further explanations of these values.
                If not specified, the search_for_dump_parameters() function will attempt to find it automatically.
       - `dump_return_directional_info` = (optional, D=`False`) Boolean designating whether extra directional information
                should be calculated and returned; these include: radial distance `r` from the origin in cm,
                radial distance `rho` from the z-axis in cm,
                polar angle `theta` between the direction vector and z-axis in radians [0,pi] (or degrees), and
                azimuthal angle `phi` of the direction vector in radians [-pi,pi] (or degrees).
                Note: This option requires all position and direction values [x,y,z,u,v,w] to be included in the dump file.
       - `dump_use_degrees` = (optional, D=`False`) Boolean designating whether angles `theta` and `phi` are returned
                in units of degrees. Default setting is to return angles in radians.
       - `dump_max_entries_read` = (optional, D=`None`) integer number specifying the maximum number of entries/records
                of the dump file to be read.  By default, all records in the dump file are read.
       - `dump_save_namedtuple_list` = (optional, D=`True`) Boolean designating whether `dump_data_list` is saved to a dill file
               (for complicated reasons, objects containing namedtuples cannot be easily saved with pickle but can with dill).
       - `dump_save_Pandas_dataframe` = (optional, D=`True`) Boolean designating whether `dump_data_frame` is saved to a pickle
               file (via Pandas .to_pickle()).

    Output:
        - `tally_output_list` = a list of `tally_output` dictionary objects with the below keys and values / a list of
             file paths to pickle files containing `tally_output` dictionary objects:
            - `&#39;tally_data&#39;` = a 10-dimensional NumPy array containing all tally results, explained in more detail below
            - `&#39;tally_metadata&#39;` = a dictionary/Munch object with various data extracted from the tally output file, such as axis binning and units
            - `&#39;tally_dataframe&#39;` = (optionally included if setting `make_PandasDF = True`) a Pandas dataframe version of `tally_data`

    &#39;&#39;&#39;
    import os

    if not os.path.isdir(tally_output_dirpath):
        print(&#39;The provided path to &#34;tally_output_dir&#34; is not a directory:&#39;,tally_output_dirpath)
        if os.path.isfile(tally_output_dirpath):
            head, tail = os.path.split(tally_output_dirpath)
            tally_output_dirpath = head
            print(&#39;However, it is a valid path to a file; thus, its parent directory will be used:&#39;,tally_output_dirpath)
        else:
            print(&#39;Nor is it a valid path to a file. ERROR! Aborting...&#39;)
            return None

    if include_subdirectories:
        # Get paths to all files in this dir and subdirs
        files_in_dir = []
        for path, subdirs, files in os.walk(tally_output_dirpath):
            for name in files:
                files_in_dir.append(os.path.join(path, name))
    else:
        # Just get paths to files in this dir
        files_in_dir = [os.path.join(tally_output_dirpath, f) for f in os.listdir(tally_output_dirpath) if os.path.isfile(os.path.join(tally_output_dirpath, f))]

    # Determine which files should be parsed
    filepaths_to_process = []
    dump_filepaths_to_process = []
    len_suffix = len(output_file_suffix)
    len_prefix = len(output_file_prefix)
    len_reqstr = len(output_file_required_string)
    for f in files_in_dir:
        head, tail = os.path.split(f)
        if len_suffix &gt; 0 and tail[-len_suffix:] != output_file_suffix: continue
        if len_prefix &gt; 0 and tail[:len_prefix] != output_file_prefix: continue
        if len_reqstr &gt; 0 and output_file_required_string not in tail: continue
        if tail[(-4-len_suffix):] == &#39;_err&#39; + output_file_suffix: continue
        with open(f) as ff:
            try:
                first_line = ff.readline().strip()
            except: # triggered if encountering binary / non ASCII or UTF-8 file
                if include_dump_files and tail[(-4-len_suffix):] == &#39;_dmp&#39; + output_file_suffix:
                    dump_filepaths_to_process.append(f)
                continue
            if len(first_line) == 0: continue
            if first_line[0] != &#39;[&#39; :
                if include_dump_files and tail[(-4-len_suffix):] == &#39;_dmp&#39; + output_file_suffix:
                    dump_filepaths_to_process.append(f)
                continue
        filepaths_to_process.append(f)

    tally_output_pickle_path_list = []
    tally_output_list = []
    for f in filepaths_to_process:
        f = Path(f)
        path_to_pickle_file = Path(f.parent, f.stem + &#39;.pickle&#39;)
        tally_output_pickle_path_list.append(path_to_pickle_file)
        tally_output = parse_tally_output_file(f, make_PandasDF=make_PandasDF,
                                               calculate_absolute_errors=calculate_absolute_errors,
                                               save_output_pickle=save_output_pickle,
                                               prefer_reading_existing_pickle=prefer_reading_existing_pickle)
        if return_tally_output: tally_output_list.append(tally_output)

    if include_dump_files:
        for f in dump_filepaths_to_process:
            f = Path(f)
            parse_tally_dump_file(f, dump_data_number=dump_data_number, dump_data_sequence=dump_data_number,
                                  return_directional_info=dump_return_directional_info, use_degrees=dump_use_degrees,
                                  max_entries_read=dump_max_entries_read,
                                  return_namedtuple_list=False, return_Pandas_dataframe=False,
                                  save_namedtuple_list=dump_save_namedtuple_list,
                                  save_Pandas_dataframe=dump_save_Pandas_dataframe)

    if return_tally_output:
        return tally_output_list
    else:
        return tally_output_pickle_path_list


def fetch_MC_material(matid=None,matname=None,matsource=None,concentration_type=None,particle=None):
    &#39;&#39;&#39;
    Description:
        Returns a materials definition string formatted for use in PHITS or MCNP

    Dependencies:
        - `import os`
        - `import pickle`
        - PYTHONPATH environmental variable must be set and one entry must contain the directory
                which contains the vital &#34;MC_materials/Compiled_MC_materials.pkl&#34; file.

    Inputs:
       (required to enter `matid` OR `matname`, with `matid` taking priority if conflicting)

       - `matid` = ID number in the &#34;Compiled_MC_materials&#34; file
       - `matname` = exact name of material in &#34;Compiled_MC_materials&#34; file
       - `matsource` = exact source of material in &#34;Compiled_MC_materials&#34; file, only used when multiple
                materials have identical names
       - `concentration_type` = selection between `&#39;weight fraction&#39;` (default if no formula) and `&#39;atom fraction&#39;` (default if formula present) to be returned
       - `particle` = selection of whether natural (`&#39;photons&#39;`, default) or isotopic (`&#39;neutrons&#39;`) elements are used
                Note that if &#34;enriched&#34; or &#34;depleted&#34; appears in the material&#39;s name, particle=`&#39;neutrons&#39;` is set automatically.

    Outputs:
       - `mat_str` = string containing the material&#39;s information, ready to be inserted directly into a PHITS/MCNP input file
    &#39;&#39;&#39;
    import os
    import pickle
    if not matid and not matname:
        print(&#39;Either &#34;matid&#34; or &#34;matname&#34; MUST be defined&#39;)
        return None

    # First, locate and open materials library
    try:
        user_paths = os.environ[&#39;PYTHONPATH&#39;].split(os.pathsep)
        lib_file = None
        for i in user_paths:
            if &#39;phits_tools&#39; in i.lower() or &#39;phits-tools&#39; in i.lower():
                lib_file = i + r&#34;\MC_materials\Compiled_MC_materials&#34;
        if not lib_file:
            print(&#39;Could not find &#34;PHITS_tools&#34; folder in PYTHONPATH; this folder contains the vital &#34;MC_materials/Compiled_MC_materials.pkl&#34; file.&#39;)
    except KeyError:
        print(&#39;The PYTHONPATH environmental variable must be defined and contain the path to the directory holding &#34;MC_materials/Compiled_MC_materials.pkl&#34;&#39;)
        return None

    # Load materials library
    def load_obj(name ):
        with open(name + &#39;.pkl&#39;, &#39;rb&#39;) as f:
            return pickle.load(f)
    all_mats_list = load_obj(lib_file)

    if matid: # use mat ID number
        mi = int(matid)-1
        matname = all_mats_list[mi][&#39;name&#39;]
    else: # use material name and possibly source too
        # determine material
        mi = None
        # first check for exact matches
        matching_mi = []
        for i in range(len(all_mats_list)):
            if all_mats_list[i][&#39;name&#39;].lower()==matname.lower():
                matching_mi.append(i)
        if len(matching_mi)==1:
            mi = matching_mi[0]
        elif len(matching_mi)&gt;1:
            print(&#39;Found multiple materials with this identical matname value:&#39;)
            for mmi in matching_mi:
                print(&#39;\tmatid={}  matname=&#34;{}&#34;  source=&#34;{}&#34;&#39;.format(str(mmi+1),all_mats_list[mmi][&#39;name&#39;],all_mats_list[mmi][&#39;source&#39;]))
                if all_mats_list[mmi][&#39;source&#39;] and all_mats_list[mmi][&#39;source&#39;]==matsource:
                    mi = mmi
                    print(&#39;\t\t^ matches inputed &#34;matsource&#34; and will be used&#39;)
            if mi==None:
                print(&#39;Please enter a &#34;matsource&#34; value identical to one of these two (or the matid).&#39;)
                return None
        else: # Exact material name not found
            # search for similar entries
            similar_mi = []
            for i in range(len(all_mats_list)):
                if matname.lower() in all_mats_list[i][&#39;name&#39;].lower():
                    similar_mi.append(i)
            if len(similar_mi)==0:
                print(&#39;No materials with that exact name or names containing &#34;matname&#34; were found.&#39;)
                return None
            elif len(similar_mi)==1:
                mi = similar_mi[0]
                print(&#39;Found one similar material (matid={}  matname=&#34;{}&#34;  source=&#34;{}&#34;); using it.&#39;.format(str(mi+1),all_mats_list[mi][&#39;name&#39;],all_mats_list[mi][&#39;source&#39;]))
            else:
                print(&#39;Found no material with exact &#34;matname&#34; but {} with similar names:&#39;.format(len(similar_mi)))
                for smi in similar_mi:
                    print(&#39;\tmatid={}  matname=&#34;{}&#34;  source=&#34;{}&#34;&#39;.format(str(smi+1),all_mats_list[smi][&#39;name&#39;],all_mats_list[smi][&#39;source&#39;]))
                print(&#39;The first of these will be used.  If another material was desired, please enter its &#34;matid&#34; or exact &#34;matname&#34;.&#39;)
                mi = similar_mi[0]

    # Now that material ID has been found, generate text entry
    mat = all_mats_list[mi]
    banner_width = 60
    cc = &#39;$&#39;  # comment character

    entry_text  = &#39;\n&#39;+cc+&#39;*&#39;*banner_width + &#39;\n&#39;
    entry_text += cc+&#39;  {:&lt;3d} : {} \n&#39;.format(mi+1,mat[&#39;name&#39;])
    if mat[&#39;source&#39;] and mat[&#39;source&#39;]!=&#39;-&#39;:
        entry_text += cc+&#39;  Source = {} \n&#39;.format(mat[&#39;source&#39;])
    if mat[&#39;formula&#39;] and mat[&#39;formula&#39;]!=&#39;-&#39;:
        entry_text += cc+&#39;  Formula = {} \n&#39;.format(mat[&#39;formula&#39;])
    if mat[&#39;molecular weight&#39;] and mat[&#39;molecular weight&#39;]!=&#39;-&#39;:
        entry_text += cc+&#39;  Molecular weight (g/mole) = {} \n&#39;.format(mat[&#39;molecular weight&#39;])
    if mat[&#39;density&#39;] and mat[&#39;density&#39;]!=&#39;-&#39;:
        entry_text += cc+&#39;  Density (g/cm3) = {} \n&#39;.format(mat[&#39;density&#39;])
    if mat[&#39;total atom density&#39;] and mat[&#39;total atom density&#39;]!=&#39;-&#39;:
        if isinstance(mat[&#39;total atom density&#39;],str):
            entry_text += cc+&#39;  Total atom density (atoms/b-cm) = {} \n&#39;.format(mat[&#39;total atom density&#39;])
        else:
            entry_text += cc+&#39;  Total atom density (atoms/b-cm) = {:&lt;13.4E} \n&#39;.format(mat[&#39;total atom density&#39;])

    if concentration_type==None: # user did not select this, determine which is more appropriate automatically
        if mat[&#39;formula&#39;] and mat[&#39;formula&#39;]!=&#39;-&#39;:
            concentration_type = &#39;atom fraction&#39;
        else:
            concentration_type = &#39;weight fraction&#39;

    entry_text += cc+&#39;  Composition by {} \n&#39;.format(concentration_type)

    # Determine if neutron or photon entry will be used
    neutron_keyword_list = [&#39;depleted&#39;,&#39;enriched&#39;,&#39; heu&#39;,&#39; leu&#39;,&#39;uranium&#39;,&#39;plutonium&#39;,&#39;uranyl&#39;]
    if particle==None: # user did not select this, determine which is more appropriate automatically
        neutron_kw_found_in_name = False
        for nki in neutron_keyword_list:
            if nki in matname.lower():
                neutron_kw_found_in_name = True
        if neutron_kw_found_in_name:
            particle = &#39;neutrons&#39;
        else:
            particle = &#39;photons&#39;


    for j in range(len(mat[particle][concentration_type][&#39;ZA&#39;])):

        if isinstance(mat[particle][concentration_type][&#39;value&#39;][j],str):
            entry_format = &#39;{:4}    {:&gt;7}  {:13}   &#39;+cc+&#39;  {}&#39;  + &#39;\n&#39;
        else:
            entry_format = &#39;{:4}    {:&gt;7d}  {:&lt;13.6f}   &#39;+cc+&#39;  {}&#39;  + &#39;\n&#39;

        if j==0:
            mstr = &#39;M{:&lt;3}&#39;.format(mi+1)
        else:
            mstr = &#39; &#39;*4

        ZZZAAA = mat[particle][concentration_type][&#39;ZA&#39;][j]
        if ZZZAAA == &#39;-&#39;:
            ZZZAAA = mat[&#39;photons&#39;][concentration_type][&#39;ZA&#39;][j]

        Z = int(str(ZZZAAA)[:-3])
        A = str(ZZZAAA)[-3:]
        sym = Element_Z_to_Sym(Z)
        if A != &#39;000&#39;:
            isotope = sym+&#39;-&#39;+A.lstrip(&#39;0&#39;)
        else:
            isotope = sym

        entry_text += entry_format.format(mstr,ZZZAAA,mat[particle][concentration_type][&#39;value&#39;][j],isotope)
    entry_text  += cc+&#39;*&#39;*banner_width + &#39;\n&#39;

    return entry_text

def tally(data, bin_edges=[], min_bin_left_edge=None, max_bin_right_edge=None, nbins=None, bin_width=None, divide_by_bin_width=False, normalization=None, scaling_factor=1, place_overflow_at_ends=True, return_uncertainties=False, return_event_indices_histogram=False):
    &#39;&#39;&#39;
    Description:
        Tally number of incidences of values falling within a desired binning structure

    Inputs:
        - `data` = list of values to be tallied/histogrammed
        - `bin_edges` = list of N+1 bin edge values for a tally of N bins
        - `min_bin_left_edge` = left/minimum edge value of the first bin
        - `max_bin_right_edge` = right/maximum edge value of the last bin
        - `nbins` = number of equally-sized bins to be created from `min_bin_left_edge` to `max_bin_right_edge`
        - `bin_width` = constant width of bins to be created from `min_bin_left_edge` to `max_bin_right_edge`
        - `divide_by_bin_width` = Boolean denoting whether final bin values are divided by their bin widths (D=`False`)
        - `normalization` = determine how the resulting histogram is normalized (D=`None`), options are:
                       `[None, &#39;unity-sum&#39;, &#39;unity-max-val&#39;]`.  If `None`, no additional normalization is done.
                       If `unity-sum`, the data is normalized such that its sum will be 1.  If `unity-max-val`, the
                       data is normalized such that the maximum value is 1.  The operation occurs after any bin
                       width normalization from `divide_by_bin_width` but before any scaling from `scaling_factor`.
        - `scaling_factor` = value which all final bins are multiplied/scaled by (D=`1`)
        - `place_overflow_at_ends` = handling of values outside of binning range (D=`True`); if `True` extreme
                       values are tallied in the first/last bin, if `False` extreme values are discarded
        - `return_uncertainties` = Boolean denoting if should return an extra N-length list whose elements
                       are the statistical uncertainties (square root w/ normalizations) of the tally bins (D=`False`)
        - `return_event_indices_histogram` = Boolean denoting if should return an extra N-length list whose elements
                       are each a list of the event indices corresponding to each bin (D=`False`)

    Notes:
        Regarding the binning structure, this function only needs to be provided `bin_edges` directly (takes priority)
        or the information needed to calculate `bin_edges`, that is: `min_bin_left_edge` and `max_bin_right_edge` and
        either `nbins` or `bin_width`.  (Priority is given to `nbins` if both are provided.)

    Outputs:
        - `tallied_hist` = N-length list of tallied data
        - `bin_edges` = list of N+1 bin edge values for a tally of N bins
        - `tallied_hist_err` = (optional) N-length list of statistical uncertainties of tallied data
        - `tallied_event_indicies` = (optional) N-length list of, for each bin, a list of the event indices populating it
    &#39;&#39;&#39;

    normalization_valid_entries = [None, &#39;unity-sum&#39;, &#39;unity-max-val&#39;]
    if normalization not in normalization_valid_entries:
        print(&#34;Entered normalization option of &#34;,normalization,&#34; is not a valid option; please select from the following: [None, &#39;unity-sum&#39;, &#39;unity-max-val&#39;]&#34;.format())

    if len(bin_edges)!=0:
        bin_edges = np.array(bin_edges)
    else:
        if nbins != None:
            bin_edges = np.linspace(min_bin_left_edge,max_bin_right_edge,num=nbins+1)
        else:
            bin_edges = np.arange(min_bin_left_edge,max_bin_right_edge+bin_width,step=bin_width)

    nbins = len(bin_edges) - 1

    if return_event_indices_histogram:
        tallied_event_indicies = []
        tallied_hist = np.zeros(nbins)
        for i in range(nbins):
            tallied_event_indicies.append([])
        # events must be histogrammed manually
        for i, val in enumerate(data):
            if val &lt; bin_edges[0]:
                if place_overflow_at_ends:
                    tallied_hist[0] += 1
                    tallied_event_indicies[0].append(i)
                continue
            if val &gt; bin_edges[-1]:
                if place_overflow_at_ends:
                    tallied_hist[-1] += 1
                    tallied_event_indicies[-1].append(i)
                continue
            for j, be in enumerate(bin_edges):
                if be &gt; val: # found right edge of bin containing val
                    tallied_hist[j-1] += 1
                    tallied_event_indicies[j-1].append(i)
                    break



    else:
        tallied_hist, bins = np.histogram(data,bins=bin_edges)

    if return_uncertainties:
        tallied_hist_err = np.sqrt(tallied_hist)
        if divide_by_bin_width: tallied_hist_err = tallied_hist_err/(bin_edges[1:]-bin_edges[:-1])
        if normalization==&#39;unity-sum&#39;: tallied_hist_err = tallied_hist_err/np.sum(tallied_hist)
        if normalization==&#39;unity-max-val&#39;: tallied_hist_err = tallied_hist_err/np.max(tallied_hist)
        if scaling_factor != 1: tallied_hist_err = tallied_hist_err*scaling_factor

    if divide_by_bin_width: tallied_hist = tallied_hist/(bin_edges[1:]-bin_edges[:-1])
    if normalization==&#39;unity-sum&#39;: tallied_hist = tallied_hist/np.sum(tallied_hist)
    if normalization==&#39;unity-max-val&#39;: tallied_hist = tallied_hist/np.max(tallied_hist)
    if scaling_factor != 1: tallied_hist = tallied_hist*scaling_factor

    if return_event_indices_histogram:
        if return_uncertainties:
            return tallied_hist,bin_edges,tallied_hist_err,tallied_event_indicies
        else:
            return tallied_hist,bin_edges,tallied_event_indicies
    else:
        if return_uncertainties:
            return tallied_hist,bin_edges,tallied_hist_err
        else:
            return tallied_hist,bin_edges





def rebinner(output_xbins,input_xbins,input_ybins):
    &#34;&#34;&#34;
    Description:
        The purpose of this function is to rebin a set of y values corresponding to a set of x bins to a new set of x bins.
        The function seeks to be as generalized as possible, meaning bin sizes do not need to be consistent.

    Dependencies:
        `import numpy as np`

    Inputs:
      - `output_xbins` = output array containing bounds of x bins of length N; first entry is leftmost bin boundary
      - `input_xbins`  = input array containing bounds of x bins of length M; first entry is leftmost bin boundary
      - `input_ybins`  = input array containing y values of length M-1

    Outputs:
      - `output_ybins` = output array containing y values of length N-1
    &#34;&#34;&#34;

    N = len(output_xbins)
    M = len(input_xbins)
    output_ybins = np.zeros(N-1)

    for i in range(0,N-1):
        # For each output bin
        lxo = output_xbins[i]   # lower x value of output bin
        uxo = output_xbins[i+1] # upper x value of output bin
        dxo = uxo - lxo         # width of current x output bin

        # Scan input x bins to see if any fit in this output bin
        for j in range(0,M-1):
            lxi = input_xbins[j]    # lower x value of input bin
            uxi = input_xbins[j+1]  # upper x value of input bin
            dxi = uxi - lxi         # width of current x input bin

            if uxi&lt;lxo or lxi&gt;uxo:
                # no bins are aligned
                continue
            elif lxi &gt;= lxo and lxi &lt; uxo:
                # start of an input bin occurs in this output bin
                if lxi &gt;= lxo and uxi &lt;= uxo:
                    # input bin completely encompassed by output bin
                    output_ybins[i] = output_ybins[i] + input_ybins[j]
                else:
                    # input bin spans over at least one output bin
                    # count fraction in current output x bin
                    f_in_dxo = (uxo-lxi)/dxi
                    output_ybins[i] = output_ybins[i] + f_in_dxo*input_ybins[j]
            elif lxi &lt; lxo and uxi &gt; uxo:
                # output bin is completely encompassed by input bin
                f_in_dxo = (uxo-lxo)/dxi
                output_ybins[i] = output_ybins[i] + f_in_dxo*input_ybins[j]
            elif lxi &lt; lxo and uxi &gt; lxo and uxi &lt;= uxo:
                # tail of input bin is located in this output bin
                f_in_dxo = (uxi-lxo)/dxi
                output_ybins[i] = output_ybins[i] + f_in_dxo*input_ybins[j]

    return output_ybins

def is_number(n):
    &#39;&#39;&#39;
    Description:
        Determine if a string is that of a number or not.

    Inputs:
        - `n` = string to be tested

    Outputs:
        - `True` if value is a number (can be converted to float() without an error)
        - `False` otherwise
    &#39;&#39;&#39;
    try:
        float(n)
    except ValueError:
        return False
    return True


def ZZZAAAM_to_nuclide_plain_str(ZZZAAAM,include_Z=False,ZZZAAA=False,delimiter=&#39;-&#39;):
    &#39;&#39;&#39;
    Description:
        Converts a plaintext string of a nuclide to an integer ZZZAAAM = 10000\*Z + 10\*A + M

    Dependencies:
        `Element_Z_to_Sym` (function within the &#34;Hunter&#39;s tools&#34; package)

    Input:
       - `ZZZAAAM` = integer equal to 10000*Z + 10*A + M, where M designates the metastable state (0=ground)
       - `include_Z` = Boolean denoting whether the Z number should be included in the output string (D=`False`)
       - `ZZZAAA` = Boolean denoting whether the input should be interpreted as a ZZZAAA value (1000Z+A) instead (D=`False`)
       - `delimiter` = string which will be used to separate elements of the output string (D=`-`)

    Output:
       - `nuc_str` = string describing the input nuclide formatted as [Z]-[Symbol]-[A][m]
    &#39;&#39;&#39;
    ZZZAAAM = int(ZZZAAAM)
    if ZZZAAA:
        ZZZAAAM = ZZZAAAM*10
    m = ZZZAAAM % 10
    A = (ZZZAAAM % 10000) // 10
    Z = ZZZAAAM // 10000
    symbol = Element_Z_to_Sym(Z)

    m_str = &#39;&#39;
    if m&gt;0:
        m_str = &#39;m&#39; + str(m)

    nuc_str = &#39;&#39;
    if include_Z:
        nuc_str += str(Z) + delimiter
    nuc_str += symbol + delimiter + str(A) + m_str

    return nuc_str


def nuclide_plain_str_to_latex_str(nuc_str,include_Z=False):
    &#39;&#39;&#39;
    Description:
        Converts a plaintext string of a nuclide to a LaTeX-formatted raw string
        Note: if you already have the Z, A, and isomeric state information determined, the &#34;nuclide_to_Latex_form&#34; function can be used instead

    Dependencies:
        - `Element_Z_to_Sym` (function within the &#34;Hunter&#39;s tools&#34; package) (only required if `include_Z = True`)

    Input:
        (required)

       - `nuc_str` = string to be converted; a huge variety of formats are supported, but they all must follow the following rules:
           + Isomeric/metastable state characters must always immediately follow the atomic mass characters.
               Isomeric state labels MUST either:
               - (1) be a single lower-case character OR
               - (2) begin with any non-numeric character and end with a number
           + Atomic mass numbers must be nonnegative integers OR the string `&#34;nat&#34;` (in which case no metastable states can be written)
           + Elemental symbols MUST begin with an upper-case character

    Input:
       (optional)

       - `include_Z` = `True`/`False` determining whether the nuclide&#39;s atomic number Z will be printed as a subscript beneath the atomic mass

    Output:
        - LaTeX-formatted raw string of nuclide
    &#39;&#39;&#39;
    tex_str = r&#39;&#39;

    # remove unwanted characters from provided string
    delete_characters_list = [&#39; &#39;, &#39;-&#39;, &#39;_&#39;]
    for dc in delete_characters_list:
        nuc_str = nuc_str.replace(dc,&#39;&#39;)

    # determine which characters are letters versus numbers
    isalpha_list = []
    isdigit_list = []
    for c in nuc_str:
        isalpha_list.append(c.isalpha())
        isdigit_list.append(c.isdigit())

    symbol = &#39;&#39;
    mass = &#39;&#39;
    isost = &#39;&#39;

    # string MUST begin with either mass number or elemental symbol
    if isdigit_list[0] or nuc_str[0:3]==&#39;nat&#39;: # mass first
        mass_first = True
    else:
        mass_first = False

    if mass_first:
        if nuc_str[0:3]==&#39;nat&#39;:
            mass = &#39;nat&#39;
            ci = 3
        else:
            ci = 0
            while isdigit_list[ci]:
                mass += nuc_str[ci]
                ci += 1
            mass = str(int(mass)) # eliminate any extra leading zeros
            # encountered a non-numeric character, end of mass
            # now, determine if metastable state is listed or if element is listed next
            # first, check to see if any other numerals are in string
            lni = 0 # last numeral index
            for i in range(ci,len(nuc_str)):
                if isdigit_list[i]:
                    lni = i
            if lni != 0:
                # grab all characters between ci and last numeral as metastable state
                isost = nuc_str[ci:lni+1]
                ci = lni + 1
            else: # no more numerals in string, now check for single lower-case letter
                if isalpha_list[ci] and nuc_str[ci].islower():
                    isost = nuc_str[ci]
                    ci += 1

            # Now extract elemental symbol
            for i in range(ci,len(nuc_str)):
                if isalpha_list[i]:
                    symbol += nuc_str[i]

    else: # if elemental symbol is listed first
        if &#39;nat&#39; in nuc_str:
            mass = &#39;nat&#39;
            nuc_str = nuc_str.replace(&#39;nat&#39;,&#39;&#39;)

        ci = 0
        # Extract all characters before first number as the elemental symbol
        while nuc_str[ci].isalpha():
            symbol += nuc_str[ci]
            ci += 1

        # now, extract mass
        if mass != &#39;nat&#39;:
            while nuc_str[ci].isdigit():
                mass += nuc_str[ci]
                ci += 1
                if ci == len(nuc_str):
                    break

            # lastly, extract isomeric state, if present
            if ci != len(nuc_str):
                isost = nuc_str[ci:]

    # treating the cases of lowercase-specified particles (n, d, t, etc.)
    if symbol == &#39;&#39; and isost != &#39;&#39;:
        symbol = isost
        isost = &#39;&#39;

    # Now assemble LaTeX string for nuclides
    if include_Z:
        if symbol == &#39;n&#39;:
            Z = 0
        elif symbol == &#39;p&#39; or symbol == &#39;d&#39; or symbol == &#39;t&#39;:
            Z = 1
        else:
            Z = Element_Sym_to_Z(symbol)
        Z = str(int(Z))
        tex_str = r&#34;$^{{{}{}}}_{{{}}}$&#34;.format(mass,isost,Z) + &#34;{}&#34;.format(symbol)
    else:
        tex_str = r&#34;$^{{{}{}}}$&#34;.format(mass,isost) + &#34;{}&#34;.format(symbol)

    return tex_str


def Element_Z_to_Sym(Z):
    &#39;&#39;&#39;
    Description:
        Returns elemental symbol for a provided atomic number Z

    Inputs:
        - `Z` = atomic number

    Outputs:
        - `sym` = string of elemental symbol for element of atomic number Z
    &#39;&#39;&#39;
    elms = [&#34;n &#34;,\
            &#34;H &#34;,&#34;He&#34;,&#34;Li&#34;,&#34;Be&#34;,&#34;B &#34;,&#34;C &#34;,&#34;N &#34;,&#34;O &#34;,&#34;F &#34;,&#34;Ne&#34;,\
            &#34;Na&#34;,&#34;Mg&#34;,&#34;Al&#34;,&#34;Si&#34;,&#34;P &#34;,&#34;S &#34;,&#34;Cl&#34;,&#34;Ar&#34;,&#34;K &#34;,&#34;Ca&#34;,\
            &#34;Sc&#34;,&#34;Ti&#34;,&#34;V &#34;,&#34;Cr&#34;,&#34;Mn&#34;,&#34;Fe&#34;,&#34;Co&#34;,&#34;Ni&#34;,&#34;Cu&#34;,&#34;Zn&#34;,\
            &#34;Ga&#34;,&#34;Ge&#34;,&#34;As&#34;,&#34;Se&#34;,&#34;Br&#34;,&#34;Kr&#34;,&#34;Rb&#34;,&#34;Sr&#34;,&#34;Y &#34;,&#34;Zr&#34;,\
            &#34;Nb&#34;,&#34;Mo&#34;,&#34;Tc&#34;,&#34;Ru&#34;,&#34;Rh&#34;,&#34;Pd&#34;,&#34;Ag&#34;,&#34;Cd&#34;,&#34;In&#34;,&#34;Sn&#34;,\
            &#34;Sb&#34;,&#34;Te&#34;,&#34;I &#34;,&#34;Xe&#34;,&#34;Cs&#34;,&#34;Ba&#34;,&#34;La&#34;,&#34;Ce&#34;,&#34;Pr&#34;,&#34;Nd&#34;,\
            &#34;Pm&#34;,&#34;Sm&#34;,&#34;Eu&#34;,&#34;Gd&#34;,&#34;Tb&#34;,&#34;Dy&#34;,&#34;Ho&#34;,&#34;Er&#34;,&#34;Tm&#34;,&#34;Yb&#34;,\
            &#34;Lu&#34;,&#34;Hf&#34;,&#34;Ta&#34;,&#34;W &#34;,&#34;Re&#34;,&#34;Os&#34;,&#34;Ir&#34;,&#34;Pt&#34;,&#34;Au&#34;,&#34;Hg&#34;,\
            &#34;Tl&#34;,&#34;Pb&#34;,&#34;Bi&#34;,&#34;Po&#34;,&#34;At&#34;,&#34;Rn&#34;,&#34;Fr&#34;,&#34;Ra&#34;,&#34;Ac&#34;,&#34;Th&#34;,\
            &#34;Pa&#34;,&#34;U &#34;,&#34;Np&#34;,&#34;Pu&#34;,&#34;Am&#34;,&#34;Cm&#34;,&#34;Bk&#34;,&#34;Cf&#34;,&#34;Es&#34;,&#34;Fm&#34;,\
            &#34;Md&#34;,&#34;No&#34;,&#34;Lr&#34;,&#34;Rf&#34;,&#34;Db&#34;,&#34;Sg&#34;,&#34;Bh&#34;,&#34;Hs&#34;,&#34;Mt&#34;,&#34;Ds&#34;,\
            &#34;Rg&#34;,&#34;Cn&#34;,&#34;Nh&#34;,&#34;Fl&#34;,&#34;Mc&#34;,&#34;Lv&#34;,&#34;Ts&#34;,&#34;Og&#34;]
    i = int(Z)
    if i &lt; 0 or i &gt; len(elms):
        print(&#39;Z={} is not valid, please select a number from 0 to 118 (inclusive).&#39;.format(str(Z)))
        return None
    return elms[i].strip()

def Element_Sym_to_Z(sym):
    &#39;&#39;&#39;
    Description:
        Returns atomic number Z for a provided elemental symbol

    Dependencies:
        `find` (function within the &#34;Hunter&#39;s tools&#34; package)

    Inputs:
        - `sym` = string of elemental symbol for element of atomic number Z

    Outputs:
        - `Z` = atomic number
    &#39;&#39;&#39;
    elms = [&#34;n &#34;,\
            &#34;H &#34;,&#34;He&#34;,&#34;Li&#34;,&#34;Be&#34;,&#34;B &#34;,&#34;C &#34;,&#34;N &#34;,&#34;O &#34;,&#34;F &#34;,&#34;Ne&#34;,\
            &#34;Na&#34;,&#34;Mg&#34;,&#34;Al&#34;,&#34;Si&#34;,&#34;P &#34;,&#34;S &#34;,&#34;Cl&#34;,&#34;Ar&#34;,&#34;K &#34;,&#34;Ca&#34;,\
            &#34;Sc&#34;,&#34;Ti&#34;,&#34;V &#34;,&#34;Cr&#34;,&#34;Mn&#34;,&#34;Fe&#34;,&#34;Co&#34;,&#34;Ni&#34;,&#34;Cu&#34;,&#34;Zn&#34;,\
            &#34;Ga&#34;,&#34;Ge&#34;,&#34;As&#34;,&#34;Se&#34;,&#34;Br&#34;,&#34;Kr&#34;,&#34;Rb&#34;,&#34;Sr&#34;,&#34;Y &#34;,&#34;Zr&#34;,\
            &#34;Nb&#34;,&#34;Mo&#34;,&#34;Tc&#34;,&#34;Ru&#34;,&#34;Rh&#34;,&#34;Pd&#34;,&#34;Ag&#34;,&#34;Cd&#34;,&#34;In&#34;,&#34;Sn&#34;,\
            &#34;Sb&#34;,&#34;Te&#34;,&#34;I &#34;,&#34;Xe&#34;,&#34;Cs&#34;,&#34;Ba&#34;,&#34;La&#34;,&#34;Ce&#34;,&#34;Pr&#34;,&#34;Nd&#34;,\
            &#34;Pm&#34;,&#34;Sm&#34;,&#34;Eu&#34;,&#34;Gd&#34;,&#34;Tb&#34;,&#34;Dy&#34;,&#34;Ho&#34;,&#34;Er&#34;,&#34;Tm&#34;,&#34;Yb&#34;,\
            &#34;Lu&#34;,&#34;Hf&#34;,&#34;Ta&#34;,&#34;W &#34;,&#34;Re&#34;,&#34;Os&#34;,&#34;Ir&#34;,&#34;Pt&#34;,&#34;Au&#34;,&#34;Hg&#34;,\
            &#34;Tl&#34;,&#34;Pb&#34;,&#34;Bi&#34;,&#34;Po&#34;,&#34;At&#34;,&#34;Rn&#34;,&#34;Fr&#34;,&#34;Ra&#34;,&#34;Ac&#34;,&#34;Th&#34;,\
            &#34;Pa&#34;,&#34;U &#34;,&#34;Np&#34;,&#34;Pu&#34;,&#34;Am&#34;,&#34;Cm&#34;,&#34;Bk&#34;,&#34;Cf&#34;,&#34;Es&#34;,&#34;Fm&#34;,\
            &#34;Md&#34;,&#34;No&#34;,&#34;Lr&#34;,&#34;Rf&#34;,&#34;Db&#34;,&#34;Sg&#34;,&#34;Bh&#34;,&#34;Hs&#34;,&#34;Mt&#34;,&#34;Ds&#34;,\
            &#34;Rg&#34;,&#34;Cn&#34;,&#34;Nh&#34;,&#34;Fl&#34;,&#34;Mc&#34;,&#34;Lv&#34;,&#34;Ts&#34;,&#34;Og&#34;]

    if len(sym.strip())&gt;2:
        print(&#39;Please provide a valid elemental symbol (1 or 2 characters), {} is too long&#39;.format(sym))
        return -1

    # handle exception for neutron first
    if sym.strip()==&#39;XX&#39;:
        return 0

    # make sure string is formatted to match entries in elms list
    sym2 = sym.strip()
    if len(sym2)==1: sym2 += &#39; &#39;
    sym2 = sym2[0].upper() + sym2[1].lower()

    Z = find(sym2,elms)

    if Z==None:
        print(&#39;Z could not be found for element &#34;{}&#34;; please make sure entry is correct.&#39;.format(sym))
        return -1

    return Z

def find(target, myList):
    &#39;&#39;&#39;
    Description:
        Search for and return the index of the first occurance of a value in a list.

    Inputs:
        - `target` = value to be searched for
        - `myList` = list of values

    Output:
        - index of first instance of `target` in `myList`
    &#39;&#39;&#39;
    for i in range(len(myList)):
        if myList[i] == target:
            return i

def ICRP116_effective_dose_coeff(E=1.0,particle=&#39;photon&#39;,geometry=&#39;AP&#39;,interp_scale=&#39;log&#39;,interp_type=&#39;cubic&#39;,extrapolation_on=False):
    &#39;&#39;&#39;
    Description:
        For a given particle at a given energy in a given geometry, returns its
        effective dose conversion coefficient from ICRP 116

    Dependencies:
        - `import numpy as np`
        - `from scipy.interpolate import CubicSpline, lagrange, interp1d`
        - `find` (function within the &#34;PHITS Tools&#34; package)

    Inputs:
       - `E` = energy of the particle in MeV (D=`1`)
       - `particle` = select particle (D=`&#39;photon&#39;`, options include: `[&#39;photon&#39;, &#39;electron&#39;, &#39;positron&#39; ,&#39;neutron&#39; ,&#39;proton&#39;, &#39;negmuon&#39;, &#39;posmuon&#39;, &#39;negpion&#39;, &#39;pospion&#39;, &#39;He3ion&#39;]`)
       - `geometry` = geometric arrangement (D=`&#39;AP&#39;`, options include: `[&#39;AP&#39;, &#39;PA&#39;, &#39;LLAT&#39;, &#39;RLAT&#39;, &#39;ROT&#39;, &#39;ISO&#39;, &#39;H*(10)&#39;]` (`&#39;LLAT&#39;`,`&#39;RLAT&#39;`,`&#39;ROT&#39;` only available for photon, proton, and neutron))
              - Meanings:
               AP, antero-posterior; PA, postero-anterior; LLAT, left lateral; RLAT, right lateral; ROT, rotational; ISO, isotropic.
              - Note: `&#39;H*(10)&#39;` ambient dose equivalent is available for photons only
       - `interp_scale` = interpolation scale (D=`&#39;log&#39;` to interpolate on a log scale, options include: `[&#39;log&#39;,&#39;lin&#39;]`, ICRP 74/116 suggest log-log cubic interpolation)
       - `interp_type`  = interpolation method (D=`&#39;cubic&#39;` to interpolate with a cubic spline, options include: `[&#39;cubic&#39;,&#39;linear&#39;]`, ICRP 74/116 suggest log-log cubic interpolation)
                                              technically, any options available for scipy.interpolate.interp1d() can be used: `[&#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;, &#39;previous&#39;]`
       - `extrapolation_on` = boolean designating whether values outside of the tabulated energies will be extrapolated (D=`False`)

             |                      |                                                                       |
             | -------------------- | --------------------------------------------------------------------- |
             | if False &amp; E &lt; E_min | f(E) = 0                                                              |
             | if False &amp; E &gt; E_max | f(E) = f(E_max)                                                       |
             | if True  &amp; E &lt; E_min | f(E) is linearly interpolated between (0,0) and (E_min,f(E_min))      |
             | if True  &amp; E &gt; E_max | f(E) is extrapolated using the specified interpolation scale and type |
    Outputs:
       - `f` = effective dose conversion coefficient in pSv*cm^2
    &#39;&#39;&#39;
    import numpy as np
    from scipy.interpolate import CubicSpline, lagrange, interp1d

    pars_list = [&#39;photon&#39;,&#39;electron&#39;,&#39;positron&#39;,&#39;neutron&#39;,&#39;proton&#39;,&#39;negmuon&#39;,&#39;posmuon&#39;,&#39;negpion&#39;,&#39;pospion&#39;,&#39;He3ion&#39;]
    geo_list_all = [&#39;AP&#39;,&#39;PA&#39;,&#39;LLAT&#39;,&#39;RLAT&#39;,&#39;ROT&#39;,&#39;ISO&#39;,&#39;H*(10)&#39;]
    geo_list_short = [&#39;AP&#39;,&#39;PA&#39;,&#39;ISO&#39;]

    if particle not in pars_list or geometry not in geo_list_all:
        pstr = &#39;Please select a valid particle and geometry.\n&#39;
        pstr += &#34;Particle selected = {}, options include: [&#39;photon&#39;,&#39;electron&#39;,&#39;positron&#39;,&#39;neutron&#39;,&#39;proton&#39;,&#39;negmuon&#39;,&#39;posmuon&#39;,&#39;negpion&#39;,&#39;pospion&#39;,&#39;He3ion&#39;]&#34;.format(particle)
        pstr += &#34;Geometry selected = {}, options include: [&#39;AP&#39;,&#39;PA&#39;,&#39;LLAT&#39;,&#39;RLAT&#39;,&#39;ROT&#39;,&#39;ISO&#39;] (&#39;LLAT&#39;,&#39;RLAT&#39;,&#39;ROT&#39; only available for photon, proton, and neutron)&#34;
        print(pstr)
        return None

    if (particle not in [&#39;photon&#39;,&#39;neutron&#39;,&#39;proton&#39;] and geometry in [&#39;LLAT&#39;,&#39;RLAT&#39;,&#39;ROT&#39;]) or (particle!=&#39;photon&#39; and geometry==&#39;H*(10)&#39;):
        if (particle!=&#39;photon&#39; and geometry==&#39;H*(10)&#39;):
            pstr = &#34;geometry = {} is only available for photons\n&#34;.format(geometry)
        else:
            pstr = &#34;geometry = {} is only available for photon, neutron, and proton\n&#34;.format(geometry)
            pstr += &#34;For selected particle = {}, please choose geometry from [&#39;AP&#39;,&#39;PA&#39;,&#39;ISO&#39;]&#34;.format(particle)
        print(pstr)
        return None

    E_photon = [0.01, 0.015, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.511, 0.6, 0.662, 0.8, 1, 1.117, 1.33, 1.5, 2, 3, 4, 5, 6, 6.129, 8, 10, 15, 20, 30, 40, 50, 60, 80, 100, 150, 200, 300, 400, 500, 600, 800, 1000, 1500, 2000, 3000, 4000, 5000, 6000, 8000, 10000]
    f_photon = [
    [0.0685, 0.156, 0.225, 0.313, 0.351, 0.37, 0.39, 0.413, 0.444, 0.519, 0.748, 1, 1.51, 2, 2.47, 2.52, 2.91, 3.17, 3.73, 4.49, 4.9, 5.59, 6.12, 7.48, 9.75, 11.7, 13.4, 15, 15.1, 17.8, 20.5, 26.1, 30.8, 37.9, 43.1, 47.1, 50.1, 54.5, 57.8, 63.3, 67.3, 72.3, 75.5, 77.5, 78.9, 80.5, 81.7, 83.8, 85.2, 86.9, 88.1, 88.9, 89.5, 90.2, 90.7],
    [0.0184, 0.0155, 0.026, 0.094, 0.161, 0.208, 0.242, 0.271, 0.301, 0.361, 0.541, 0.741, 1.16, 1.57, 1.98, 2.03, 2.38, 2.62, 3.13, 3.83, 4.22, 4.89, 5.39, 6.75, 9.12, 11.2, 13.1, 15, 15.2, 18.6, 22, 30.3, 38.2, 51.4, 62, 70.4, 76.9, 86.6, 93.2, 104, 111, 119, 124, 128, 131, 135, 138, 142, 145, 148, 150, 152, 153, 155, 155],
    [0.0189, 0.0416, 0.0655, 0.11, 0.14, 0.16, 0.177, 0.194, 0.214, 0.259, 0.395, 0.552, 0.888, 1.24, 1.58, 1.62, 1.93, 2.14, 2.59, 3.23, 3.58, 4.2, 4.68, 5.96, 8.21, 10.2, 12, 13.7, 13.9, 17, 20.1, 27.4, 34.4, 47.4, 59.2, 69.5, 78.3, 92.4, 103, 121, 133, 148, 158, 165, 170, 178, 183, 193, 198, 206, 212, 216, 219, 224, 228],
    [0.0182, 0.039, 0.0573, 0.0891, 0.114, 0.133, 0.15, 0.167, 0.185, 0.225, 0.348, 0.492, 0.802, 1.13, 1.45, 1.49, 1.78, 1.98, 2.41, 3.03, 3.37, 3.98, 4.45, 5.7, 7.9, 9.86, 11.7, 13.4, 13.6, 16.6, 19.7, 27.1, 34.4, 48.1, 60.9, 72.2, 82, 97.9, 110, 130, 143, 161, 172, 180, 186, 195, 201, 212, 220, 229, 235, 240, 244, 251, 255],
    [0.0337, 0.0664, 0.0986, 0.158, 0.199, 0.226, 0.248, 0.273, 0.297, 0.355, 0.528, 0.721, 1.12, 1.52, 1.92, 1.96, 2.3, 2.54, 3.04, 3.72, 4.1, 4.75, 5.24, 6.55, 8.84, 10.8, 12.7, 14.4, 14.6, 17.6, 20.6, 27.7, 34.4, 46.1, 56, 64.4, 71.2, 82, 89.7, 102, 111, 121, 128, 133, 136, 142, 145, 152, 156, 161, 165, 168, 170, 172, 175],
    [0.0288, 0.056, 0.0812, 0.127, 0.158, 0.18, 0.199, 0.218, 0.239, 0.287, 0.429, 0.589, 0.932, 1.28, 1.63, 1.67, 1.97, 2.17, 2.62, 3.25, 3.6, 4.2, 4.66, 5.9, 8.08, 10, 11.8, 13.5, 13.7, 16.6, 19.6, 26.8, 33.8, 46.1, 56.9, 66.2, 74.1, 87.2, 97.5, 116, 130, 147, 159, 168, 174, 185, 193, 208, 218, 232, 243, 251, 258, 268, 276],
    [0.061, 0.83, 1.05, 0.81, 0.64, 0.55, 0.51, 0.52, 0.53, 0.61, 0.89, 1.20, 1.80, 2.38, 2.93, 2.99, 3.44, 3.73, 4.38, 5.20, 5.60, 6.32, 6.90, 8.60, 11.10, 13.40, 15.50, 17.60, 17.86, 21.60, 25.60, 8.53, 8.29, 8.23, 8.26, 8.64, 8.71, 8.86, 9.00, 9.60, 10.20, 10.73, 11.27, 11.80, 11.78, 11.74, 11.70, 11.60, 11.50, 12.10, 12.70, 13.30, 13.08, 12.64, 12.20]
    ]

    E_electron = [0.01, 0.015, 0.02, 0.03, 0.04, 0.05, 0.06, 0.08, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.8, 1, 1.5, 2, 3, 4, 5, 6, 8, 10, 15, 20, 30, 40, 50, 60, 80, 100, 150, 200, 300, 400, 500, 600, 800, 1000, 1500, 2000, 3000, 4000, 5000, 6000, 8000, 10000]
    f_electron = [
    [0.0269, 0.0404, 0.0539, 0.081, 0.108, 0.135, 0.163, 0.218, 0.275, 0.418, 0.569, 0.889, 1.24, 1.63, 2.05, 4.04, 7.1, 15, 22.4, 36.1, 48.2, 59.3, 70.6, 97.9, 125, 188, 236, 302, 329, 337, 341, 346, 349, 355, 359, 365, 369, 372, 375, 379, 382, 387, 391, 397, 401, 405, 407, 411, 414],
    [0.0268, 0.0402, 0.0535, 0.0801, 0.107, 0.133, 0.16, 0.213, 0.267, 0.399, 0.53, 0.787, 1.04, 1.28, 1.5, 1.68, 1.68, 1.62, 1.62, 1.95, 2.62, 3.63, 5.04, 9.46, 18.3, 53.1, 104, 220, 297, 331, 344, 358, 366, 379, 388, 399, 408, 414, 419, 428, 434, 446, 455, 468, 477, 484, 490, 499, 507],
    [0.0188, 0.0283, 0.0377, 0.0567, 0.0758, 0.0948, 0.114, 0.152, 0.191, 0.291, 0.393, 0.606, 0.832, 1.08, 1.35, 1.97, 2.76, 4.96, 7.24, 11.9, 16.4, 21, 25.5, 35.5, 46.7, 76.9, 106, 164, 212, 249, 275, 309, 331, 363, 383, 410, 430, 445, 457, 478, 495, 525, 549, 583, 608, 628, 646, 675, 699]
    ]

    E_positron = [0.01, 0.015, 0.02, 0.03, 0.04, 0.05, 0.06, 0.08, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.8, 1, 1.5, 2, 3, 4, 5, 6, 8, 10, 15, 20, 30, 40, 50, 60, 80, 100, 150, 200, 300, 400, 500, 600, 800, 1000, 1500, 2000, 3000, 4000, 5000, 6000, 8000, 10000]
    f_positron = [
    [3.28, 3.29, 3.3, 3.33, 3.36, 3.39, 3.42, 3.47, 3.53, 3.67, 3.84, 4.16, 4.52, 4.9, 5.36, 7.41, 10.5, 18.3, 25.7, 39.1, 51, 61.7, 72.9, 99, 126, 184, 229, 294, 320, 327, 333, 339, 342, 349, 354, 362, 366, 369, 372, 376, 379, 385, 389, 395, 399, 402, 404, 408, 411],
    [1.62, 1.64, 1.65, 1.68, 1.71, 1.73, 1.76, 1.82, 1.87, 2.01, 2.14, 2.4, 2.65, 2.9, 3.12, 3.32, 3.37, 3.44, 3.59, 4.19, 5.11, 6.31, 8.03, 14, 23.6, 59, 111, 221, 291, 321, 334, 349, 357, 371, 381, 393, 402, 409, 415, 424, 430, 443, 451, 465, 473, 480, 486, 495, 503],
    [1.39, 1.4, 1.41, 1.43, 1.45, 1.47, 1.49, 1.53, 1.57, 1.67, 1.77, 1.98, 2.21, 2.45, 2.72, 3.38, 4.2, 6.42, 8.7, 13.3, 18, 22.4, 26.9, 36.7, 47.6, 75.5, 104, 162, 209, 243, 268, 302, 323, 356, 377, 405, 425, 440, 453, 474, 491, 522, 545, 580, 605, 627, 645, 674, 699]
    ]

    E_neutron = [1.00E-09, 1.00E-08, 2.50E-08, 1.00E-07, 2.00E-07, 5.00E-07, 1.00E-06, 2.00E-06, 5.00E-06, 1.00E-05, 2.00E-05, 5.00E-05, 1.00E-04, 2.00E-04, 5.00E-04, 0.001, 0.002, 0.005, 0.01, 0.02, 0.03, 0.05, 0.07, 0.1, 0.15, 0.2, 0.3, 0.5, 0.7, 0.9, 1, 1.2, 1.5, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 30, 50, 75, 100, 130, 150, 180, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 2000, 5000, 10000]
    f_neutron = [
    [3.09, 3.55, 4, 5.2, 5.87, 6.59, 7.03, 7.39, 7.71, 7.82, 7.84, 7.82, 7.79, 7.73, 7.54, 7.54, 7.61, 7.97, 9.11, 12.2, 15.7, 23, 30.6, 41.9, 60.6, 78.8, 114, 177, 232, 279, 301, 330, 365, 407, 458, 483, 494, 498, 499, 499, 500, 500, 499, 495, 493, 490, 484, 477, 474, 453, 433, 420, 402, 382, 373, 363, 359, 363, 389, 422, 457, 486, 508, 524, 537, 612, 716, 933],
    [1.85, 2.11, 2.44, 3.25, 3.72, 4.33, 4.73, 5.02, 5.3, 5.44, 5.51, 5.55, 5.57, 5.59, 5.6, 5.6, 5.62, 5.95, 6.81, 8.93, 11.2, 15.7, 20, 25.9, 34.9, 43.1, 58.1, 85.9, 112, 136, 148, 167, 195, 235, 292, 330, 354, 371, 383, 392, 398, 404, 412, 417, 419, 420, 422, 423, 423, 422, 428, 439, 444, 446, 446, 447, 448, 464, 496, 533, 569, 599, 623, 640, 654, 740, 924, 1.17E+03],
    [1.04, 1.15, 1.32, 1.7, 1.94, 2.21, 2.4, 2.52, 2.64, 2.65, 2.68, 2.66, 2.65, 2.66, 2.62, 2.61, 2.6, 2.74, 3.13, 4.21, 5.4, 7.91, 10.5, 14.4, 20.8, 27.2, 39.7, 63.7, 85.5, 105, 115, 130, 150, 179, 221, 249, 269, 284, 295, 303, 310, 316, 325, 333, 336, 338, 343, 347, 348, 360, 380, 399, 409, 416, 420, 425, 427, 441, 472, 510, 547, 579, 603, 621, 635, 730, 963, 1.23E+03],
    [0.893, 0.978, 1.12, 1.42, 1.63, 1.86, 2.02, 2.11, 2.21, 2.24, 2.26, 2.24, 2.23, 2.24, 2.21, 2.21, 2.2, 2.33, 2.67, 3.6, 4.62, 6.78, 8.95, 12.3, 17.9, 23.4, 34.2, 54.4, 72.6, 89.3, 97.4, 110, 128, 153, 192, 220, 240, 255, 267, 276, 284, 290, 301, 310, 313, 317, 323, 328, 330, 345, 370, 392, 404, 413, 418, 425, 429, 451, 483, 523, 563, 597, 620, 638, 651, 747, 979, 1.26E+03],
    [1.7, 2.03, 2.31, 2.98, 3.36, 3.86, 4.17, 4.4, 4.59, 4.68, 4.72, 4.73, 4.72, 4.67, 4.6, 4.58, 4.61, 4.86, 5.57, 7.41, 9.46, 13.7, 18, 24.3, 34.7, 44.7, 63.8, 99.1, 131, 160, 174, 193, 219, 254, 301, 331, 351, 365, 374, 381, 386, 390, 395, 398, 398, 399, 399, 398, 398, 395, 395, 402, 406, 411, 414, 418, 422, 443, 472, 503, 532, 558, 580, 598, 614, 718, 906, 1.14E+03],
    [1.29, 1.56, 1.76, 2.26, 2.54, 2.92, 3.15, 3.32, 3.47, 3.52, 3.54, 3.55, 3.54, 3.52, 3.47, 3.46, 3.48, 3.66, 4.19, 5.61, 7.18, 10.4, 13.7, 18.6, 26.6, 34.4, 49.4, 77.1, 102, 126, 137, 153, 174, 203, 244, 271, 290, 303, 313, 321, 327, 332, 339, 344, 346, 347, 350, 352, 353, 358, 371, 387, 397, 407, 412, 421, 426, 455, 488, 521, 553, 580, 604, 624, 642, 767, 1.01E+03, 1.32E+03]
    ]

    E_proton = [1, 1.5, 2, 3, 4, 5, 6, 8, 10, 15, 20, 30, 40, 50, 60, 80, 100, 150, 200, 300, 400, 500, 600, 800, 1000, 1500, 2000, 3000, 4000, 5000, 6000, 8000, 10000]
    f_proton = [
    [5.46, 8.2, 10.9, 16.4, 21.9, 27.3, 32.8, 43.7, 54.9, 189, 428, 750, 1.02E+03, 1.18E+03, 1.48E+03, 2.16E+03, 2.51E+03, 2.38E+03, 1.77E+03, 1.38E+03, 1.23E+03, 1.15E+03, 1.16E+03, 1.11E+03, 1.09E+03, 1.15E+03, 1.12E+03, 1.23E+03, 1.27E+03, 1.23E+03, 1.37E+03, 1.45E+03, 1.41E+03],
    [5.47, 8.21, 10.9, 16.4, 21.9, 27.3, 32.8, 43.7, 54.6, 56.1, 43.6, 36.1, 45.5, 71.5, 156, 560, 1.19E+03, 2.82E+03, 1.93E+03, 1.45E+03, 1.30E+03, 1.24E+03, 1.23E+03, 1.23E+03, 1.23E+03, 1.25E+03, 1.28E+03, 1.34E+03, 1.40E+03, 1.45E+03, 1.53E+03, 1.65E+03, 1.74E+03],
    [2.81, 4.21, 5.61, 8.43, 11.2, 14, 16.8, 22.4, 28.1, 50.7, 82.8, 180, 290, 379, 500, 799, 994, 1.64E+03, 2.15E+03, 1.44E+03, 1.27E+03, 1.21E+03, 1.20E+03, 1.19E+03, 1.18E+03, 1.21E+03, 1.25E+03, 1.32E+03, 1.31E+03, 1.39E+03, 1.44E+03, 1.56E+03, 1.63E+03],
    [2.81, 4.2, 5.62, 8.41, 11.2, 14, 16.8, 22.4, 28.1, 48.9, 78.8, 172, 278, 372, 447, 602, 818, 1.46E+03, 2.18E+03, 1.45E+03, 1.28E+03, 1.21E+03, 1.20E+03, 1.20E+03, 1.20E+03, 1.23E+03, 1.25E+03, 1.32E+03, 1.33E+03, 1.41E+03, 1.45E+03, 1.59E+03, 1.67E+03],
    [4.5, 6.75, 8.98, 13.4, 17.8, 22.1, 26.3, 34.5, 50.1, 93.7, 165, 296, 422, 532, 687, 1.09E+03, 1.44E+03, 2.16E+03, 1.96E+03, 1.44E+03, 1.28E+03, 1.22E+03, 1.22E+03, 1.20E+03, 1.19E+03, 1.23E+03, 1.23E+03, 1.30E+03, 1.29E+03, 1.35E+03, 1.41E+03, 1.49E+03, 1.56E+03],
    [3.52, 5.28, 7.02, 10.5, 13.9, 17.3, 20.5, 26.8, 45.8, 80.1, 136, 249, 358, 451, 551, 837, 1.13E+03, 1.79E+03, 1.84E+03, 1.42E+03, 1.25E+03, 1.18E+03, 1.17E+03, 1.17E+03, 1.15E+03, 1.21E+03, 1.22E+03, 1.31E+03, 1.40E+03, 1.43E+03, 1.57E+03, 1.71E+03, 1.78E+03]
    ]

    E_negmuon = [1, 1.5, 2, 3, 4, 5, 6, 8, 10, 15, 20, 30, 40, 50, 60, 80, 100, 150, 200, 300, 400, 500, 600, 800, 1000, 1500, 2000, 3000, 4000, 5000, 6000, 8000, 10000]
    f_negmuon = [
    [180, 180, 184, 188, 193, 205, 242, 293, 332, 414, 465, 657, 735, 755, 628, 431, 382, 340, 326, 319, 320, 321, 325, 327, 333, 331, 333, 336, 337, 337, 337, 337, 338],
    [75.2, 76.8, 78.3, 81.4, 84.8, 87.7, 86.7, 86.8, 88.6, 100, 122, 251, 457, 703, 775, 485, 402, 345, 329, 321, 321, 324, 326, 332, 337, 338, 341, 344, 345, 346, 346, 347, 347],
    [78.7, 79.5, 80.9, 83.7, 87.1, 91.5, 98.1, 113, 127, 161, 191, 275, 363, 446, 496, 498, 432, 354, 332, 321, 321, 323, 326, 331, 337, 338, 341, 344, 346, 347, 347, 348, 348]
    ]

    E_posmuon = [1, 1.5, 2, 3, 4, 5, 6, 8, 10, 15, 20, 30, 40, 50, 60, 80, 100, 150, 200, 300, 400, 500, 600, 800, 1000, 1500, 2000, 3000, 4000, 5000, 6000, 8000, 10000]
    f_posmuon = [
    [194, 196, 198, 202, 207, 216, 251, 300, 340, 425, 481, 674, 751, 768, 635, 431, 381, 339, 326, 318, 319, 320, 322, 325, 327, 331, 333, 336, 337, 337, 337, 337, 339],
    [82.6, 84.1, 85.7, 88.9, 92.1, 94.3, 92.5, 92.8, 94.8, 108, 133, 265, 473, 721, 787, 483, 399, 345, 328, 320, 321, 323, 325, 330, 333, 339, 341, 344, 345, 346, 346, 347, 347],
    [85.2, 86.2, 87.5, 90.3, 93.6, 97.7, 103, 117, 132, 167, 199, 284, 373, 456, 506, 502, 432, 354, 332, 320, 320, 322, 324, 329, 333, 338, 341, 344, 346, 347, 347, 348, 348]
    ]

    E_negpion = [1, 1.5, 2, 3, 4, 5, 6, 8, 10, 15, 20, 30, 40, 50, 60, 80, 100, 150, 200, 300, 400, 500, 600, 800, 1000, 1500, 2000, 3000, 4000, 5000, 6000, 8000, 10000, 15000, 20000, 30000, 40000, 50000, 60000, 80000, 100000, 150000, 200000]
    f_negpion = [
    [406, 422, 433, 458, 491, 528, 673, 965, 1.09E+03, 1.25E+03, 1.28E+03, 1.77E+03, 1.92E+03, 1.93E+03, 1.68E+03, 1.14E+03, 995, 927, 902, 848, 844, 869, 901, 947, 977, 1.03E+03, 1.05E+03, 1.03E+03, 1.03E+03, 1.06E+03, 1.09E+03, 1.14E+03, 1.17E+03, 1.21E+03, 1.24E+03, 1.30E+03, 1.35E+03, 1.39E+03, 1.42E+03, 1.48E+03, 1.54E+03, 1.67E+03, 1.78E+03],
    [194, 201, 210, 225, 233, 237, 208, 181, 178, 197, 244, 547, 1.02E+03, 1.70E+03, 1.99E+03, 1.31E+03, 991, 889, 871, 843, 850, 880, 917, 976, 1.02E+03, 1.08E+03, 1.12E+03, 1.11E+03, 1.13E+03, 1.18E+03, 1.22E+03, 1.29E+03, 1.34E+03, 1.41E+03, 1.47E+03, 1.56E+03, 1.63E+03, 1.70E+03, 1.75E+03, 1.86E+03, 1.95E+03, 2.15E+03, 2.33E+03],
    [176, 189, 198, 215, 232, 251, 271, 317, 361, 439, 508, 676, 868, 1.02E+03, 1.15E+03, 1.15E+03, 1.03E+03, 857, 815, 794, 807, 838, 875, 935, 979, 1.05E+03, 1.09E+03, 1.11E+03, 1.15E+03, 1.20E+03, 1.26E+03, 1.36E+03, 1.43E+03, 1.55E+03, 1.64E+03, 1.79E+03, 1.91E+03, 2.02E+03, 2.11E+03, 2.29E+03, 2.46E+03, 2.80E+03, 3.04E+03]
    ]

    E_pospion = [1, 1.5, 2, 3, 4, 5, 6, 8, 10, 15, 20, 30, 40, 50, 60, 80, 100, 150, 200, 300, 400, 500, 600, 800, 1000, 1500, 2000, 3000, 4000, 5000, 6000, 8000, 10000, 15000, 20000, 30000, 40000, 50000, 60000, 80000, 100000, 150000, 200000]
    f_pospion = [
    [314, 324, 340, 379, 429, 489, 540, 717, 819, 1000, 1.10E+03, 1.52E+03, 1.75E+03, 1.83E+03, 1.66E+03, 1.22E+03, 1.13E+03, 1.22E+03, 1.25E+03, 1.07E+03, 969, 943, 952, 999, 1.04E+03, 1.10E+03, 1.10E+03, 1.06E+03, 1.06E+03, 1.07E+03, 1.10E+03, 1.14E+03, 1.17E+03, 1.22E+03, 1.25E+03, 1.30E+03, 1.34E+03, 1.38E+03, 1.42E+03, 1.48E+03, 1.54E+03, 1.67E+03, 1.78E+03],
    [121, 125, 133, 151, 170, 183, 185, 177, 179, 201, 247, 494, 906, 1.48E+03, 1.82E+03, 1.38E+03, 1.12E+03, 1.15E+03, 1.23E+03, 1.10E+03, 998, 970, 980, 1.04E+03, 1.09E+03, 1.16E+03, 1.19E+03, 1.16E+03, 1.16E+03, 1.20E+03, 1.24E+03, 1.31E+03, 1.35E+03, 1.42E+03, 1.48E+03, 1.57E+03, 1.64E+03, 1.70E+03, 1.75E+03, 1.84E+03, 1.94E+03, 2.14E+03, 2.33E+03],
    [151, 160, 168, 183, 198, 216, 233, 265, 296, 367, 439, 602, 787, 953, 1.09E+03, 1.16E+03, 1.10E+03, 1.05E+03, 1.08E+03, 1.02E+03, 953, 930, 938, 993, 1.05E+03, 1.13E+03, 1.16E+03, 1.16E+03, 1.18E+03, 1.23E+03, 1.28E+03, 1.37E+03, 1.43E+03, 1.55E+03, 1.64E+03, 1.79E+03, 1.90E+03, 2.01E+03, 2.10E+03, 2.27E+03, 2.42E+03, 2.76E+03, 3.07E+03]
    ]

    E_He3ion = [1, 2, 3, 5, 10, 14, 20, 30, 50, 75, 100, 150, 200, 300, 500, 700, 1000, 2000, 3000, 5000, 10000, 20000, 50000, 100000]
    f_He3ion = [
    [219, 438, 656, 1.09E+03, 2.19E+03, 4.61E+03, 1.72E+04, 3.01E+04, 4.75E+04, 8.05E+04, 1.01E+05, 9.25E+04, 6.74E+04, 5.14E+04, 4.27E+04, 4.11E+04, 4.00E+04, 4.02E+04, 4.08E+04, 4.12E+04, 4.56E+04, 5.12E+04, 6.12E+04, 7.14E+04],
    [219, 438, 657, 1.09E+03, 2.19E+03, 2.56E+03, 1.74E+03, 1.44E+03, 2.88E+03, 1.75E+04, 4.84E+04, 1.10E+05, 7.29E+04, 5.33E+04, 4.49E+04, 4.60E+04, 4.47E+04, 4.80E+04, 5.01E+04, 5.17E+04, 6.26E+04, 6.10E+04, 8.14E+04, 1.01E+05],
    [141, 281, 419, 689, 1.82E+03, 2.81E+03, 5.46E+03, 9.86E+03, 1.78E+04, 3.00E+04, 4.55E+04, 6.95E+04, 7.01E+04, 5.25E+04, 4.27E+04, 4.19E+04, 4.09E+04, 4.31E+04, 4.50E+04, 4.76E+04, 5.73E+04, 7.10E+04, 9.67E+04, 1.24E+05]
    ]


    E_all = [E_photon, E_electron, E_positron, E_neutron, E_proton, E_negmuon, E_posmuon, E_negpion, E_pospion, E_He3ion]
    f_all = [f_photon, f_electron, f_positron, f_neutron, f_proton, f_negmuon, f_posmuon, f_negpion, f_pospion, f_He3ion]

    pi = find(particle, pars_list)
    if particle in [&#39;photon&#39;,&#39;neutron&#39;,&#39;proton&#39;]:
        gi = find(geometry, geo_list_all)
    else:
        gi = find(geometry, geo_list_short)

    E_list = E_all[pi]
    f_list = f_all[pi][gi]

    # Interpolate f given E
    if E in E_list:
        f = f_list[find(E,E_list)]
    else:
        if not extrapolation_on and (E &lt; E_list[0] or E &gt; E_list[-1]):  # E is outside of bounds and extrapolation is off
            if E &lt; E_list[0]:
                f = 0   # assume negligibly low energy particle
            if E &gt; E_list[-1]:
                f = f_list[-1]  # just set equal to max energy particle&#39;s coefficient
        else:
            if E &lt; E_list[0]:
                E_list = [0] + E_list
                f_list = [0] + f_list
                interp_scale = &#39;linear&#39;

            if interp_scale==&#39;log&#39;:
                cs = interp1d(np.log10(np.array(E_list)),np.log10(np.array(f_list)), kind=interp_type,fill_value=&#39;extrapolate&#39;)
                f = 10**cs(np.log10(E))
            else:
                cs = interp1d(np.array(E_list),np.array(f_list), kind=interp_type,fill_value=&#39;extrapolate&#39;)
                f = cs(E)

            # for sake of sanity, return zero for values quite below minimum coefficients
            if f &lt; 1e-4:
                f = 0.0


        #if interp_type==&#39;cubic&#39;:
        #    if interp_scale==&#39;log&#39;:
        #        cs = interp1d(np.log10(np.array(E_list)),np.log10(np.array(f_list)), kind=&#39;cubic&#39;,fill_value=&#39;extrapolate&#39;)
        #        f = 10**cs(np.log10(E))
        #    else:
        #        cs = interp1d(np.array(E_list),np.array(f_list), kind=&#39;cubic&#39;,fill_value=&#39;extrapolate&#39;)
        #        f = cs(E)
        #else:
        #    if interp_scale==&#39;log&#39;:
        #        f = 10**np.interp(np.log10(E),np.log10(np.array(E_list)),np.log10(np.array(f_list)))
        #    else:
        #        f = np.interp(E,np.array(E_list),np.array(f_list))

        #if interp_type==&#39;cubic&#39;:
        #    if interp_scale==&#39;log&#39;:
        #        cs = lagrange(np.log10(np.array(E_list)),np.log10(np.array(f_list)))
        #        f = 10**cs(np.log10(E))
        #    else:
        #        cs = lagrange(np.array(E_list),np.array(f_list))
        #        f = cs(E)
        #if interp_type==&#39;cubic&#39;:
        #    if interp_scale==&#39;log&#39;:
        #        cs = CubicSpline(np.log10(np.array(E_list)),np.log10(np.array(f_list)))
        #        f = 10**cs(np.log10(E))
        #    else:
        #        cs = CubicSpline(np.array(E_list),np.array(f_list))
        #        f = cs(E)

    return f

def split_into_header_and_content(output_file_path):
    &#39;&#39;&#39;
    Description:
        Initial parsing of a PHITS tally output file to isolate its header section (containing metadata) and main
        tally results &#34;content&#34; section for later processing.

    Inputs:
        - `output_file_path` = path to a PHITS tally output file

    Outputs:
        - `header` = list of lines belonging to the tally output&#39;s header section
        - `content` = list of lists of remaining lines after the tally output&#39;s header section; the top level list is
                broken into &#34;blocks&#34; (&#34;newpage:&#34;-separated) which are lists of lines belonging to each block/page.

    &#39;&#39;&#39;
    in_content = False
    header, content = [], [[]]
    with open(output_file_path, mode=&#39;rb&#39;) as f:
        for line in f:
            if b&#39;\x00&#39; in line:
                line = line.replace(b&#34;\x00&#34;, b&#34;&#34;)
            line = line.decode()
            #if &#34;\x00&#34; in line: line = line.replace(&#34;\x00&#34;, &#34;&#34;)
            if &#39;#newpage:&#39; in line:
                in_content = True
                continue
            if in_content:
                if &#39;newpage:&#39; in line:
                    content.append([])
                    continue
                content[-1].append(line.strip())
            else:
                header.append(line.strip())
    # add &#34;footer&#34; to peel off last bit of &#34;content&#34; section?
    return header, content




def extract_data_from_header_line(line):
    &#39;&#39;&#39;
    Description:
        Extract a &#34;key&#34; and its corresponding value from a PHITS tally output header line

    Dependencies:
        - `is_number` (function within the &#34;PHITS tools&#34; package)

    Inputs:
        - `line` = string to be processed

    Outputs:
        - `key` = a string &#34;key&#34; to become a key in the metadata dictionary
        - `value` = corresponding value they &#34;key&#34; is equal to; dtype is string, int, or float
    &#39;&#39;&#39;
    if &#39;#&#39; in line:
        info, trash = line.split(&#39;#&#39;,1)
    else:
        info = line
    key, value = info.split(&#39;=&#39;)
    key = key.strip()
    value = value.strip()
    if is_number(value):
        if &#39;.&#39; in value:
            value = float(value)
        else:
            value = int(value)
    return key, value

def data_row_to_num_list(line):
    &#39;&#39;&#39;
    Description:
        Extract numeric values from line of text from PHITS tally output content section

    Dependencies:
        - `is_number` (function within the &#34;PHITS tools&#34; package)

    Inputs:
        - `line` = string to be processed

    Outputs:
        - `values` = a list of ints and/or floats of numeric values in `line`
    &#39;&#39;&#39;
    value_strs = line.strip().split()
    values = []
    for value in value_strs:
        if is_number(value):
            if &#39;.&#39; in value:
                value = float(value)
            else:
                value = int(value)
        values.append(value)
    return values



def parse_group_string(text):
    &#39;&#39;&#39;
    Description:
        Separate &#34;groups&#34; in a string, wherein a group is a standalone value or a series of values inside parentheses.

    Inputs:
        - `text` = string to be processed

    Outputs:
        - `groups` = a list of strings extracted from `text`
    &#39;&#39;&#39;
    # returns list of items from PHITS-formatted string, e.g. w/ ()
    parts = text.strip().split()
    #print(parts)
    groups = []
    curly_vals = []
    in_brackets_group = False
    in_curly_brace_group = False
    num_group_members = 0
    for i in parts:
        if &#39;(&#39; in i and &#39;)&#39; in i:
            in_brackets_group = False
            groups.append(i)
        elif &#39;(&#39; in i:
            in_brackets_group = True
            groups.append(i)
        elif &#39;)&#39; in i:
            in_brackets_group = False
            num_group_members = 0
            groups[-1] += i
        elif &#39;{&#39; in i:
            in_curly_brace_group = True
            curly_vals = []
        elif &#39;}&#39; in i:
            in_curly_brace_group = False
            curly_int_strs = [str(j) for j in range(int(curly_vals[0]), int(curly_vals[-1])+1)]
            curly_vals = []
            groups += curly_int_strs
        else:
            if in_brackets_group or in_curly_brace_group:
                if in_brackets_group:
                    if num_group_members&gt;0: groups[-1] += &#39; &#39;
                    groups[-1] += i
                    num_group_members += 1
                if in_curly_brace_group:
                    if i != &#39;-&#39;:
                        curly_vals.append(i)
            else:
                groups.append(i)
    #print(groups)
    return groups

def parse_tally_header(tally_header,tally_content):
    &#39;&#39;&#39;
    Description:
        Extracts metadata from PHITS tally output header (and some extra info from its contents section)

    Dependencies:
        - `extract_data_from_header_line` (function within the &#34;PHITS tools&#34; package)
        - `parse_group_string` (function within the &#34;PHITS tools&#34; package)

    Inputs:
        - `tally_header` = list of lines belonging to the tally output&#39;s header section
        - `tally_content` = list of lists of remaining lines after the tally output&#39;s header section; the top level list is
                broken into &#34;blocks&#34; (&#34;newpage:&#34;-separated) which are lists of lines belonging to each block/page.

    Outputs:
        - `meta` = Munch object / dictionary containing tally metadata

    &#39;&#39;&#39;
    nlines = len(tally_header)
    tally_type = tally_header[0].replace(&#39; &#39;,&#39;&#39;).replace(&#39;off&#39;,&#39;&#39;)
    if &#39;[&#39; not in tally_type and &#39;]&#39; not in tally_type: # file is not PHITS tally output
        if &#39;htitle&#39; in tally_type:
            tally_type = &#39;[T-Dchain]&#39;
        else:
            tally_type = &#39;UNKNOWN&#39;
    meta = Munch({})
    meta.tally_type = tally_type
    unsupported_tally_types = [&#39;[T-WWG]&#39;, &#39;[T-WWBG]&#39;, &#39;[T-Volume]&#39;, &#39;[T-Userdefined]&#39;, &#39;[T-Gshow]&#39;, &#39;[T-Rshow]&#39;,
                               &#39;[T-3Dshow]&#39;, &#39;[T-4Dtrack]&#39;, &#39;[T-Dchain]&#39;, &#39;UNKNOWN&#39;]
    if tally_type in unsupported_tally_types:
        return meta
    # Initialize variables for possible array
    mesh_types = [&#39;e&#39;,&#39;t&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;,&#39;r&#39;,&#39;a&#39;,&#39;l&#39;]
    for m in mesh_types: meta[&#39;n&#39;+m] = None
    meta[&#39;reg&#39;] = None
    meta[&#39;part&#39;] = None
    meta[&#39;npart&#39;] = None
    meta[&#39;nc&#39;] = None
    meta[&#39;samepage&#39;] = &#39;part&#39;
    found_mesh_kinds = []

    reading_axis_data = False
    reading_regions = False
    in_exceptional_mesh_kind = False
    for li, line in enumerate(tally_header):
        #if line[0]==&#39;#&#39;: # commented line
        if &#39;data =&#39; in line: # data section to parse
            reading_axis_data = True
            n_values_to_read = meta[&#39;n&#39;+current_data_mesh_kind] + 1
            remaining_n_values_to_read = n_values_to_read
            data_values = []
            in_exceptional_mesh_kind = False
            #print(&#39;read &#39;,n_values_to_read,current_data_mesh_kind,&#39; values&#39;)
            continue
        elif &#39;=&#39; in line:
            if line[0] == &#39;#&#39;:  # commented line
                key, value = extract_data_from_header_line(line[1:])
            else:
                key, value = extract_data_from_header_line(line)
            if in_exceptional_mesh_kind:
                if key[0]==&#39;e&#39;:
                    key = current_data_mesh_kind + key[1:]
                elif key==&#39;ne&#39;:
                    key = &#39;n&#39; + current_data_mesh_kind
            meta[key] = value

            if &#39;type&#39; in key:
                current_data_mesh_kind = key.replace(&#39;-type&#39;,&#39;&#39;)
                if current_data_mesh_kind == &#39;se&#39;: current_data_mesh_kind = &#39;e&#39;
                current_data_mesh_type = value
                found_mesh_kinds.append(current_data_mesh_kind)
                if current_data_mesh_kind in [&#39;e1&#39;,&#39;e2&#39;]:
                    in_exceptional_mesh_kind = True
                #print(current_data_mesh_kind,current_data_mesh_type)
            if key==&#39;part&#39;:
                part_groups = parse_group_string(str(value))
                kf_groups = parse_group_string(tally_header[li + 1].split(&#39;:&#39;)[1])
                if meta[&#39;npart&#39;] == None: # first instance of &#34;part&#34;
                    meta[&#39;part_groups&#39;] = part_groups
                    meta[&#39;kf_groups&#39;] = kf_groups
                    meta[&#39;npart&#39;] = len(part_groups)
                    meta[&#39;part_serial_groups&#39;] = [&#39;p&#39;+str(gi+1)+&#39;-group&#39; for gi in range(len(part_groups))]
                else: # an additional occurance of part?
                    if &#39;multiplier&#39; not in tally_header[li - 1]: # the multiplier can also be followed by an erroneous &#34;part&#34; specification
                        for pi,pg in enumerate(part_groups):
                            if pg not in meta[&#39;part_groups&#39;]:
                                meta[&#39;part_groups&#39;] += [pg]
                                meta[&#39;kf_groups&#39;] += kf_groups[pi]
                                meta[&#39;npart&#39;] += 1
                                meta[&#39;part_serial_groups&#39;] += [&#39;p&#39; + str(pi + 1) + &#39;-group&#39;]
            if key==&#39;reg&#39;:
                if meta[&#39;tally_type&#39;]==&#39;[T-Cross]&#39;:
                    num_regs = value
                    meta[&#39;num_reg_groups&#39;] = num_regs
                    meta[&#39;reg_groups&#39;] = []
                    # manually read in reg groups
                    li_start = li+2
                    li_stop = li_start + num_regs
                    for lii in range(li_start,li_stop):
                        non, rfrom, rto, area = tally_header[lii].split()
                        meta[&#39;reg_groups&#39;].append(rfrom+&#39; - &#39;+rto)
                else:
                    reg_groups = parse_group_string(str(value))
                    eli = 0 # extra line index
                    if &#39;=&#39; not in tally_header[eli+li+1] and &#39;volume&#39; not in tally_header[eli+li+1]: # reg specification continues to next line
                        while &#39;=&#39; not in tally_header[eli+li+1] and &#39;volume&#39; not in tally_header[eli+li+1]:
                            reg_groups += parse_group_string(tally_header[eli+li+1].strip())
                            eli += 1
                    if &#39;all&#39; in reg_groups and &#39;volume&#39; in tally_header[li+1] and &#39;=&#39; not in tally_header[eli+li+1]:
                        # parse table of regions...
                        found_reg_grps = []
                        meta[&#39;reg_groups_inputted&#39;] = reg_groups
                        reg_lines = tally_header[li+3:]
                        for reg_line in reg_lines:
                            if &#39;=&#39; in reg_line: break
                            line_parts = reg_line.split(&#39;#&#39;)
                            if len(line_parts) &gt;= 2:
                                found_reg_grps.append(line_parts[1].strip())
                            else:
                                found_reg_grps.append(line_parts[0].split()[1])
                        meta[&#39;reg_groups&#39;] = found_reg_grps
                        meta[&#39;num_reg_groups&#39;] = len(found_reg_grps)
                    else:
                        meta[&#39;reg_groups&#39;] = reg_groups
                        meta[&#39;num_reg_groups&#39;] = len(reg_groups)
            if key == &#39;point&#39;:
                num_regs = value
                meta[&#39;point_detectors&#39;] = {&#39;non&#39;:[], &#39;x&#39;:[], &#39;y&#39;:[], &#39;z&#39;:[], &#39;r0&#39;:[]} # [T-Point] points
                li_start = li + 2
                li_stop = li_start + num_regs
                for lii in range(li_start, li_stop):
                    non, tppx, tppy, tppz, tppr0 = tally_header[lii].split()
                    meta[&#39;point_detectors&#39;][&#39;non&#39;].append(non)
                    meta[&#39;point_detectors&#39;][&#39;x&#39;].append(tppx)
                    meta[&#39;point_detectors&#39;][&#39;y&#39;].append(tppy)
                    meta[&#39;point_detectors&#39;][&#39;z&#39;].append(tppz)
                    meta[&#39;point_detectors&#39;][&#39;r0&#39;].append(tppr0)
            if key == &#39;ring&#39;:
                num_regs = value
                meta[&#39;point_detectors&#39;] = {&#39;non&#39;:[], &#39;axis&#39;:[], &#39;ar&#39;:[], &#39;rr&#39;:[], &#39;r0&#39;:[]} # [T-Point] points
                li_start = li + 2
                li_stop = li_start + num_regs
                for lii in range(li_start, li_stop):
                    non, tppx, tppy, tppz, tppr0 = tally_header[lii].split()
                    meta[&#39;point_detectors&#39;][&#39;non&#39;].append(non)
                    meta[&#39;point_detectors&#39;][&#39;axis&#39;].append(tppx)
                    meta[&#39;point_detectors&#39;][&#39;ar&#39;].append(tppy)
                    meta[&#39;point_detectors&#39;][&#39;rr&#39;].append(tppz)
                    meta[&#39;point_detectors&#39;][&#39;r0&#39;].append(tppr0)
        elif reading_axis_data:
            values = line.replace(&#39;#&#39;,&#39;&#39;).strip().split()
            for val in values:
                data_values.append(float(val))
                remaining_n_values_to_read += -1
            if remaining_n_values_to_read &lt;= 0:
                reading_axis_data = False
                data_values = np.array(data_values)
                meta[current_data_mesh_kind+&#39;-mesh_bin_edges&#39;] = data_values
                meta[current_data_mesh_kind+&#39;-mesh_bin_mids&#39;] = 0.5*(data_values[1:]+data_values[:-1])
                #meta[current_data_mesh_kind+&#39;-mesh_bin_mids_log&#39;] = np.sqrt(data_values[1:]*data_values[:-1])
                # generate log-centered bin mids
                bin_mids_log = []
                for i in range(len(data_values)-1):
                    if data_values[i+1]&lt;=0 or data_values[i]&lt;=0: # if one or both edges &lt;= 0
                        if data_values[i+1]&lt;0 and data_values[i]&lt;0: # both values are negative
                            bin_mids_log.append(-1*np.sqrt(data_values[i]*data_values[i+1]))
                        elif data_values[i+1]==0 or data_values[i]==0: # one value is zero
                            # use linear center instead...
                            bin_mids_log.append(0.5*(data_values[i]+data_values[i+1]))
                        elif data_values[i+1]&lt;0 or data_values[i]&lt;0: # bin straddles zero
                            # use linear center instead...
                            bin_mids_log.append(0.5*(data_values[i]+data_values[i+1]))
                        else:
                            print(&#39;unknown binning encountered, skipping generation of log-scale bin mids for &#39;+current_data_mesh_kind+&#39;-mesh&#39;)
                            break
                    else:
                        bin_mids_log.append(np.sqrt(data_values[i]*data_values[i+1]))
                meta[current_data_mesh_kind+&#39;-mesh_bin_mids_log&#39;] = np.array(bin_mids_log)
            continue
        else:
            continue

    meta[&#39;found_mesh_kinds&#39;] = found_mesh_kinds

    if meta[&#39;tally_type&#39;]==&#39;[T-Cross]&#39;:
        if meta[&#39;mesh&#39;]==&#39;xyz&#39;:
            if &#39;enclos&#39; in meta and meta[&#39;enclos&#39;]==1:
                pass # total items remains nx*ny*nz
            else:
                meta[&#39;nz_original&#39;] = meta[&#39;nz&#39;]
                meta[&#39;nz&#39;] += 1 # zmesh surfaces are scored, making array nx*ny*(nz+1)
        elif meta[&#39;mesh&#39;]==&#39;r-z&#39;:
            if &#39;enclos&#39; in meta and meta[&#39;enclos&#39;]==1:
                pass # total items remains nr*nz
            else:
                # Current solution addresses this by expanding the ierr axis
                meta[&#39;nr_original&#39;] = meta[&#39;nr&#39;]
                meta[&#39;nz_original&#39;] = meta[&#39;nz&#39;]
                meta[&#39;nr&#39;] = meta[&#39;nr&#39;] + 1
                meta[&#39;nz&#39;] = meta[&#39;nz&#39;] + 1
                # OLD SOLUTION IMPLEMENTED IS BELOW
                # max total num of pages = nrsurf*nz + nzsurf*nr = (nr+1)*nz + nr*(nz+1) = 2*nr*nz + nr + nz
                # if one radius is 0, this becomes = nr*nz + nr*(nz+1) = 2*nr*nz + nr
                # Solution used here:
                # use ir to iterate nr, use iy to iterate nrsurf, use iz to iterate nz, use ic to iterate nzsurf
                # since only rsurf*z [iy,iz] and r*zsurf [ir,ic] pairs exist, when one pair is being written
                # the other will be [-1,-1], hence the dimensions for the array are increased by an extra 1 to prevent overlap
                #meta[&#39;nr_original&#39;] = meta[&#39;nr&#39;]
                #meta[&#39;nz_original&#39;] = meta[&#39;nz&#39;]
                #meta[&#39;ny_original&#39;] = meta[&#39;ny&#39;]
                ##meta[&#39;nc_original&#39;] = meta[&#39;nc&#39;]
                #meta[&#39;ny&#39;] = meta[&#39;nr&#39;] + 1 + 1
                #meta[&#39;nc&#39;] = meta[&#39;nz&#39;] + 1 + 1
                #meta[&#39;nr&#39;] = meta[&#39;nr&#39;] + 1
                #meta[&#39;nz&#39;] = meta[&#39;nz&#39;] + 1

    if meta[&#39;tally_type&#39;] == &#39;[T-Point]&#39;:
        if &#39;mesh&#39; not in meta:
            if &#39;point&#39; in meta:
                meta[&#39;mesh&#39;] = &#39;point&#39;
                meta[&#39;nreg&#39;] = meta[&#39;point&#39;]
            elif &#39;ring&#39; in meta:
                meta[&#39;mesh&#39;] = &#39;ring&#39;
                meta[&#39;nreg&#39;] = meta[&#39;ring&#39;]


    axes_1D = [&#39;eng&#39;,&#39;reg&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;,&#39;r&#39;,&#39;t&#39;,&#39;cos&#39;,&#39;the&#39;,&#39;mass&#39;,&#39;charge&#39;,&#39;let&#39;,&#39;tet&#39;,&#39;eng1&#39;,&#39;eng2&#39;,&#39;sed&#39;,&#39;rad&#39;,&#39;deg&#39;,&#39;act&#39;]
    axes_2D = [&#39;xy&#39;,&#39;yz&#39;,&#39;zx&#39;,&#39;rz&#39;,&#39;chart&#39;,&#39;dchain&#39;,&#39;t-eng&#39;,&#39;eng-t&#39;,&#39;t-e1&#39;,&#39;e1-t&#39;,&#39;t-e2&#39;,&#39;e2-t&#39;,&#39;e12&#39;,&#39;e21&#39;,&#39;xz&#39;,&#39;yx&#39;,&#39;zy&#39;,&#39;zr&#39;]

    axes_ital_1D = [3,   0,  0,  1,  2,  0,  4,    5,    5,     8,       8,    6,    0,     3,     8,    3,    5,    5,   8]
    axes_ital_2D = [ [0,1],[1,2],[2,0],[0,2],[None,None],[None,None],[4,3],[3,4],[4,3],[3,4],[4,8],[8,4],[3,8],[8,3],[0,2],[1,0],[2,1],[2,0]]


    if meta[&#39;axis&#39;] in axes_1D:
        meta[&#39;axis_dimensions&#39;] = 1
        meta[&#39;axis_index_of_tally_array&#39;] = axes_ital_1D[axes_1D.index(meta[&#39;axis&#39;])]
    elif meta[&#39;axis&#39;] in axes_2D:
        meta[&#39;axis_dimensions&#39;] = 2
        meta[&#39;axis_index_of_tally_array&#39;] = axes_ital_2D[axes_2D.index(meta[&#39;axis&#39;])]
    else:
        print(&#34;WARNING: axis value of &#34;,meta[&#39;axis&#39;],&#34; is not in list of known/registered values&#34;)
        meta[&#39;axis_dimensions&#39;] = None
        meta[&#39;axis_index_of_tally_array&#39;] = None




    # Now extract portion of metadata only available from tally content

    if meta[&#39;mesh&#39;] == &#39;reg&#39; or meta[&#39;mesh&#39;] == &#39;tet&#39;:
        num, reg, vol = [], [], []
        if meta[&#39;axis&#39;]==&#39;reg&#39; or meta[&#39;axis&#39;]==&#39;tet&#39;:  # get number of regions and region data from first block of tally content
            outblock = tally_content[0]
            in_reg_list = False
            for line in outblock:
                if &#39;#&#39; in line and &#39; num &#39; in line:
                    cols = line[1:].split()
                    #print(cols)
                    in_reg_list = True
                    continue
                if len(line.split()) == 0 or &#39;{&#39; in line:
                    in_reg_list = False
                if in_reg_list:
                    vals = line.split()
                    if meta[&#39;tally_type&#39;] == &#39;[T-Cross]&#39;:
                        num.append(vals[0])
                        reg.append(vals[0])
                        vol.append(vals[1])
                    else:
                        num.append(vals[0])
                        reg.append(vals[1])
                        vol.append(vals[2])
        else: # scan output for region numbers:
            regcount = 0
            for outblock in tally_content:
                for line in outblock:
                    if &#39;reg =&#39; in line or &#39;reg  =&#39; in line:
                        eq_strs = split_str_of_equalities(line[1:])
                        reg_eq_str = &#39;&#39;
                        for eqsi in eq_strs:
                            if &#39;reg&#39; in eqsi:
                                reg_eq_str = eqsi
                                break
                        regnum = reg_eq_str.split(&#39;=&#39;)[1].strip()
                        #regnum = line.strip().split(&#39;reg =&#39;)[1].strip().replace(&#34;&#39;&#34;,&#39;&#39;)
                        if regnum not in reg:
                            regcount += 1
                            num.append(regcount)
                            reg.append(regnum)
                            vol.append(None)
                        continue
        if meta[&#39;mesh&#39;] == &#39;reg&#39;:
            meta.reg_serial_num = num
            meta.reg_num = reg
            if meta[&#39;tally_type&#39;] == &#39;[T-Cross]&#39;:
                meta.reg_area = vol
            else:
                meta.reg_volume = vol
            meta.nreg = len(reg)
        elif meta[&#39;mesh&#39;] == &#39;tet&#39;:
            meta.tet_serial_num = num
            meta.tet_num = reg
            meta.reg_num = reg
            #meta.tet_volume = vol
            if meta[&#39;tally_type&#39;] == &#39;[T-Cross]&#39;:
                meta.tet_area = vol
            else:
                meta.tet_volume = vol
            meta.ntet = len(reg)

        #if meta[&#39;tally_type&#39;] == &#39;[T-Cross]&#39;:
        #    meta[&#39;reg_groups&#39;] = reg



    elif meta[&#39;mesh&#39;] == &#39;tet&#39;:
        num, reg, vol = [], [], []
        if meta[&#39;axis&#39;] == &#39;tet&#39;:
            pass
        else:
            pass
        print(&#39;mesh=tet has not been tested!&#39;)
        meta.ntet = 0

    axis1_label = &#39;&#39;
    axis2_label = &#39;&#39;
    value_label = &#39;&#39;
    hc_passed = False # passed colorbar definition line
    outblock = tally_content[0]
    for line in outblock:
        if len(line) == 0: continue
        if line[:2] == &#39;x:&#39;:
            axis1_label = line[2:].strip()
        if line[:2] == &#39;y:&#39;:
            if meta.axis_dimensions == 1:
                value_label = line[2:].strip()
                #break
            elif meta.axis_dimensions == 2:
                if hc_passed: # second instance of y:
                    value_label = line[2:].strip()
                    #break
                else: # first instance of y:
                    axis2_label = line[2:].strip()
                    hc_passed = True
        #if line[:3] == &#39;hc:&#39;:
        #    hc_passed = True
        h_line_str = &#39;&#39;
        if line[0] == &#39;h&#39; and (line[1] == &#39;:&#39; or line[2] == &#39;:&#39;):
            if meta[&#39;axis_dimensions&#39;] == 1:
                ndatacol = line.count(&#39; y&#39;)
                if ndatacol != 1:  # multiple columns are present &#34;samepage&#34;
                    # get first string with y
                    col_groups = parse_group_string(line)
                    i_first_y = next((i for i,v in enumerate(col_groups) if v[0]==&#39;y&#39;), None) # index of first column with &#34;y&#34;
                    first_data_col_header = col_groups[i_first_y][2:]
                    for m in mesh_types:
                        if first_data_col_header[0] == m:
                            if m == &#39;e&#39;:
                                meta[&#39;samepage&#39;] = &#39;eng&#39;
                            elif m == &#39;r&#39;:
                                if first_data_col_header[:3] == &#39;reg&#39;:
                                    meta[&#39;samepage&#39;] = &#39;reg&#39;
                                else:
                                    meta[&#39;samepage&#39;] = m
                            elif m == &#39;l&#39;:
                                meta[&#39;samepage&#39;] = &#39;let&#39;
                            elif m == &#39;a&#39;:
                                if first_data_col_header[:3] not in [&#39;all&#39;,&#39;alp&#39;]:
                                    meta[&#39;samepage&#39;] = &#39;the&#39; # or cos
                            else:
                                meta[&#39;samepage&#39;] = m
                    if meta[&#39;samepage&#39;] == &#39;part&#39;:  # still is default value
                        # double check to see if it could be region numbers vs particle names
                        if ndatacol != meta[&#39;npart&#39;]:
                            if &#39;num_reg_groups&#39; in meta and ndatacol == meta[&#39;num_reg_groups&#39;]:
                                meta[&#39;samepage&#39;] = &#39;reg&#39;
                            else:
                                print(&#39;&#34;samepage&#34; was not correctly identified; needs to be implemented&#39;)
                    if meta[&#39;samepage&#39;] == &#39;reg&#39;:
                        hcols = parse_group_string(line[3:])
                        num, reg, vol = [], [], []
                        reg_ser_num = 1
                        for hcol in hcols:
                            if hcol[0] == &#39;y&#39;:
                                num.append(reg_ser_num)
                                reg_ser_num += 1
                                reg.append(hcol.split(&#39;)&#39;)[0].replace(&#39;y(reg&#39;,&#39;&#39;))
                                vol.append(None)
                        meta.reg_serial_num = num
                        meta.reg_num = reg
                        meta.reg_volume = vol
                        meta.nreg = len(reg)

            break
    meta.axis1_label = axis1_label
    meta.axis2_label = axis2_label
    meta.value_label = value_label

    # Now do any final overrides for specific tallies / circumstances

    if meta[&#39;tally_type&#39;] == &#39;[T-Deposit2]&#39;:
        meta[&#39;nreg&#39;] = 1
        meta[&#39;reg_serial_num&#39;] = [1]
        meta[&#39;reg_num&#39;] = [&#39;1&#39;]
        meta[&#39;reg_volume&#39;] = [None]
        if meta[&#39;num_reg_groups&#39;] &gt; 1:
            meta[&#39;num_reg_groups&#39;] = 1
            meta[&#39;reg_groups&#39;] = [meta[&#39;reg_groups&#39;][0] + &#39; &#39; + meta[&#39;reg_groups&#39;][1]]

    if meta[&#39;tally_type&#39;] == &#39;[T-Heat]&#39;:
        if &#39;npart&#39; not in meta or meta[&#39;npart&#39;] == None: meta[&#39;npart&#39;] = 1
        if &#39;part_groups&#39; not in meta: meta[&#39;part_groups&#39;] = [&#39;all&#39;]

    return meta

def initialize_tally_array(tally_metadata,include_abs_err=True):
    &#39;&#39;&#39;
    Description:
        Initializes main tally data array in which tally results will be stored when read

    Dependencies:
        - `import numpy as np`

    Inputs:
        - `tally_metadata` = Munch object / dictionary containing tally metadata
        - `include_abs_err` = a Boolean (D=`True`) on whether absolute error will be calculated; the final dimension of `tdata` is
                `3/2` if this value is `True/False`

    Outputs:
        - `tdata` = 10-dimensional NumPy array of zeros of correct size for holding tally results

    &#39;&#39;&#39;
    ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max = 1, 1, 1, 1, 1, 1, 1, 1, 1
    if include_abs_err:
        ierr_max = 3
    else:
        ierr_max = 2
    if tally_metadata[&#39;mesh&#39;] == &#39;reg&#39;:
        ir_max = tally_metadata.nreg
    elif tally_metadata[&#39;mesh&#39;] == &#39;xyz&#39;:
        ir_max = tally_metadata.nx
        iy_max = tally_metadata.ny
        iz_max = tally_metadata.nz
    elif tally_metadata[&#39;mesh&#39;] == &#39;r-z&#39;:
        ir_max = tally_metadata.nr
        iz_max = tally_metadata.nz
        if &#39;ny&#39; in tally_metadata and tally_metadata.ny != None: iy_max = tally_metadata.ny
        if &#39;nc&#39; in tally_metadata and tally_metadata.nc != None: ic_max = tally_metadata.nc
    elif tally_metadata[&#39;mesh&#39;] == &#39;tet&#39;:
        ir_max = tally_metadata.ntet
    elif tally_metadata[&#39;mesh&#39;] == &#39;point&#39; or tally_metadata[&#39;mesh&#39;] == &#39;ring&#39;:
        ir_max = tally_metadata.nreg
    else:
        raise ValueError(&#39;ERROR! Unknown geometry mesh:&#39;+ str(tally_metadata[&#39;mesh&#39;]))

    if tally_metadata.na != None: ia_max = tally_metadata.na
    if tally_metadata.nt != None: it_max = tally_metadata.nt
    if tally_metadata.nl != None: il_max = tally_metadata.nl
    if &#39;nc&#39; in tally_metadata and tally_metadata.nc != None: ic_max = tally_metadata.nc
    #if &#39;npart&#39; in tally_metadata and tally_metadata.npart != None: ip_max = tally_metadata.np

    if tally_metadata.ne == None:
        if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Deposit2]&#39;:
            if &#39;ne1&#39; in tally_metadata:
                ie_max = tally_metadata.ne1
            if &#39;ne2&#39; in tally_metadata:
                ic_max = tally_metadata.ne2
        elif &#39;e1&#39; in tally_metadata.axis or &#39;e2&#39; in tally_metadata.axis:  # This should now be redundant?
            if tally_metadata.axis == &#39;e12&#39;:
                ie_max = tally_metadata.ne1
                ic_max = tally_metadata.ne2
            elif tally_metadata.axis == &#39;e21&#39;:
                ie_max = tally_metadata.ne1
                ic_max = tally_metadata.ne2
            elif &#39;e1&#39; in tally_metadata.axis or &#39;eng1&#39; in tally_metadata.axis:
                ie_max = tally_metadata.ne1
                if &#39;ne2&#39; in tally_metadata:
                    ic_max = tally_metadata.ne2
            elif &#39;e2&#39; in tally_metadata.axis or &#39;eng2&#39; in tally_metadata.axis:
                ic_max = tally_metadata.ne2
                if &#39;ne1&#39; in tally_metadata:
                    ie_max = tally_metadata.ne1
            else:
                if &#39;ne1&#39; in tally_metadata:
                    ie_max = tally_metadata.ne1
                if &#39;ne2&#39; in tally_metadata:
                    ic_max = tally_metadata.ne2

    else:
        ie_max = tally_metadata.ne

    ip_max = tally_metadata.npart

    if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Cross]&#39; and tally_metadata.mesh == &#39;r-z&#39;:
        if &#39;enclos&#39; in tally_metadata and tally_metadata[&#39;enclos&#39;] == 1:
            pass
        else: # enclos = 0 case
            ierr_max = 2*ierr_max

    if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Yield]&#39;:
        if tally_metadata.axis == &#39;charge&#39;:
            ic_max = 130
        elif tally_metadata.axis == &#39;mass&#39;:
            ic_max = 320
        elif tally_metadata.axis == &#39;chart&#39;:
            if int(tally_metadata.mxnuclei) == 0:
                ic_max = 10000
            else:
                ic_max = int(tally_metadata.mxnuclei)

    if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Interact]&#39; and tally_metadata[&#39;axis&#39;] == &#39;act&#39;:
        ic_max = 100
        if &#39;maxact&#39; in tally_metadata:
            ic_max = tally_metadata.maxact

    if in_debug_mode:
        dims_str = &#39;tally dims: nr={:g}, ny={:g}, nz={:g}, ne={:g}, nt={:g}, na={:g}, nl={:g}, np={:g}, nc={:g}, nerr={:g}&#39;
        print(dims_str.format(ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max, ierr_max))
    tally_data = np.zeros((ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max, ierr_max))
    return tally_data

def calculate_tally_absolute_errors(tdata):
    &#39;&#39;&#39;
    Description:
        Calculates the absolute uncertainty for every value in the PHITS tally data array

    Inputs:
        - `tdata` = 10-dimensional NumPy array containing read/extracted tally results

    Outputs:
        - `tdata` = updated `tdata` array now with absolute uncertainties in `ierr = 2` index

    &#39;&#39;&#39;

    ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max, ierr_max = np.shape(tdata)
    for ir in range(ir_max):
        for iy in range(iy_max):
            for iz in range(iz_max):
                for ie in range(ie_max):
                    for it in range(it_max):
                        for ia in range(ia_max):
                            for il in range(il_max):
                                for ip in range(ip_max):
                                    for ic in range(ic_max):
                                        tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 2] = \
                                            tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 0] * \
                                            tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 1]
    if ierr_max==6:
        for ir in range(ir_max):
            for iy in range(iy_max):
                for iz in range(iz_max):
                    for ie in range(ie_max):
                        for it in range(it_max):
                            for ia in range(ia_max):
                                for il in range(il_max):
                                    for ip in range(ip_max):
                                        for ic in range(ic_max):
                                            tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 5] = \
                                                tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 3] * \
                                                tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 4]

    return tdata

def split_str_of_equalities(text):
    &#39;&#39;&#39;
    Description:
        Extract relevant regions, indices, etc. from somewhat inconsistently formatted lines in PHITS tally output content section.

    Dependencies:
        - `is_number` (function within the &#34;PHITS tools&#34; package)

    Inputs:
        - `text` = string to be processed

    Outputs:
        - `equalities_str_list` = list of strings of equalities each of the format &#34;key = value&#34;

    &#39;&#39;&#39;
    equalities_str_list = []
    original_text = text
    #if text[0] == &#34;&#39;&#34;: # more loosely formatted text
    #    problem_strs = [&#39;tot DPA&#39;]
    text = text.replace(&#34;&#39;&#34;,&#39;&#39;).replace(&#39;,&#39;,&#39; &#39;).replace(&#39;#&#39;,&#39;&#39;).replace(&#39;=&#39;,&#39; = &#39;)
    text_pieces = text.split()
    #i_equal_sign = [i for i, x in enumerate(text_pieces) if x == &#34;=&#34;]
    is_i_equal_sign = [x==&#39;=&#39; for x in text_pieces]
    #i_is_number = [i for i, x in enumerate(text_pieces) if is_number(x)]
    is_i_number = [is_number(x) for x in text_pieces]
    #num_equalities = len(i_equal_sign)
    #remaining_equalities = num_equalities
    equality_str = &#39;&#39;
    # the only condition enforced is that the last item in each value be numeric or )
    current_equality_contains_equalsign = False
    for i in reversed(range(len(text_pieces))): # easiest to build from right to left
        equality_str = text_pieces[i] + &#39; &#39; + equality_str
        if is_i_equal_sign[i]:
            current_equality_contains_equalsign = True
        elif current_equality_contains_equalsign: # looking to terminate if next item is numeric
            if i==0 or (is_i_number[i-1] or text_pieces[i-1][-1]==&#39;)&#39;): # either final equality completed or next item belongs to next equality
                equalities_str_list.insert(0,equality_str.strip())
                equality_str = &#39;&#39;
                current_equality_contains_equalsign = False
    if &#39;(&#39; in text: # need to break up potential (ia,ib) pairs
        new_eq_str_list = []
        for x in equalities_str_list:
            if &#39;(&#39; in x:
                keys, values = x.split(&#39;=&#39;)
                keys = keys.strip().replace(&#39;(&#39;,&#39;&#39;).replace(&#39;)&#39;,&#39;&#39;).split()
                values = values.strip().replace(&#39;(&#39;,&#39;&#39;).replace(&#39;)&#39;,&#39;&#39;).split()
                for i in range(len(keys)):
                    new_eq_str = keys[i].strip() + &#39; = &#39; + values[i].strip()
                    new_eq_str_list.append(new_eq_str)
            else:
                new_eq_str_list.append(x)
        equalities_str_list = new_eq_str_list
    #print(equalities_str_list)
    return equalities_str_list


def parse_tally_content(tdata,meta,tally_blocks,is_err_in_separate_file,err_mode=False):
    &#39;&#39;&#39;
    Description:
        Parses the PHITS tally output content section and extract its results

    Dependencies:
        - `split_str_of_equalities` (function within the &#34;PHITS tools&#34; package)
        - `parse_group_string` (function within the &#34;PHITS tools&#34; package)
        - `data_row_to_num_list` (function within the &#34;PHITS tools&#34; package)

    Inputs:
        - `tdata` = 10-dimensional NumPy array of zeros of correct size to hold tally output/results
        - `meta` = Munch object / dictionary containing tally metadata
        - `tally_blocks` = blocks of tally output as outputted by the `split_into_header_and_content` function
        - `is_err_in_separate_file` = Boolean denoting whether the tally&#39;s relative errors are located in a separate file
        - `err_mode` = Boolean (D=`False`) used for manually forcing all read values to be regarded as relative uncertainties
                as is necessary when processing dedicated *_err files.

    Outputs:
        - `tdata` = updated `tdata` array containing read/extracted tally results

    &#39;&#39;&#39;
    global ir, iy, iz, ie, it, ia, il, ip, ic, ierr
    global ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max, ierr_max
    ierr = 0
    if is_err_in_separate_file and err_mode:
        ierr = 1

    mesh_kind_chars = [&#39;e&#39;, &#39;t&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;r&#39;, &#39;a&#39;, &#39;l&#39;]
    mesh_kind_iax = [3, 4, 0, 1, 2, 0, 5, 6]
    tdata_ivar_strs = [&#39;ir&#39;, &#39;iy&#39;, &#39;iz&#39;, &#39;ie&#39;, &#39;it&#39;, &#39;ia&#39;, &#39;il&#39;, &#39;ip&#39;, &#39;ic&#39;]
    ir, iy, iz, ie, it, ia, il, ip, ic = 0, 0, 0, 0, 0, 0, 0, 0, 0

    ignored_eq_strs = [&#39;axis&#39;,&#39;axs&#39;,&#39;ar&#39;,&#39;rr&#39;,&#39;m jm&#39;,&#39;Z&#39;,&#39;cmax nmax&#39;]
    replace_eq_strs_dict = {&#39;ang&#39;:&#39;a&#39;}

    ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max, ierr_max = np.shape(tdata)

    axes_1D = [&#39;eng&#39;, &#39;reg&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;r&#39;, &#39;t&#39;, &#39;cos&#39;, &#39;the&#39;, &#39;mass&#39;, &#39;charge&#39;, &#39;let&#39;, &#39;tet&#39;, &#39;eng1&#39;, &#39;eng2&#39;,
               &#39;sed&#39;, &#39;rad&#39;, &#39;deg&#39;, &#39;act&#39;]
    axes_2D = [&#39;xy&#39;, &#39;yz&#39;, &#39;zx&#39;, &#39;rz&#39;, &#39;chart&#39;, &#39;dchain&#39;,
               &#39;t-eng&#39;, &#39;eng-t&#39;, &#39;t-e1&#39;, &#39;e1-t&#39;, &#39;t-e2&#39;, &#39;e2-t&#39;,
               &#39;e12&#39;, &#39;e21&#39;, &#39;xz&#39;, &#39;yx&#39;, &#39;zy&#39;, &#39;zr&#39;]

    axes_ital_1D = [3, 0, 0, 1, 2, 0, 4, 5, 5, 8, 8, 6, 0, 3, 8,
                    3, 5, 5, 8]
    axes_ital_2D = [[0, 1], [1, 2], [2, 0], [0, 2], [None, None], [None, None],
                    [4, 3], [3, 4], [4, 3], [3, 4], [4, 8], [8, 4],
                    [3, 8], [8, 3], [0, 2], [1, 0], [2, 1], [2, 0]]

    ierr_mod = 0 # add to ierr for weird [T-Cross], mesh=r-z, enclos=0 case

    banked_uninterpreted_lines = [] # store lines with equalities that may be useful but are skipped owing to being a bit exceptional
    i_metastable = 0
    ZZZAAAM_list = []

    if meta.axis_dimensions==1:
        for bi, block in enumerate(tally_blocks):
            hli, fli = 0,0
            ierr_mod = 0
            hli_found = False
            for li, line in enumerate(block):
                if len(line) == 0: continue
                if line[:2].lower() == &#39;h:&#39;:  # start of data is here
                    hli = li
                    hli_found = True
                    continue
                if hli_found and (line[:12] == &#39;#   sum over&#39; or line[:7] == &#39;#   sum&#39; or line[:5] == &#39;#----&#39; or (len(block[li-1]) == 0 and hli != 0 and li&gt;hli+2) or &#34;&#39;&#34; in line or &#39;{&#39; in line):
                    fli = li
                    if (len(block[li-1]) == 0 and hli != 0 and li&gt;hli+2): fli = li - 1 # triggered by blank line after data
                    #if &#34;&#39;&#34; in line or &#39;{&#39; in line:
                    #    fli = li-1
                    break

            data_header = block[:hli]
            data_table = block[hli:fli]
            data_footer = block[fli:]

            if bi == len(tally_blocks) - 1:
                ffli = len(data_footer)
                for li, line in enumerate(data_footer):
                    if line[:37] == &#39;# Information for Restart Calculation&#39;:
                        ffli = li
                        break
                data_footer = data_footer[:ffli]

            # print(data_header)
            #print(data_table)
            # print(data_footer)

            hash_line_already_evaluated = False

            # try to get relevant indices data from header and footer blocks
            for li, line in enumerate(data_header+data_footer):
                if len(line) == 0: continue

                if &#39;=&#39; in line and (line[0] == &#34;&#39;&#34; or (line[0] == &#34;#&#34; and (&#39;no.&#39; in line or &#39;i&#39; in line or &#39;reg&#39; in line or &#39;part&#39; in line))):
                    if line[0] == &#34;#&#34;:
                        hash_line_already_evaluated = True
                    elif line[0] == &#34;&#39;&#34; and hash_line_already_evaluated:
                        if meta[&#39;samepage&#39;] == &#39;part&#39;:
                            continue  # &#39;-starting lines tend to have more problematic formatting, best skipped if possible
                        elif meta[&#39;npart&#39;] == 1:
                            continue  # can still skip if only one particle group tallied
                        else:
                            pass  # but this needs to be parsed if not using samepage = part and npart &gt; 1
                    parts = split_str_of_equalities(line)
                    #print(line)
                    for part in parts:
                        mesh_char = part.split(&#39;=&#39;)[0].strip().replace(&#39;i&#39;,&#39;&#39;)
                        #print(mesh_char)
                        if mesh_char == &#39;no.&#39;:
                            if &#39;***&#39; in part:
                                break # this is a bugged line
                            continue
                        elif mesh_char == &#39;part.&#39; or mesh_char == &#39;partcle&#39; or mesh_char == &#39;part&#39;:
                            part_grp_name = part.split(&#39;=&#39;)[1].strip()
                            if part_grp_name in meta.part_groups:
                                ip = (meta.part_groups).index(part_grp_name)
                            elif part_grp_name in meta.part_serial_groups:
                                ip = (meta.part_serial_groups).index(part_grp_name)
                            else:
                                raise ValueError(&#39;ERROR! Particle &#34;&#39;+part_grp_name+&#39;&#34; could not be identified.&#39;)
                        elif mesh_char == &#39;reg&#39;:
                            regnum = part.split(&#39;=&#39;)[1].strip()
                            ir = (meta.reg_num).index(regnum)
                        elif mesh_char == &#39;pont&#39; or mesh_char == &#39;rng&#39;: # [T-Point]
                            value_str = part.split(&#39;=&#39;)[1].strip()
                            ir = int(value_str) - 1
                        elif mesh_char == &#39;e1&#39;: # [T-Deposit2]
                            value_str = part.split(&#39;=&#39;)[1].strip()
                            ie = int(value_str) - 1
                        elif mesh_char == &#39;e2&#39;: # [T-Deposit2]
                            value_str = part.split(&#39;=&#39;)[1].strip()
                            ic = int(value_str) - 1
                        elif mesh_char in mesh_kind_chars or mesh_char in replace_eq_strs_dict:
                            if mesh_char in replace_eq_strs_dict:
                                mesh_char = replace_eq_strs_dict[mesh_char]
                            if &#39;i&#39;+mesh_char not in part: continue # only looking for indices for meshes, not values
                            imesh = mesh_kind_chars.index(mesh_char)
                            itdata_axis = mesh_kind_iax[imesh]
                            tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                            value_str = part.split(&#39;=&#39;)[1].strip()
                            if &#39; - &#39; in value_str:
                                vals = value_str.split(&#39;-&#39;)
                                if int(vals[0]) == int(vals[1]):
                                    value_str = vals[0]
                                else:  # samepage axis
                                    value_str = vals[0]  # this will be overwritten later
                            value = str(int(value_str)-1)
                            exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                        elif mesh_char in ignored_eq_strs:
                            continue
                        elif meta[&#39;tally_type&#39;]==&#39;[T-Cross]&#39;:
                            if meta[&#39;mesh&#39;] == &#39;xyz&#39; and mesh_char==&#39;z surf&#39;:
                                #imesh = mesh_kind_chars.index(&#39;z&#39;)
                                itdata_axis = 2 #mesh_kind_iax[imesh]
                                tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                                value_str = part.split(&#39;=&#39;)[1].strip()
                                value = str(int(value_str) - 1)
                                exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                            elif meta[&#39;mesh&#39;] == &#39;r-z&#39;:
                                if mesh_char==&#39;r surf&#39;:
                                    itdata_axis = 0  # mesh_kind_iax[imesh]
                                    #itdata_axis = 1  # set to iy
                                    ierr_mod = int(ierr_max/2)
                                    #ir, ic = -1, -1
                                    # imesh = mesh_kind_chars.index(&#39;y&#39;)
                                elif mesh_char == &#39;z surf&#39;:
                                    itdata_axis = 2  # mesh_kind_iax[imesh]
                                    #itdata_axis = 8  # set to ic
                                    ierr_mod = 0
                                    #iy, iz = -1, -1
                                    # imesh = mesh_kind_chars.index(&#39;c&#39;)
                                else:
                                    raise ValueError(&#39;ERROR! Unregistered potential index [&#39;+ part.split(&#39;=&#39;)[0].strip()+&#39;] found&#39;)
                                tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                                value_str = part.split(&#39;=&#39;)[1].strip()
                                if &#39; - &#39; in value_str:
                                    vals = value_str.split(&#39;-&#39;)
                                    if int(vals[0]) == int(vals[1]):
                                        value_str = vals[0]
                                    else: # samepage axis
                                        value_str = vals[0] # this will be overwritten later
                                value = str(int(value_str) - 1)
                                exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                            else:
                                raise ValueError(&#39;ERROR! Unregistered potential index [&#39;+ part.split(&#39;=&#39;)[0].strip()+ &#39;] found&#39;)
                        elif meta[&#39;tally_type&#39;] == &#39;[T-Heat]&#39;:
                            banked_uninterpreted_lines.append(line)
                        else:
                            raise ValueError(&#39;ERROR! Unregistered potential index [&#39;+part.split(&#39;=&#39;)[0].strip()+&#39;] found&#39;)


            # extract data from table
            # determine meaning of table rows
            row_ivar = tdata_ivar_strs[meta.axis_index_of_tally_array]
            # determine meaning of table columns
            hcols = parse_group_string(data_table[0][3:])
            nhcols = len(hcols)
            col_names_line_str = data_table[1][1:]
            icol_mod = 0 # account for weirdness in column presence/absence
            if &#39;r surface position&#39; in col_names_line_str:
                icol_mod = -1
                ierr_mod = int(ierr_max / 2)
            # Test for error in hcols
            num_data_vals_in_first_row = len(data_row_to_num_list(data_table[2])) # first row of data
            if num_data_vals_in_first_row != nhcols:
                if num_data_vals_in_first_row == (nhcols+1):
                    # most likely issue is hcol string is missing the &#34;n&#34; for the ?-lower column
                    nhcols = nhcols + 1
                    icol_mod = 1
            is_col_data = np.full(nhcols,False)
            data_col_indices = []
            is_col_err = np.full(nhcols,False)
            err_col_indices = []
            for iii in range(len(hcols)):
                if hcols[iii][0] == &#39;y&#39;:
                    is_col_data[iii+icol_mod] = True
                    is_col_err[iii+1+icol_mod] = True
                    data_col_indices.append(iii+icol_mod)
                    err_col_indices.append(iii+1+icol_mod)
            #print(is_col_data)
            #print(is_col_err)
            cols = data_table[1][1:].strip().split()
            ncols = len(cols)
            ndata_cols = np.sum(is_col_data) # number of data values per row
            # determine what variable this corresponds to, should be val of samepage
            # by default, this is usually particles (samepage = part by default)
            if meta.samepage == &#39;part&#39;:
                if meta.npart != ndata_cols:
                    raise ValueError(&#39;ERROR! samepage number of particle types (&#39;+str(meta.npart)+&#39;) not equal to number of data columns y(part) = &#39;+str(ndata_cols))
                data_ivar = &#39;ip&#39;
                data_ivar_indices = [j for j in range(ndata_cols)]
            else: # figure out what axis samepage is on
                if meta.samepage not in axes_1D:
                    raise ValueError(&#39;ERROR! samepage parameter (&#39;+str(meta.samepage)+&#39;) must be &#34;part&#34; or one of valid options for &#34;axis&#34; parameter&#39;)
                data_ivar = tdata_ivar_strs[axes_ital_1D[axes_1D.index(meta.samepage)]]
                if ndata_cols != eval(data_ivar+&#39;_max&#39;):
                    if meta[&#39;tally_type&#39;]==&#39;[T-Cross]&#39; and ndata_cols+1 == eval(data_ivar+&#39;_max&#39;):
                        # This is fine; for T-Cross, ndata cols can be one less than max length...
                        pass
                    elif meta[&#39;tally_type&#39;]==&#39;[T-Cross]&#39; and data_ivar == &#39;ir&#39; and ndata_cols+2 == eval(data_ivar+&#39;_max&#39;):
                        # This is fine; for T-Cross, ndata cols for radius can be two less than max length if rmin=0...
                        pass
                    else:
                        raise ValueError(&#39;ERROR! number of data columns (&#39;+str(ndata_cols)+&#39;) not equal to tally array dimension for &#39;+str(data_ivar)+&#39;, &#39;+str(eval(data_ivar+&#39;_max&#39;)))
                data_ivar_indices = [j for j in range(ndata_cols)]
            #print(cols)
            #print(ndata_cols)
            for li, line in enumerate(data_table[2:]):
                if len(line)==0: continue
                #print(line)
                rowi = li
                exec(row_ivar + &#39;=&#39; + str(rowi),globals())
                #print(row_ivar + &#39;=&#39; + str(rowi))
                values = data_row_to_num_list(line)
                dcoli = 0
                ecoli = 0
                for vi, value in enumerate(values):
                    if is_col_data[vi]:
                        exec(data_ivar + &#39;=&#39; + str(dcoli),globals())
                        #print(data_ivar + &#39;=&#39; + str(dcoli))
                        tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 0+ierr_mod] = value
                        dcoli += 1
                    if is_col_err[vi]:
                        exec(data_ivar + &#39;=&#39; + str(ecoli),globals())
                        #print(data_ivar + &#39;=&#39; + str(ecoli))
                        tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 1+ierr_mod] = value
                        ecoli += 1





    elif meta.axis_dimensions==2:
        for bi, block in enumerate(tally_blocks):
            hli, bli = 0 , 0
            data_keyword_found = False
            for li, line in enumerate(block):
                if meta[&#39;2D-type&#39;] in [1, 2, 3, 6, 7]:
                    if len(line) == 0: continue
                    if line[:3].lower() in [&#39;hc:&#39;, &#39;h2:&#39;, &#39;hd:&#39;, &#39;hc2&#39;]:  # start of data is here
                        hli = li
                    if line[:12] == &#39;#-----------&#39;:
                        fli = li
                        #if bi != len(tally_blocks) - 1:
                        break
                elif meta[&#39;2D-type&#39;] == 4:
                    if line == &#39;&#39; and hli != 0:
                        fli = li
                        #if bi != len(tally_blocks) - 1:
                        break
                    elif line == &#39;&#39;:  # start of data is here
                        hli = li
                elif meta[&#39;2D-type&#39;] == 5:
                    if &#39;data&#39; in line:
                        hli = li + 3
                    if line == &#39;&#39; and hli != 0 and li&gt;hli+2:
                        fli = li
                        #if bi != len(tally_blocks) - 1:
                        break

            data_header = block[:hli]
            data_table = block[hli:fli]
            data_footer = block[fli:]

            #print(data_header)
            #print(data_table)
            #print(data_footer)

            hash_line_already_evaluated = False

            if bi == len(tally_blocks) - 1:
                for li, line in enumerate(data_footer):
                    if line[:37] == &#39;# Information for Restart Calculation&#39;:
                        ffli = li
                        break
                data_footer = data_footer[:ffli]

            # try to get relevant indices data from header block
            for li, line in enumerate(data_header+data_footer): # +data_footer
                if len(line) == 0: continue
                #if &#39;reg =&#39; in line:
                #    regnum = line.strip().split(&#39;reg =&#39;)[1].strip()
                #    ir = (meta.reg_num).index(regnum)
                #    # print(ir)
                if &#39;=&#39; in line and (line[0] == &#34;&#39;&#34; or (line[0] == &#34;#&#34; and (&#39;no.&#39; in line or &#39;i&#39; in line or &#39;reg&#39; in line or &#39;part&#39; in line))):
                    if line[0] == &#34;#&#34;:
                        hash_line_already_evaluated = True
                    elif line[0] == &#34;&#39;&#34; and hash_line_already_evaluated:
                        if meta[&#39;samepage&#39;] == &#39;part&#39;:
                            continue # &#39;-starting lines tend to have more problematic formatting, best skipped if possible
                        elif meta[&#39;npart&#39;] == 1:
                            continue # can still skip if only one particle group tallied
                        else:
                            pass # but this needs to be parsed if not using samepage = part and npart &gt; 1
                    parts = split_str_of_equalities(line)
                    for part in parts:
                        mesh_char = part.split(&#39;=&#39;)[0].strip().replace(&#39;i&#39;, &#39;&#39;)
                        #print(mesh_char)
                        if mesh_char == &#39;no.&#39;:
                            continue
                        elif mesh_char == &#39;part.&#39; or mesh_char == &#39;partcle&#39;:
                            part_grp_name = part.split(&#39;=&#39;)[1].strip()
                            try:
                                ip = (meta.part_groups).index(part_grp_name)
                            except:
                                ip = (meta.part_serial_groups).index(part_grp_name)
                        elif mesh_char == &#39;reg&#39;: # and meta[&#39;samepage&#39;] != &#39;reg&#39;:
                            regnum = part.split(&#39;=&#39;)[1].strip()
                            ir = (meta.reg_num).index(regnum)
                        elif mesh_char == &#39;e1&#39;: # [T-Deposit2]
                            value_str = part.split(&#39;=&#39;)[1].strip()
                            ie = int(value_str) - 1
                        elif mesh_char == &#39;e2&#39;: # [T-Deposit2]
                            value_str = part.split(&#39;=&#39;)[1].strip()
                            ic = int(value_str) - 1
                        elif mesh_char in mesh_kind_chars or mesh_char in replace_eq_strs_dict:
                            if mesh_char in replace_eq_strs_dict:
                                mesh_char = replace_eq_strs_dict[mesh_char]
                            if &#39;i&#39;+mesh_char not in part: continue # only looking for indices for meshes, not values
                            imesh = mesh_kind_chars.index(mesh_char)
                            itdata_axis = mesh_kind_iax[imesh]
                            tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                            value = str(int(part.split(&#39;=&#39;)[1].strip()) - 1)
                            if mesh_char == &#39;l&#39; and meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39; and meta[&#39;axis&#39;] == &#39;chart&#39;:
                                i_metastable = int(value) + 1
                                il = 0
                            else:
                                exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                        elif mesh_char in ignored_eq_strs:
                            continue
                        elif meta[&#39;tally_type&#39;]==&#39;[T-Cross]&#39;:
                            ierr_mod = 0
                            if meta[&#39;mesh&#39;] == &#39;xyz&#39; and mesh_char==&#39;z surf&#39;:
                                #imesh = mesh_kind_chars.index(&#39;z&#39;)
                                itdata_axis = 2 #mesh_kind_iax[imesh]
                                tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                                value = str(int(part.split(&#39;=&#39;)[1].strip()) - 1)
                                exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                            elif meta[&#39;mesh&#39;] == &#39;r-z&#39;:
                                if mesh_char==&#39;r surf&#39;:
                                    # imesh = mesh_kind_chars.index(&#39;y&#39;)
                                    itdata_axis = 0 #1  # mesh_kind_iax[imesh]
                                    tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                                    value = str(int(part.split(&#39;=&#39;)[1].strip()) - 1)
                                    exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                                    #ir, ic = -1, -1
                                    ierr_mod = int(ierr_max / 2)
                                elif mesh_char==&#39;z surf&#39;:
                                    # imesh = mesh_kind_chars.index(&#39;c&#39;)
                                    itdata_axis = 2 #8  # mesh_kind_iax[imesh]
                                    tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                                    value = str(int(part.split(&#39;=&#39;)[1].strip()) - 1)
                                    exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                                    iy, iz = -1, -1
                                    ierr_mod = 0
                                else:
                                    raise ValueError(&#39;ERROR! Unregistered potential index [&#39;+ part.split(&#39;=&#39;)[0].strip()+&#39;] found&#39;)
                            else:
                                raise ValueError(&#39;ERROR! Unregistered potential index [&#39;+ part.split(&#39;=&#39;)[0].strip()+ &#39;] found&#39;)
                        else:
                            raise ValueError(&#39;ERROR! Unregistered potential index [&#39;+part.split(&#39;=&#39;)[0].strip()+&#39;] found&#39;)


            # Now read data_table, with formatting dependent on 2D-type, and can be inferred from last line of header
            axis1_ivar = meta.axis_index_of_tally_array[0]
            axis2_ivar = meta.axis_index_of_tally_array[1]
            if meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39; and meta[&#39;axis&#39;] == &#39;chart&#39;: # this setting does not respect 2D-type and uses its own formatting
                data_write_format_str = data_table[0][3:]
                Z_y_segment = data_write_format_str.split(&#39;;&#39;)[0]
                N_x_segment = data_write_format_str.split(&#39;;&#39;)[1]
                Z_y_vals = Z_y_segment.replace(&#39;=&#39;,&#39;&#39;).replace(&#39;to&#39;,&#39;&#39;).replace(&#39;by&#39;,&#39;&#39;).replace(&#39;y&#39;,&#39;&#39;).strip().split()
                N_x_vals = N_x_segment.replace(&#39;=&#39;,&#39;&#39;).replace(&#39;to&#39;,&#39;&#39;).replace(&#39;by&#39;,&#39;&#39;).replace(&#39;x&#39;,&#39;&#39;).strip().split()
                Z_y_max, Z_y_min, Z_y_increment = int(Z_y_vals[0]), int(Z_y_vals[1]), int(Z_y_vals[2])
                N_x_max, N_x_min, N_x_increment = int(N_x_vals[1]), int(N_x_vals[0]), int(N_x_vals[2])
                #print(Z_y_max, Z_y_min, Z_y_increment, N_x_max, N_x_min, N_x_increment )
            elif meta[&#39;2D-type&#39;] != 4:
                data_write_format_str = data_header[-2][1:]
                if &#39;data&#39; not in data_write_format_str:
                    for line in data_header[::-1]:
                        if &#39;data&#39; in line:
                            data_write_format_str = line[1:]
                            break
                #print(data_write_format_str)
                if &#39;data&#39; not in data_write_format_str:
                    # failed to find a &#34;data&#34; line telling us how the values are ordered
                    # have to make guesses about output ordering...
                    # axis variable should give us a hint
                    axis = meta[&#39;axis&#39;]
                    if &#39;eng&#39; in axis or &#39;e1&#39; in axis or &#39;e2&#39; in axis:
                        if axis == &#39;e12&#39; or axis == &#39;e21&#39;:
                            ax1_ivar = &#39;ie&#39;
                            ax2_ivar = &#39;ie&#39;
                        else: # energy vs time
                            if axis[0] == &#39;t&#39;:
                                ax1_ivar = &#39;it&#39;
                                ax2_ivar = &#39;ie&#39;
                            else:
                                ax1_ivar = &#39;ie&#39;
                                ax2_ivar = &#39;it&#39;
                    else:
                        if &#39;axis1_label&#39; in meta and meta[&#39;axis1_label&#39;][0] in axis:
                            # we know horizontal axis variable
                            ax1_ivar = &#39;i&#39; + meta[&#39;axis1_label&#39;][0]
                            ax2_ivar = &#39;i&#39; + axis.replace(meta[&#39;axis1_label&#39;][0],&#39;&#39;)
                        else:
                            ax1_ivar = &#39;i&#39; + meta[&#39;axis&#39;][1]
                            ax2_ivar = &#39;i&#39; + meta[&#39;axis&#39;][0]
                else:
                    # We can, with confidence, determine output value ordering :)
                    for dsi in data_write_format_str.split():
                        if &#39;data&#39; in dsi:
                            data_index_str = dsi
                            ax_vars = data_index_str.replace(&#39;data&#39;,&#39;&#39;).replace(&#39;(&#39;,&#39;&#39;).replace(&#39;)&#39;,&#39;&#39;)
                            #print(data_index_str)
                            #print(ax_vars)
                            ax1_ivar, ax2_ivar = ax_vars.split(&#39;,&#39;)[:2]
                            ax1_ivar = &#39;i&#39; + ax1_ivar
                            ax2_ivar = &#39;i&#39; + ax2_ivar
                    #print(data_write_format_str)
            else:  # 2D-type = 4
                cols = data_table[1][1:].split()
                ax1_ivar, ax2_ivar = cols[0], cols[1]
                ax1_ivar = &#39;i&#39; + ax1_ivar
                ax2_ivar = &#39;i&#39; + ax2_ivar

            # manually fix [T-Deposit2] axes
            if meta[&#39;tally_type&#39;] == &#39;[T-Deposit2]&#39;:
                if meta[&#39;axis&#39;] == &#39;e12&#39;:
                    ax1_ivar, ax2_ivar = &#39;ie&#39;, &#39;ic&#39;
                elif meta[&#39;axis&#39;] == &#39;e21&#39;:
                    ax1_ivar, ax2_ivar = &#39;ic&#39;, &#39;ie&#39;
                elif meta[&#39;axis&#39;] == &#39;t-e1&#39;:
                    ax1_ivar, ax2_ivar = &#39;it&#39;, &#39;ie&#39;
                elif meta[&#39;axis&#39;] == &#39;t-e2&#39;:
                    ax1_ivar, ax2_ivar = &#39;it&#39;, &#39;ic&#39;
                elif meta[&#39;axis&#39;] == &#39;e1-t&#39;:
                    ax1_ivar, ax2_ivar = &#39;ie&#39;, &#39;it&#39;
                elif meta[&#39;axis&#39;] == &#39;e2-t&#39;:
                    ax1_ivar, ax2_ivar = &#39;ic&#39;, &#39;it&#39;

            if meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39; and meta[&#39;axis&#39;] == &#39;chart&#39;:
                remaining_ndata_to_read = (Z_y_max - Z_y_min + 1) * (N_x_max - N_x_min + 1)
            else:
                # check if this is one of the backwards instances
                expected_ax1_ivar = tdata_ivar_strs[axis1_ivar]
                expected_ax2_ivar = tdata_ivar_strs[axis2_ivar]
                if meta.mesh==&#39;xyz&#39;:
                    if expected_ax1_ivar == &#39;ir&#39;: expected_ax1_ivar = &#39;ix&#39;
                    if expected_ax2_ivar == &#39;ir&#39;: expected_ax1_ivar = &#39;ix&#39;
                if ax1_ivar==expected_ax1_ivar and ax2_ivar==expected_ax2_ivar:
                    pass # all is correct as is
                elif ax2_ivar == expected_ax1_ivar and ax1_ivar == expected_ax2_ivar:
                    axis1_ivar_temp = axis1_ivar
                    axis1_ivar = axis2_ivar
                    axis2_ivar = axis1_ivar_temp
                    #axis1_ivar = tdata_ivar_strs.index(ax1_ivar)
                    #axis2_ivar = tdata_ivar_strs.index(ax2_ivar)
                    #print(&#39;backwards!&#39;)
                else:
                    raise ValueError(&#39;ERROR! Unknown axes (&#39;+ax1_ivar+&#39; &#39;+ax2_ivar +
                                     &#39;) encountered that did not match expected axes (&#39; +
                                     tdata_ivar_strs[meta.axis_index_of_tally_array[0]]+&#39; &#39; +
                                     tdata_ivar_strs[meta.axis_index_of_tally_array[1]]+&#39;)&#39;)

                axis1_ivar_str = tdata_ivar_strs[axis1_ivar]
                axis2_ivar_str = tdata_ivar_strs[axis2_ivar]
                axis1_size = np.shape(tdata)[axis1_ivar]
                axis2_size = np.shape(tdata)[axis2_ivar]
                ndata_to_read = axis1_size*axis2_size
                #print(axis1_ivar_str,axis2_ivar_str)
                #print(axis1_size,axis2_size,ndata_to_read)
                remaining_ndata_to_read = ndata_to_read
                iax1 = 0
                iax2 = axis2_size - 1

            if meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39; and meta[&#39;axis&#39;] == &#39;chart&#39;:
                #Z_y_max, Z_y_min, Z_y_increment # big, 1, -1
                #N_x_max, N_x_min, N_x_increment # big, 1, 1
                current_Z = Z_y_max
                current_N = N_x_min - N_x_increment
                ic = 0
                for line in data_table[1:]:
                    values = data_row_to_num_list(line)
                    for value in values:
                        remaining_ndata_to_read += -1
                        current_N += N_x_increment
                        if current_N &gt; N_x_max:
                            current_N = N_x_min
                            current_Z += Z_y_increment
                        #print(&#39;Z=&#39;,current_Z,&#39;, N=&#39;,current_N)

                        if value != 0:
                            ZZZAAAM = 10000*current_Z + 10*(current_Z+current_N) + i_metastable
                            if ZZZAAAM not in ZZZAAAM_list:
                                ic = len(ZZZAAAM_list)
                                ZZZAAAM_list.append(ZZZAAAM)
                            else:
                                ic = ZZZAAAM_list.index(ZZZAAAM)
                            #print(ic, i_metastable)
                            #print(ic,value)
                            tdata[ir, iy, iz, ie, it, ia, il, ip, ic, ierr + ierr_mod] = value

                        if remaining_ndata_to_read &lt;= 0:
                            break







            elif meta[&#39;2D-type&#39;] in [1,2,3,6,7]:
                for line in data_table[1:]:
                    values = data_row_to_num_list(line)
                    #print(line)
                    for value in values:
                        exec(axis1_ivar_str + &#39; = &#39; + str(iax1), globals())
                        exec(axis2_ivar_str + &#39; = &#39; + str(iax2), globals())
                        #print(ir, iy, iz, ie, it, ia, il, ip, ic, ierr, &#39;\t&#39;, value)
                        tdata[ir, iy, iz, ie, it, ia, il, ip, ic, ierr + ierr_mod] = value
                        remaining_ndata_to_read += -1
                        #print(iax1, iax2)
                        iax1 += 1
                        if iax1 == axis1_size:
                            iax1 = 0
                            iax2 += -1
                    if remaining_ndata_to_read &lt;= 0:
                        break

            elif meta[&#39;2D-type&#39;] == 4:
                iax2 = 0
                for line in data_table[2:]:
                    values = data_row_to_num_list(line)
                    value = values[2]
                    value_err = values[3]
                    exec(axis1_ivar_str + &#39; = &#39; + str(iax1), globals())
                    exec(axis2_ivar_str + &#39; = &#39; + str(iax2), globals())
                    tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 0 + ierr_mod] = value
                    tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 1 + ierr_mod] = value_err
                    # print(ir, iy, iz, ie, it, ia, il, ip, ic, ierr,&#39;\t&#39;,value)
                    remaining_ndata_to_read += -1
                    # print(iax1, iax2)
                    iax1 += 1
                    if iax1 == axis1_size:
                        iax1 = 0
                        iax2 += 1

                    if remaining_ndata_to_read &lt;= 0:
                        break

            elif meta[&#39;2D-type&#39;] == 5:
                for line in data_table[2:]:
                    values = data_row_to_num_list(line)
                    #print(line)
                    for vi, value in enumerate(values):
                        if vi==0: continue # header column
                        exec(axis1_ivar_str + &#39; = &#39; + str(iax1), globals())
                        exec(axis2_ivar_str + &#39; = &#39; + str(iax2), globals())
                        #print(ir, iy, iz, ie, it, ia, il, ip, ic, ierr, &#39;\t&#39;, value)
                        tdata[ir, iy, iz, ie, it, ia, il, ip, ic, ierr + ierr_mod] = value
                        remaining_ndata_to_read += -1
                        # print(iax1, iax2)
                        iax1 += 1
                        if iax1 == axis1_size:
                            iax1 = 0
                            iax2 += -1
                    if remaining_ndata_to_read &lt;= 0:
                        break

            else:
                raise ValueError(&#39;ERROR! unsupported 2D-type of &#39;+str(meta[&#39;2D-type&#39;])+&#39; provided; legal values are [1,2,3,4,5,6,7]&#39;)

    else:
        raise ValueError(str(meta.axis_dimensions)+&#39;axis dimensions is unknown, ERROR!&#39;)

    if len(banked_uninterpreted_lines) != 0:
        print(&#39;The following potentially useful output lines were found but not stored anywhere:&#39;)
        for line in banked_uninterpreted_lines:
            print(&#39;\t&#39;+line)

    return_updated_metadata_too = False
    if meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39;:
        return_updated_metadata_too = True
        if meta[&#39;axis&#39;] == &#39;chart&#39;:
            meta[&#39;nuclide_ZZZAAAM_list&#39;] = ZZZAAAM_list
            meta[&#39;nuclide_isomer_list&#39;] = [ZZZAAAM_to_nuclide_plain_str(i) for i in ZZZAAAM_list]
            nc_max = len(ZZZAAAM_list) #+ 1
            meta[&#39;nc&#39;] = nc_max
            tdata = tdata[:,:,:,:,:,:,:,:,:nc_max,:]
        elif meta[&#39;axis&#39;] == &#39;charge&#39; or meta[&#39;axis&#39;] == &#39;mass&#39;:
            ic_axis_tdata_sum = tdata.sum(axis=(0,1,2,3,4,5,6,7,9))
            nc_max = np.max(np.nonzero(ic_axis_tdata_sum)) + 1
            meta[&#39;nc&#39;] = nc_max
            tdata = tdata[:, :, :, :, :, :, :, :, :nc_max, :]

    if return_updated_metadata_too:
        return tdata, meta
    else:
        return tdata

def build_tally_Pandas_dataframe(tdata,meta):
    &#39;&#39;&#39;
    Description:
        Calculates the absolute uncertainty for every value in the PHITS tally data array

    Dependencies:
        - `import pandas as pd`

    Inputs:
        - `tdata` = 10-dimensional NumPy array containing read/extracted tally results
        - `meta` = Munch object / dictionary containing tally metadata

    Outputs:
        - `tally_df` = Pandas dataframe containing the entire contents of the `tdata` array;
                note that tally_df.attrs returns values which are the same for all rows

    &#39;&#39;&#39;
    import pandas as pd
    ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max, ierr_max = np.shape(tdata)
    num_df_rows = ir_max * iy_max * iz_max * ie_max * it_max * ia_max * il_max * ip_max * ic_max
    # determine what columns to include, based on what info was specified vs left at default values
    col_names_list = []

    in_irregular_TCross_rz_mesh = False
    in_irregular_TCross_xyz_mesh = False
    ierr_mod = 0
    if meta[&#39;tally_type&#39;] == &#39;[T-Cross]&#39; and (meta.mesh == &#39;xyz&#39; or meta.mesh == &#39;r-z&#39;):
        if &#39;enclos&#39; in meta and meta[&#39;enclos&#39;] == 1:
            pass
        else:
            if meta.mesh == &#39;r-z&#39;:
                in_irregular_TCross_rz_mesh = True
                min_r_is_zero = False
                if meta[&#39;r-mesh_bin_edges&#39;][0]==0:
                    min_r_is_zero = True
                ierr_mod = int(ierr_max / 2)
            else:
                in_irregular_TCross_xyz_mesh = True


    # region columns
    if meta.mesh == &#39;reg&#39;:
        reg_cols = [&#39;ir&#39;,&#39;reg&#39;,&#39;reg#&#39;] # use meta.reg_groups and meta.reg_num
    elif meta.mesh == &#39;xyz&#39;:
        if in_irregular_TCross_xyz_mesh:
            reg_cols = [&#39;ix&#39;, &#39;iy&#39;, &#39;iz&#39;, &#39;x_mid&#39;, &#39;y_mid&#39;, &#39;z_surf&#39;]
        else:
            reg_cols = [&#39;ix&#39;,&#39;iy&#39;,&#39;iz&#39;,&#39;x_mid&#39;,&#39;y_mid&#39;,&#39;z_mid&#39;]
    elif meta.mesh == &#39;r-z&#39;:
        if in_irregular_TCross_rz_mesh:
            #reg_cols = [&#39;ir&#39;, &#39;ic&#39;, &#39;r_mid&#39;, &#39;z_surf&#39;, &#39;iy&#39;, &#39;iz&#39;, &#39;r_surf&#39;, &#39;z_mid&#39;]
            reg_cols = [&#39;ir&#39;, &#39;iz&#39;, &#39;r_mid&#39;, &#39;z_surf&#39;, &#39;r_surf&#39;, &#39;z_mid&#39;]
        else:
            reg_cols = [&#39;ir&#39;,&#39;iz&#39;,&#39;r_mid&#39;,&#39;z_mid&#39;]
    elif meta.mesh == &#39;tet&#39;:
        reg_cols = [&#39;ir&#39;,&#39;tet&#39;] #,&#39;tet#&#39;]
    elif meta.mesh == &#39;point&#39;:
        reg_cols = [&#39;ir&#39;,&#39;point#&#39;]
    elif meta.mesh == &#39;ring&#39;:
        reg_cols = [&#39;ir&#39;,&#39;ring#&#39;]
    col_names_list += reg_cols



    # Determine what other columns will be present
    ecols, tcols, acols, lcols, pcols, ccols = False, False, False, False, False, False
    single_specified_bin_axes = [] # log axes which are provided by user but only contain 1 bin
    single_bin_ranges_or_values = []
    if meta.ne != None:
        if meta.ne==1:
            single_specified_bin_axes.append(&#39;e&#39;)
            single_bin_ranges_or_values.append([&#39;Energy&#39;,meta[&#39;e-mesh_bin_edges&#39;]])
        else:
            ecols = True
            ecol_names_list = [&#39;ie&#39;,&#39;e_mid&#39;]
            col_names_list += ecol_names_list
    else:
        single_bin_ranges_or_values.append([&#39;Energy&#39;,&#39;default/all&#39;])
    if meta.nt != None:
        if meta.nt==1:
            single_specified_bin_axes.append(&#39;t&#39;)
            single_bin_ranges_or_values.append([&#39;Time&#39;,meta[&#39;t-mesh_bin_edges&#39;]])
        else:
            tcols = True
            tcol_names_list = [&#39;it&#39;, &#39;t_mid&#39;]
            col_names_list += tcol_names_list
    else:
        single_bin_ranges_or_values.append([&#39;Time&#39;,&#39;default/all&#39;])
    if meta.na != None:
        if meta.na==1:
            single_specified_bin_axes.append(&#39;a&#39;)
            single_bin_ranges_or_values.append([&#39;Angle&#39;,meta[&#39;a-mesh_bin_edges&#39;]])
        else:
            acols = True
            acol_names_list = [&#39;ia&#39;, &#39;a_mid&#39;]
            col_names_list += acol_names_list
    else:
        single_bin_ranges_or_values.append([&#39;Angle&#39;,&#39;default/all&#39;])
    if meta.nl != None:
        if meta.nl==1:
            single_specified_bin_axes.append(&#39;l&#39;)
            single_bin_ranges_or_values.append([&#39;LET&#39;,meta[&#39;l-mesh_bin_edges&#39;]])
        else:
            lcols = True
            lcol_names_list = [&#39;il&#39;, &#39;LET_mid&#39;]
            col_names_list += lcol_names_list
    else:
        single_bin_ranges_or_values.append([&#39;LET&#39;,&#39;default/all&#39;])

    if meta.nc != None:
        if meta.nc == 1:
            pass
        else:
            ccols = True
            if meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39;:
                if meta[&#39;axis&#39;] == &#39;chart&#39;:
                    ccol_names_list = [&#39;ic&#39;, &#39;nuclide&#39;, &#39;ZZZAAAM&#39;]
                    col_names_list += ccol_names_list
                elif meta[&#39;axis&#39;] == &#39;charge&#39;:
                    ccol_names_list = [&#39;ic/Z/charge&#39;]
                    col_names_list += ccol_names_list
                elif meta[&#39;axis&#39;] == &#39;mass&#39;:
                    ccol_names_list = [&#39;ic/A/mass&#39;]
                    col_names_list += ccol_names_list
            elif meta[&#39;tally_type&#39;] == &#39;[T-Deposit2]&#39;:
                pass

    if meta.npart != None: # and meta.part_groups[0]==&#39;all&#39;:
        if meta.npart==1:
            single_specified_bin_axes.append(&#39;p&#39;)
            single_bin_ranges_or_values.append([&#39;Particle&#39;,meta.part_groups[0]])
        else:
            pcols = True
            pcol_names_list = [&#39;ip&#39;, &#39;particle&#39;, &#39;kf-code&#39;]
            col_names_list += pcol_names_list
    else:
        single_bin_ranges_or_values.append([&#39;Particle&#39;,&#39;default/all&#39;])

    # HANDLE SPECIAL COLUMNS HERE (ic / ccols)


    # value columns come last
    val_names_list = [&#39;value&#39;, &#39;rel.err.&#39;]
    if ierr_max == 3 or ierr_max == 6: val_names_list += [&#39;abs.err.&#39;]
    if ierr_max &gt;= 4: val_names_list += [&#39;value2&#39;, &#39;rel.err.2&#39;]
    if ierr_max == 6: val_names_list += [&#39;abs.err.2&#39;]
    col_names_list += val_names_list

    # Initialize dictionary
    df_dict = {}
    for col in col_names_list:
        df_dict[col] = []


    # Populate dictionary
    for ir in range(ir_max):
        for iy in range(iy_max):
            for iz in range(iz_max):
                for ie in range(ie_max):
                    for it in range(it_max):
                        for ia in range(ia_max):
                            for il in range(il_max):
                                for ip in range(ip_max):
                                    for ic in range(ic_max):
                                        # Region columns
                                        if in_irregular_TCross_rz_mesh:
                                            if (ir == ir_max - 1 and iz == iz_max - 1): # only index that should be empty
                                                continue
                                            # [&#39;ir&#39;, &#39;iz&#39;, &#39;r_mid&#39;, &#39;z_surf&#39;, &#39;r_surf&#39;, &#39;z_mid&#39;]
                                            df_dict[reg_cols[0]].append(ir)
                                            df_dict[reg_cols[1]].append(iz)
                                            if ir==ir_max-1:
                                                df_dict[reg_cols[2]].append(None)
                                            else:
                                                df_dict[reg_cols[2]].append(meta[&#39;r-mesh_bin_mids&#39;][ir])
                                            df_dict[reg_cols[3]].append(meta[&#39;z-mesh_bin_edges&#39;][iz])
                                            df_dict[reg_cols[4]].append(meta[&#39;r-mesh_bin_edges&#39;][ir])
                                            if iz == iz_max - 1:
                                                df_dict[reg_cols[5]].append(None)
                                            else:
                                                df_dict[reg_cols[5]].append(meta[&#39;z-mesh_bin_mids&#39;][iz])
                                            # OLD IMPLEMENTATION IS BELOW:
                                            &#39;&#39;&#39;
                                            # skip unwritten indices
                                            # reg_cols = [&#39;ir&#39;, &#39;ic&#39;, &#39;r_mid&#39;, &#39;z_surf&#39;, &#39;iy&#39;, &#39;iz&#39;, &#39;r_surf&#39;, &#39;z_mid&#39;]
                                            if (ir==ir_max-1 and ic==ic_max-1):
                                                if (iy == iy_max - 1 or iz == iz_max - 1): continue
                                                if min_r_is_zero and iy==0: continue # surface vals not written for r=0.0
                                                df_dict[reg_cols[0]].append(None)
                                                df_dict[reg_cols[1]].append(None)
                                                df_dict[reg_cols[2]].append(None)
                                                df_dict[reg_cols[3]].append(None)
                                                df_dict[reg_cols[4]].append(iy)
                                                df_dict[reg_cols[5]].append(iz)
                                                df_dict[reg_cols[6]].append(meta[&#39;r-mesh_bin_edges&#39;][iy])
                                                df_dict[reg_cols[7]].append(meta[&#39;z-mesh_bin_mids&#39;][iz])
                                            elif (iy==iy_max-1 and iz==iz_max-1):
                                                if (ir == ir_max - 1 or ic == ic_max - 1): continue
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(ic)
                                                df_dict[reg_cols[2]].append(meta[&#39;r-mesh_bin_mids&#39;][ir])
                                                df_dict[reg_cols[3]].append(meta[&#39;z-mesh_bin_edges&#39;][ic])
                                                df_dict[reg_cols[4]].append(None)
                                                df_dict[reg_cols[5]].append(None)
                                                df_dict[reg_cols[6]].append(None)
                                                df_dict[reg_cols[7]].append(None)
                                            else: # all other indices should not have any content written into them
                                                continue
                                            &#39;&#39;&#39;
                                        else:
                                            if meta.mesh == &#39;reg&#39;: #reg_cols = [&#39;ir&#39;,&#39;reg&#39;, &#39;reg#&#39;]  # use meta.reg_groups and meta.reg_num
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(meta.reg_groups[ir])
                                                df_dict[reg_cols[2]].append(meta.reg_num[ir])
                                            elif meta.mesh == &#39;xyz&#39;:
                                                #reg_cols = [&#39;ix&#39;, &#39;iy&#39;, &#39;iz&#39;, &#39;xmid&#39;, &#39;ymid&#39;, &#39;zmid&#39;]
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(iy)
                                                df_dict[reg_cols[2]].append(iz)
                                                df_dict[reg_cols[3]].append(meta[&#39;x-mesh_bin_mids&#39;][ir])
                                                df_dict[reg_cols[4]].append(meta[&#39;y-mesh_bin_mids&#39;][iy])
                                                if in_irregular_TCross_xyz_mesh:
                                                    df_dict[reg_cols[5]].append(meta[&#39;z-mesh_bin_edges&#39;][iz])
                                                else:
                                                    df_dict[reg_cols[5]].append(meta[&#39;z-mesh_bin_mids&#39;][iz])
                                            elif meta.mesh == &#39;r-z&#39;:
                                                #reg_cols = [&#39;ir&#39;, &#39;iz&#39;, &#39;rmid&#39;, &#39;zmid&#39;]
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(iz)
                                                df_dict[reg_cols[2]].append(meta[&#39;r-mesh_bin_mids&#39;][ir])
                                                df_dict[reg_cols[3]].append(meta[&#39;z-mesh_bin_mids&#39;][iz])
                                            elif meta.mesh == &#39;tet&#39;:
                                                #reg_cols = [&#39;ir&#39;,&#39;tet&#39;]
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(meta.tet_num[ir])
                                            elif meta.mesh == &#39;point&#39;:
                                                #reg_cols = [&#39;ir&#39;,&#39;point#&#39;]
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(str(ir+1))
                                            elif meta.mesh == &#39;ring&#39;:
                                                #reg_cols = [&#39;ir&#39;,&#39;ring#&#39;]
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(str(ir+1))

                                        #ecols, tcols, acols, lcols, pcols, ccols
                                        if pcols: # pcol_names_list = [&#39;ip&#39;, &#39;particle&#39;, &#39;kf-code&#39;]
                                            df_dict[pcol_names_list[0]].append(ip)
                                            df_dict[pcol_names_list[1]].append(meta.part_groups[ip])
                                            df_dict[pcol_names_list[2]].append(meta.kf_groups[ip])

                                        if ecols: # ecol_names_list = [&#39;ie&#39;,&#39;e_mid&#39;]
                                            df_dict[ecol_names_list[0]].append(ie)
                                            df_dict[ecol_names_list[1]].append(meta[&#39;e-mesh_bin_mids&#39;][ie])
                                        if tcols: # tcol_names_list = [&#39;it&#39;,&#39;t_mid&#39;]
                                            df_dict[tcol_names_list[0]].append(it)
                                            df_dict[tcol_names_list[1]].append(meta[&#39;t-mesh_bin_mids&#39;][it])
                                        if acols: # acol_names_list = [&#39;ia&#39;,&#39;a_mid&#39;]
                                            df_dict[acol_names_list[0]].append(ia)
                                            df_dict[acol_names_list[1]].append(meta[&#39;a-mesh_bin_mids&#39;][ia])
                                        if lcols: # lcol_names_list = [&#39;il&#39;,&#39;LET_mid&#39;]
                                            df_dict[lcol_names_list[0]].append(il)
                                            df_dict[lcol_names_list[1]].append(meta[&#39;l-mesh_bin_mids&#39;][il])

                                        if ccols:
                                            if meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39;:
                                                if meta[&#39;axis&#39;] == &#39;chart&#39;:
                                                    #ccol_names_list = [&#39;ic&#39;, &#39;nuclide&#39;, &#39;ZZZAAAM&#39;]
                                                    df_dict[ccol_names_list[0]].append(ic)
                                                    df_dict[ccol_names_list[1]].append(meta[&#39;nuclide_isomer_list&#39;][ic])
                                                    df_dict[ccol_names_list[2]].append(meta[&#39;nuclide_ZZZAAAM_list&#39;][ic])
                                                elif meta[&#39;axis&#39;] == &#39;charge&#39;:
                                                    #ccol_names_list = [&#39;ic/Z/charge&#39;]
                                                    df_dict[ccol_names_list[0]].append(ic)
                                                elif meta[&#39;axis&#39;] == &#39;mass&#39;:
                                                    #ccol_names_list = [&#39;ic/A/mass&#39;]
                                                    df_dict[ccol_names_list[0]].append(ic)

                                        # Value columns
                                        #val_names_list = [&#39;value&#39;, &#39;rel.err.&#39;,&#39;abs.err.&#39;]
                                        df_dict[val_names_list[0]].append(tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 0])
                                        df_dict[val_names_list[1]].append(tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 1])
                                        if ierr_max == 3 or ierr_max == 6:
                                            df_dict[val_names_list[2]].append(tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 2])
                                        if in_irregular_TCross_rz_mesh:
                                            df_dict[val_names_list[0+ierr_mod]].append(tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 0+ierr_mod])
                                            df_dict[val_names_list[1+ierr_mod]].append(tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 1+ierr_mod])
                                            if ierr_max == 6:
                                                df_dict[val_names_list[2+ierr_mod]].append(tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 2 + ierr_mod])


    # Convert dictionary to Pandas dataframe
    #for key in df_dict.keys():
    #    print(key,len(df_dict[key]))
    #sys.exit()
    tally_df = pd.DataFrame(df_dict)

    # store information on settings provided by user that are different from default but same for all rows
    if len(single_bin_ranges_or_values) &gt; 0:
        for i in single_bin_ranges_or_values:
            col, val = i
            tally_df.attrs[col] = val

    #with pd.option_context(&#39;display.max_rows&#39;, None, &#39;display.max_columns&#39;, None): print(tally_df)
    if in_debug_mode:
        #print(tally_df.to_string())
        print(tally_df.attrs)
    return tally_df

def search_for_dump_parameters(output_file):
    &#39;&#39;&#39;
    Description:
        Try to determine the dump settings used for a dump file by searching for the same file without &#34;_dmp&#34; and parsing
        its header for the &#34;dump = &#34; line and subsequent line specifying the column ordering.

    Dependencies:
        - `from pathlib import Path`

    Inputs:
        - `output_file` = a file/filepath (string or Path object) to be judged

    Outputs:
        - `dump_data_number` = value following &#34;dump = &#34; in the PHITS tally (integer from -20 to 20, excluding 0) (D=`None`)
        - `dump_data_sequence` = list of integers specifying the order and meaning of the dump file columns (D=`None`)
    &#39;&#39;&#39;
    dump_data_number, dump_data_sequence = None, None
    output_file = Path(output_file)
    origin_tally_file = Path(output_file.parent, output_file.stem.replace(&#39;_dmp&#39;,&#39;&#39;) + output_file.suffix)
    PHITS_file_type = determine_PHITS_output_file_type(origin_tally_file)
    if PHITS_file_type[&#39;file_does_not_exist&#39;]:
        print(&#34;Could not find this dump file&#39;s companion original standard tally output file&#34;,origin_tally_file)
        return dump_data_number, dump_data_sequence
    elif not PHITS_file_type[&#39;is_standard_tally_output&#39;]:
        print(&#34;Found dump file&#39;s suspected companion original standard tally output file, but it does not seem to actually be formatted as a standard tally output file&#34;,origin_tally_file)
        return dump_data_number, dump_data_sequence
    tally_header, tally_content = split_into_header_and_content(origin_tally_file)
    for li, line in enumerate(tally_header):
        if &#34;dump =&#34; in line:
            if line[0] == &#39;#&#39;:  # commented line
                key, value = extract_data_from_header_line(line[1:])
            else:
                key, value = extract_data_from_header_line(line)
            dump_data_number = int(value)
            dump_data_sequence_str_list = tally_header[li+1].strip().split()
            dump_data_sequence = [int(i) for i in dump_data_sequence_str_list]
            break
    if dump_data_number == None and dump_data_sequence == None:
        print(&#39;Was unable to locate dump specification information in tally output file&#39;,origin_tally_file)
    return dump_data_number, dump_data_sequence

def determine_PHITS_output_file_type(output_file):
    &#39;&#39;&#39;
    Description:
        Determine what kind of PHITS file is being hanlded (tally standard output, binary tally dump, ASCII tally dump, etc.)

    Dependencies:
        - `from pathlib import Path`

    Inputs:
        - `output_file` = a file/filepath (string or Path object) to be judged

    Outputs:
        - `PHITS_file_type` = a dictionary of Booleans detailing what kind of file `output_file` is (and isn&#39;t) with
            the following keys (each with a value set to `True` or `False`):
            `&#39;is_standard_tally_output&#39;`, `&#39;is_binary_tally_dump&#39;`, `&#39;is_ASCII_tally_dump&#39;`,
            `&#39;is_unknown_file_type&#39;`, and `&#39;file_does_not_exist&#39;`.  By default, all are set to `False` except for
            `&#39;is_unknown_file_type&#39;` which is `True` by default.
    &#39;&#39;&#39;
    PHITS_file_type = {&#39;is_standard_tally_output&#39;: False,
                       &#39;is_binary_tally_dump&#39;: False,
                       &#39;is_ASCII_tally_dump&#39;: False,
                       &#39;is_unknown_file_type&#39;: True,
                       &#39;file_does_not_exist&#39;: False
                       }
    output_file = Path(output_file)
    if not output_file.is_file():
        print(&#39;Provided output file&#39;,output_file,&#39;was determined to not be a file!&#39;)
        PHITS_file_type[&#39;is_unknown_file_type&#39;] = False
        PHITS_file_type[&#39;file_does_not_exist&#39;] = True
        return PHITS_file_type
    with open(output_file) as f:
        try:
            first_line = f.readline().strip()
        except:  # triggered if encountering binary / non ASCII or UTF-8 file
            if &#39;_dmp&#39; in output_file.stem:
                PHITS_file_type[&#39;is_binary_tally_dump&#39;] = True
                PHITS_file_type[&#39;is_unknown_file_type&#39;] = False
                return PHITS_file_type
        if first_line[0] == &#39;[&#39;:
            PHITS_file_type[&#39;is_standard_tally_output&#39;] = True
            PHITS_file_type[&#39;is_unknown_file_type&#39;] = False
        elif &#39;_dmp&#39; in output_file.stem:
            PHITS_file_type[&#39;is_ASCII_tally_dump&#39;] = True
            PHITS_file_type[&#39;is_unknown_file_type&#39;] = False
    return PHITS_file_type













if run_with_CLI_inputs:
    def validate_file(arg):
        if (file := Path(arg)).is_file():
            return file
        else:
            raise FileNotFoundError(arg)
    parser = argparse.ArgumentParser()
    parser.add_argument(&#34;file&#34;, type=validate_file, help=&#34;path to PHITS output file to parse or directory containing files to parse (relative or absolute path)&#34;)
    # Flags for standard output files
    parser.add_argument(&#34;-g&#34;, &#34;--GUI&#34;, help=&#34;Launch the PHITS Tools GUI and ignore all other command line inputs&#34;, action=&#34;store_true&#34;)
    parser.add_argument(&#34;-np&#34;, &#34;--disable_PandasDF&#34;, help=&#34;[standard output] disable automatic creation of Pandas DataFrame of PHITS output&#34;, action=&#34;store_true&#34;)
    parser.add_argument(&#34;-na&#34;, &#34;--disable_abs_err_calc&#34;, help=&#34;[standard output] disable automatic calculation of absolute errors&#34;, action=&#34;store_true&#34;)
    # Not going to add below option. Why would you ever run this in CLI if not trying to generate the pickle file?
    # parser.add_argument(&#34;-ns&#34;, &#34;--disable_saving_pickle&#34;, help=&#34;disable saving of pickle of of PHITS output&#34;, action=&#34;store_true&#34;)
    # Flags for dump files
    parser.add_argument(&#34;-d&#34;, &#34;--is_dump_file&#34;, action=&#34;store_true&#34;, help=&#34;add this flag if the file is a dump file, omit if standard PHITS tally output; if inputting a directory path to &#39;file&#39;, this flag specifies that dump files will be read too (by default, they will be skipped), and if so the below flags will be applied to the settings used when parsing them&#34;)
    parser.add_argument(&#39;-dvals&#39;, &#39;--dump_data_sequence&#39;, nargs=&#39;+&#39;, type=int, help=&#39;[dump output] provide a series of integers separated by spaces that match the line after &#34;dump = &#34; in the tally whose dump file is being parsed, detailing how the columns of the dump file are to be interpreted. (REQUIRED for dump files, but an attempt to assign automatically will be made first if left unspecified)&#39;)
    parser.add_argument(&#34;-dbin&#34;, &#34;--dump_file_is_binary&#34;, action=&#34;store_true&#34;, help=&#34;[dump output] specify that the provided dump file is binary; otherwise it is assumed to be ASCII (REQUIRED for dump files, but an attempt to assign automatically will be made first if left unspecified)&#34;)
    parser.add_argument(&#34;-dnmax&#34;, &#34;--dump_max_entries_read&#34;, type=int, help=&#34;[dump output] specify maximum integer number of entries to read (read all by default)&#34;)
    parser.add_argument(&#34;-ddir&#34;, &#34;--dump_return_directional_info&#34;, action=&#34;store_true&#34;, help=&#34;[dump output] return extra directional information: radial distance r from the origin in cm, radial distance rho from the z-axis in cm, polar angle theta between the direction vector and z-axis in radians [0,pi] (or degrees), and azimuthal angle phi of the direction vector in radians [-pi,pi] (or degrees). Note: This option requires all position and direction values [x,y,z,u,v,w] to be included in the dump file.&#34;)
    parser.add_argument(&#34;-ddeg&#34;, &#34;--dump_use_degrees&#34;, action=&#34;store_true&#34;, help=&#34;[dump output] anular quantities will be in degrees instead of radians&#34;)
    parser.add_argument(&#34;-dnsl&#34;, &#34;--dump_no_save_namedtuple_list&#34;, action=&#34;store_true&#34;, help=&#34;[dump output] do NOT save parsed dump file info to list of namedtuples to dill file (-dnsl and -dnsp cannot both be enabled if parsing a dump file)&#34;)
    parser.add_argument(&#34;-dnsp&#34;, &#34;--dump_no_save_Pandas_dataframe&#34;, action=&#34;store_true&#34;, help=&#34;[dump output] do NOT save parsed dump file info to Pandas DataFrame to pickle file (-dnsl and -dnsp cannot both be enabled if parsing a dump file)&#34;)
    # Flags for processing files in a directory
    parser.add_argument(&#34;-r&#34;, &#34;--recursive_search&#34;, action=&#34;store_true&#34;, help=&#34;[directory parsing] If the provided &#39;file&#39; is a directory, also recursively search subdirectories for files to process.&#34;)
    parser.add_argument(&#34;-fpre&#34;, &#34;--file_prefix&#34;, default=&#39;&#39;, help=&#34;[directory parsing] A string specifying what characters processed filenames (including the file extension) must begin with to be included. This condition is not enforced if set to an empty string (default).&#34;)
    parser.add_argument(&#34;-fsuf&#34;, &#34;--file_suffix&#34;, default=&#39;.out&#39;, help=&#34;[directory parsing] A string specifying what characters processed filenames (including the file extension) must end in to be included. This condition is not enforced if set to an empty string. This is &#39;.out&#39; by deault.&#34;)
    parser.add_argument(&#34;-fstr&#34;, &#34;--file_required_string&#34;, default=&#39;&#39;, help=&#34;[directory parsing] A string which must be present anywhere within processed filenames (including the file extension) to be included. This condition is not enforced if set to an empty string (default).&#34;)

    args = parser.parse_args()

    output_file_path = Path(args.file)
    is_dump_file = args.is_dump_file

    is_path_a_dir = output_file_path.is_dir()
    is_path_a_file = output_file_path.is_file()

    if not is_path_a_file and not is_path_a_dir:
        raise ValueError(&#34;ERROR! The inputted filepath is neither a recognized file nor directory.&#34;)

    # directory options
    recursive_search = args.recursive_search
    file_suffix = args.file_suffix
    file_prefix = args.file_prefix
    file_reqstr = args.file_required_string

    # Standard output options
    make_PandasDF = not args.disable_PandasDF
    calculate_absolute_errors = not args.disable_abs_err_calc

    # Dump output options
    dump_data_sequence = args.dump_data_sequence
    if dump_data_sequence != None:
        dump_data_number = len(dump_data_sequence)
        if not args.dump_file_is_binary:
            dump_data_number = -1 * dump_data_number
    else:
        dump_data_number = None
    return_namedtuple_list = False
    return_Pandas_dataframe = False
    max_entries_read = args.dump_max_entries_read
    return_directional_info = args.dump_return_directional_info
    use_degrees = args.dump_use_degrees
    no_save_namedtuple_list = args.dump_no_save_namedtuple_list
    no_save_Pandas_dataframe = args.dump_no_save_Pandas_dataframe
    save_namedtuple_list = not no_save_namedtuple_list
    save_Pandas_dataframe = not no_save_Pandas_dataframe

    if is_path_a_dir:
        parse_all_tally_output_in_dir(output_file_path, output_file_suffix=file_suffix, output_file_prefix=file_prefix,
                                      output_file_required_string=file_reqstr, include_subdirectories=recursive_search,
                                      return_tally_output=False,
                                      make_PandasDF=make_PandasDF, calculate_absolute_errors=calculate_absolute_errors,
                                      save_output_pickle=True, prefer_reading_existing_pickle=False,
                                      include_dump_files=is_dump_file,
                                      dump_data_number=dump_data_number, dump_data_sequence=dump_data_sequence,
                                      dump_return_directional_info=return_directional_info, dump_use_degrees=use_degrees,
                                      dump_max_entries_read=max_entries_read,
                                      dump_save_namedtuple_list=save_namedtuple_list,
                                      dump_save_Pandas_dataframe=save_Pandas_dataframe
                                      )
    else: # if is_path_a_file
        if is_dump_file:
            if dump_data_number == None:
                dump_data_number, dump_data_sequence = search_for_dump_parameters(output_file_path)
                if dump_data_number == None or dump_data_sequence == None:
                    raise ValueError(&#39;You MUST provide a space-delimited list of integers to the -dvals / --dump_data_sequence input specifying &#39; +
                          &#39;how the data columns in the dump file are to be interpreted, the same as the line following &#34;dump = &#34; in your PHITS tally input. &#39; +
                          &#39;An attempt was made to automatically find these values, but it failed (thus, manual specification is required).&#39;)
            if no_save_namedtuple_list and no_save_Pandas_dataframe:
                raise ValueError(&#39;You MUST select how the dump file data is to be saved by disabling either or both of the following flags:&#39; +
                      &#39; -dsl / --dump_save_namedtuple_list AND/OR -dsp / --dump_save_Pandas_dataframe&#39;)
            parse_tally_dump_file(output_file_path, dump_data_number, dump_data_sequence,
                                  return_directional_info=return_directional_info, use_degrees=use_degrees,
                                  max_entries_read=max_entries_read,
                                  return_namedtuple_list=return_namedtuple_list,
                                  return_Pandas_dataframe=return_Pandas_dataframe,
                                  save_namedtuple_list=save_namedtuple_list,
                                  save_Pandas_dataframe=save_Pandas_dataframe)
        else:
            parse_tally_output_file(output_file_path, make_PandasDF=make_PandasDF,
                                    calculate_absolute_errors=calculate_absolute_errors,
                                    save_output_pickle=True, prefer_reading_existing_pickle=False)

elif launch_GUI:
    # tkinter GUI below written with the assistance of ChatGPT

    import tkinter as tk
    from tkinter import filedialog
    from tkinter import messagebox
    from tkinter import ttk
    import warnings
    import sys


    # Function to issue a warning on unexpected closure and then exit the program
    def on_closing(window):
        window.destroy()
        warnings.warn(&#34;Window closed unexpectedly&#34;, UserWarning)
        sys.exit()


    # Initialize the settings dictionary
    settings = {}

    standard_mode_short_text = &#34;[STANDARD mode]&#34;
    dump_mode_short_text = &#34;[DUMP mode]&#34;
    directory_mode_short_text = &#34;[DIRECTORY mode]&#34;

    standard_mode_full_text = standard_mode_short_text + &#34; for processing a single standard PHITS tally output file&#34;
    dump_mode_full_text = dump_mode_short_text + &#34; for processing a single PHITS tally dump output file (*_dmp.out)&#34;
    directory_mode_full_text = directory_mode_short_text + &#34; for processing all PHITS output files in a directory&#34;


    def on_option_selected():
        option = selected_option.get()
        file_chosen = None

        try:
            if option in [1, 2]:
                if option == 1:
                    window_name_str = &#39;Select standard PHITS tally output file&#39;
                else:
                    window_name_str = &#39;Select PHITS tally dump output file&#39;
                file_chosen = filedialog.askopenfilename(title=window_name_str)
                if not file_chosen:
                    raise ValueError(&#34;File selection is required&#34;)
                settings[&#39;file&#39;] = file_chosen
            elif option == 3:
                directory_chosen = filedialog.askdirectory(title=&#34;Select Directory of PHITS outputs to parse&#34;)
                if not directory_chosen:
                    raise ValueError(&#34;Directory selection is required&#34;)
                settings[&#39;directory&#39;] = directory_chosen
        except:
            raise ValueError(&#34;User closed the file/directory dialog&#34;)
        else:
            root.withdraw()
            create_secondary_gui(option)


    def create_secondary_gui(option):
        secondary_gui = tk.Toplevel(root)

        def on_closing_secondary_gui():
            on_closing(secondary_gui)

        secondary_gui.protocol(&#34;WM_DELETE_WINDOW&#34;, on_closing_secondary_gui)



        inputs = {
            1: [&#39;Checkbox 1&#39;, &#39;Checkbox 2&#39;],
            2: [&#39;Checkbox A&#39;, &#39;Checkbox B&#39;, &#39;Radio 1&#39;, &#39;Radio 2&#39;, &#39;Radio 3&#39;, &#39;Input 1 (str)&#39;, &#39;Input 2 (int)&#39;,
                &#39;Input 3 (int)&#39;],
            3: [&#39;Checkbox 1&#39;, &#39;Checkbox 2&#39;, &#39;Checkbox A&#39;, &#39;Checkbox B&#39;, &#39;Radio 1&#39;, &#39;Radio 2&#39;, &#39;Radio 3&#39;,
                &#39;Input 1 (str)&#39;, &#39;Input 2 (int)&#39;, &#39;Input 3 (int)&#39;, &#39;Input 4 (str)&#39;, &#39;Input 5 (str)&#39;, &#39;Input 6 (str)&#39;,
                &#39;Extra Checkbox 1&#39;, &#39;Extra Checkbox 2&#39;]
        }

        def save_settings():
            settings.update({
                &#39;main_mode&#39;: selected_option.get()
            })
            if option == 1:
                settings.update({
                    &#39;option_1_cb1&#39;: cb1_var.get(),
                    &#39;option_1_cb2&#39;: cb2_var.get()
                })
            elif option == 2:
                settings.update({
                    &#39;option_2_cb1&#39;: cb1_var.get(),
                    &#39;option_2_cb2&#39;: cb2_var.get(),
                    &#39;radio&#39;: radio_var.get(),
                    &#39;input_str&#39;: entry_str.get() or None,
                    &#39;input_int1&#39;: entry_int1.get() or None,
                    &#39;input_int2&#39;: entry_int2.get() or None,
                })
            elif option == 3:
                settings.update({
                    &#39;option_3_cb1&#39;: cb1_var.get(), &#39;option_3_cb2&#39;: cb2_var.get(),
                    &#39;option_3_cb3&#39;: cb3_var.get(), &#39;option_3_cb4&#39;: cb4_var.get(),
                    &#39;radio&#39;: radio_var.get(),
                    &#39;input_str_1&#39;: secondary_entry_str1.get() or None,
                    &#39;input_int_1&#39;: secondary_entry_int1.get() or None,
                    &#39;input_int_2&#39;: secondary_entry_int2.get() or None,
                    &#39;input_str_2&#39;: secondary_entry_str2.get() or None,
                    &#39;input_str_3&#39;: secondary_entry_str3.get() or None,
                    &#39;input_str_6&#39;: extra_entry_str1.get() or None,  # Renamed &#39;Extra Input 1&#39; to &#39;Input 6&#39;
                    &#39;extra_cb1&#39;: extra_cb1_var.get(),
                    &#39;extra_cb2&#39;: extra_cb2_var.get(),
                })
            secondary_gui.destroy()
            root.destroy()  # Ensure root window is destroyed after closing secondary GUI

        common_widgets = []

        if option == 1:
            sample_text_label = tk.Label(secondary_gui, text=standard_mode_full_text,
                                         anchor=tk.W, font=&#39;16&#39;)
            sample_text_label.pack(anchor=tk.W, padx=10, pady=2)
            cb1_var = tk.BooleanVar()
            cb2_var = tk.BooleanVar()
            common_widgets.append(tk.Checkbutton(secondary_gui, text=&#34;Also make and save Pandas DataFrame object of results (in addition to default NumPy array)&#34;, variable=cb1_var, anchor=tk.W))
            common_widgets[-1].select()  # This makes the checkbox be ticked by default
            common_widgets.append(tk.Checkbutton(secondary_gui, text=&#34;Also calculate absolute uncertainties&#34;, variable=cb2_var, anchor=tk.W))
            common_widgets[-1].select()  # This makes the checkbox be ticked by default

        elif option == 2:
            sample_text_label = tk.Label(secondary_gui, text=dump_mode_full_text,
                                         anchor=tk.W, font=&#39;16&#39;)
            sample_text_label.pack(anchor=tk.W, padx=10, pady=2)
            cb1_var = tk.BooleanVar()
            cb2_var = tk.BooleanVar()
            radio_var = tk.IntVar(value=3)
            entry_str = tk.Entry(secondary_gui, width=50)
            entry_int1 = tk.Entry(secondary_gui)
            entry_int2 = tk.Entry(secondary_gui)

            dir_info_str = &#34;Return extra directional information (relative to the origin and z-axis); \nthis requires all position and direction values [x,y,z,u,v,w] to be included in the dump file.&#34;
            common_widgets.append(tk.Checkbutton(secondary_gui, text=dir_info_str, variable=cb1_var, anchor=tk.W, justify=&#39;left&#39;))
            common_widgets.append(tk.Checkbutton(secondary_gui, text=&#34;Use degrees (instead of radians) for extra directional information&#34;, variable=cb2_var, anchor=tk.W))

            options_frame = tk.LabelFrame(secondary_gui, text=&#34;Data output format options&#34;)
            options_frame.pack(padx=10, pady=10, anchor=tk.W)

            tk.Radiobutton(options_frame, text=&#34;Save only a dill file of a list of named tuples with dump event information&#34;, variable=radio_var, value=1, anchor=tk.W).pack(anchor=tk.W)
            tk.Radiobutton(options_frame, text=&#34;Save only a pickle file of a Pandas DataFrame of dump event information&#34;, variable=radio_var, value=2, anchor=tk.W).pack(anchor=tk.W)
            tk.Radiobutton(options_frame, text=&#34;Save both the named tuples list dill file and the Pandas DataFrame pickle file&#34;, variable=radio_var, value=3, anchor=tk.W).pack(anchor=tk.W)

            dump_instrcutions = &#39;If in the same directory as your dump file exists the corresponding standard tally output file,\n&#39; + \
                                &#39;and the only difference in their file names is the &#34;_dmp&#34; at the end of the dump file, the \n&#39; + \
                                &#39;below two fields can be left blank as PHITS Tools should automatically find this information.\n&#39; + \
                                &#39;Otherwise, in the below two boxes, place what you entered following &#34;dump = &#34; in your PHITS tally.\n&#39; + \
                                &#39;In the first box, enter a nonzero integer between -20 and 20 specifying the number of dump\n&#39; + \
                                &#39;columns and whether the data will be in ASCII (&lt;0) or binary (&gt;0) format.\n&#39; + \
                                &#39;In the second box, enter a sequence of that many numbers, separated by spaces, describing \n&#39; + \
                                &#39;the column order of the dump file.&#39;
            common_widgets.append(tk.Label(secondary_gui, text=dump_instrcutions, anchor=tk.W, justify=&#34;left&#34;))
            common_widgets.append(entry_int1)
            #common_widgets.append(tk.Label(secondary_gui, text=&#34;Input 1 (string)&#34;, anchor=tk.W))
            common_widgets.append(entry_str)



            common_widgets.append(tk.Label(secondary_gui, text=&#34;\nMaximum number of dump entries to read. Leave blank to read all.&#34;, anchor=tk.W))
            common_widgets.append(entry_int2)

        elif option == 3:
            cb1_var = tk.BooleanVar()
            cb2_var = tk.BooleanVar()
            cb3_var = tk.BooleanVar()
            cb4_var = tk.BooleanVar()
            radio_var = tk.IntVar(value=3)

            secondary_entry_str1 = tk.Entry(secondary_gui, width=50)  # Extra width added here
            secondary_entry_int1 = tk.Entry(secondary_gui)
            secondary_entry_int2 = tk.Entry(secondary_gui)
            secondary_entry_str2 = tk.Entry(secondary_gui)
            secondary_entry_str2.insert(0, &#34;.out&#34;) # this is how default values have to be specified for tkinter...
            secondary_entry_str3 = tk.Entry(secondary_gui)

            extra_entry_str1 = tk.Entry(secondary_gui)
            extra_cb1_var = tk.BooleanVar()
            extra_cb2_var = tk.BooleanVar()

            # Add extra sample text label at the top of the secondary GUI
            top_sample_label = tk.Label(secondary_gui, text=directory_mode_full_text,
                                        anchor=tk.W, font=&#39;16&#39;)
            top_sample_label.pack(anchor=tk.W, padx=10, pady=10)

            common_widgets.append(tk.Checkbutton(secondary_gui, text=&#34;Also include contents of all subdirectories&#34;, variable=cb1_var, anchor=tk.W))
            common_widgets.append(tk.Checkbutton(secondary_gui, text=&#34;Include dump files (otherwise, they will be skipped)&#34;, variable=cb2_var, anchor=tk.W))

        # Pack common widgets with left alignment.
        for widget in common_widgets:
            widget.pack(anchor=tk.W, padx=10, pady=2)

        if option == 3:
            name_instructions_str = &#39;In the below 3 fields, specify what characters processed filenames (including the file extension)\n&#39; + \
                                    &#39;must either end with, start with, or contain in order to be processed. Leave blank to ignore.&#39;
            tk.Label(secondary_gui, text=name_instructions_str, anchor=tk.W, justify=&#39;left&#39;).pack(anchor=tk.W, padx=10, pady=2)

            tk.Label(secondary_gui, text=&#34;End of filename character string (suffix)&#34;, anchor=tk.W).pack(anchor=tk.W, padx=10, pady=2)
            secondary_entry_str2.pack(anchor=tk.W, padx=10, pady=2)

            tk.Label(secondary_gui, text=&#34;Start of filename character string (prefix)&#34;, anchor=tk.W).pack(anchor=tk.W, padx=10, pady=2)
            secondary_entry_str3.pack(anchor=tk.W, padx=10, pady=2)

            tk.Label(secondary_gui, text=&#34;String which must appear in filename (anywhere)&#34;, anchor=tk.W).pack(anchor=tk.W, padx=10, pady=2)
            extra_entry_str1.pack(anchor=tk.W, padx=10, pady=2)


            # Add horizontal separator immediately beneath &#34;Checkbox 2&#34;
            separator = ttk.Separator(secondary_gui, orient=&#39;horizontal&#39;)
            separator.pack(fill=tk.X, padx=10, pady=10)

            sample_text_label2 = tk.Label(secondary_gui, text=&#34;Options for processing standard PHITS tally output files&#34;,
                                         anchor=tk.W, font=&#39;14&#39;)
            sample_text_label2.pack(anchor=tk.W, padx=10, pady=2)

            cb3obj = tk.Checkbutton(secondary_gui, text=&#34;Also make and save Pandas DataFrame object of results (in addition to default NumPy array)&#34;, variable=cb3_var, anchor=tk.W)
            cb3obj.select() # This makes the checkbox be ticked by default
            cb3obj.pack(anchor=tk.W, padx=10, pady=2)
            cb4obj = tk.Checkbutton(secondary_gui, text=&#34;Also calculate absolute uncertainties&#34;, variable=cb4_var, anchor=tk.W)
            cb4obj.select() # This makes the checkbox be ticked by default
            cb4obj.pack(anchor=tk.W, padx=10, pady=2)

            options_frame = tk.LabelFrame(secondary_gui, text=&#34;Data output format options for dump files&#34;)
            tk.Radiobutton(options_frame, text=&#34;Save only a dill file of a list of named tuples with dump event information&#34;, variable=radio_var, value=1, anchor=tk.W).pack(anchor=tk.W)
            tk.Radiobutton(options_frame, text=&#34;Save only a pickle file of a Pandas DataFrame of dump event information&#34;, variable=radio_var, value=2, anchor=tk.W).pack(anchor=tk.W)
            tk.Radiobutton(options_frame, text=&#34;Save both the named tuples list dill file and the Pandas DataFrame pickle file&#34;, variable=radio_var, value=3, anchor=tk.W).pack(anchor=tk.W)



            # Add horizontal separator immediately beneath &#34;Input 3 (integer)&#34;
            separator_1 = ttk.Separator(secondary_gui, orient=&#39;horizontal&#39;)
            separator_1.pack(fill=tk.X, padx=10, pady=10)

            sample_text_label = tk.Label(secondary_gui, text=&#34;Options for processing PHITS tally dump output files&#34;,
                                         anchor=tk.W, font=&#39;14&#39;)
            sample_text_label.pack(anchor=tk.W, padx=10, pady=2)

            options_frame.pack(padx=10, pady=10, anchor=tk.W) # radio buttons

            dir_info_str = &#34;Return extra directional information (relative to the origin and z-axis); \nthis requires all position and direction values [x,y,z,u,v,w] to be included in the dump file.&#34;
            tk.Checkbutton(secondary_gui, text=dir_info_str, variable=extra_cb1_var, anchor=tk.W, justify=&#39;left&#39;).pack(
                anchor=tk.W, padx=10, pady=2)
            tk.Checkbutton(secondary_gui, text=&#34;Use degrees (instead of radians) for extra directional information&#34;, variable=extra_cb2_var, anchor=tk.W).pack(
                anchor=tk.W, padx=10, pady=2)

            dump_instrcutions = &#39;If in the same directory as the found dump file exists the corresponding standard tally output file,\n&#39; + \
                                &#39;and the only difference in their file names is the &#34;_dmp&#34; at the end of the dump file, the \n&#39; + \
                                &#39;below two fields can be left blank as PHITS Tools should automatically find this information.\n&#39; + \
                                &#39;Otherwise, in the below two boxes, place what you entered following &#34;dump = &#34; in your PHITS tally.\n&#39; + \
                                &#39;In the first box, enter a nonzero integer between -20 and 20 specifying the number of dump\n&#39; + \
                                &#39;columns and whether the data will be in ASCII (&lt;0) or binary (&gt;0) format.\n&#39; + \
                                &#39;In the second box, enter a sequence of that many numbers, separated by spaces, describing \n&#39; + \
                                &#39;the column order of the dump file.&#39;

            tk.Label(secondary_gui, text=dump_instrcutions, anchor=tk.W, justify=&#39;left&#39;).pack(anchor=tk.W, padx=10, pady=2)
            secondary_entry_int1.pack(anchor=tk.W, padx=10, pady=2)
            #tk.Label(secondary_gui, text=&#34;Input 1 (string)&#34;, anchor=tk.W).pack(anchor=tk.W, padx=10, pady=2)
            secondary_entry_str1.pack(anchor=tk.W, padx=10, pady=2)



            tk.Label(secondary_gui, text=&#34;\nMaximum number of dump entries to read. Leave blank to read all.&#34;, anchor=tk.W).pack(anchor=tk.W, padx=10, pady=2)
            secondary_entry_int2.pack(anchor=tk.W, padx=10, pady=2)



        save_btn = tk.Button(secondary_gui, text=&#34;Run PHITS Tools with selected settings&#34;, command=save_settings)
        save_btn.pack(pady=10)


    root = tk.Tk()
    root.title(&#39;PHITS Tools&#39;)

    # protocol for main menu window to issue warning and exit if closed
    root.protocol(&#34;WM_DELETE_WINDOW&#34;, lambda: on_closing(root))

    selected_option = tk.IntVar(value=1)

    sample_text_label2 = tk.Label(text=&#34;Select what mode PHITS Tools should be ran in:&#34;,anchor=tk.W,font=&#39;16&#39;)
    sample_text_label2.pack(anchor=tk.W, padx=10, pady=2)

    tk.Radiobutton(root, text=standard_mode_full_text, variable=selected_option, value=1).pack(anchor=tk.W)
    tk.Radiobutton(root, text=dump_mode_full_text, variable=selected_option, value=2).pack(anchor=tk.W)
    tk.Radiobutton(root, text=directory_mode_full_text, variable=selected_option, value=3).pack(anchor=tk.W)

    confirm_btn = tk.Button(root, text=&#34;Select&#34;, command=on_option_selected)
    confirm_btn.pack(pady=4)

    root.mainloop()

    # Print final settings dictionary
    if in_debug_mode:
        print(&#34;Settings:&#34;, settings)

    if settings[&#39;main_mode&#39;] == 1: # standard tally mode
        make_PandasDF = settings[&#39;option_1_cb1&#39;]
        calculate_absolute_errors = settings[&#39;option_1_cb2&#39;]
        parse_tally_output_file(Path(settings[&#39;file&#39;]), make_PandasDF=make_PandasDF,
                                calculate_absolute_errors=calculate_absolute_errors,
                                save_output_pickle=True, prefer_reading_existing_pickle=False)

    elif settings[&#39;main_mode&#39;] == 2:  # dump tally mode
        output_file_path = Path(settings[&#39;file&#39;])
        return_directional_info = settings[&#39;option_2_cb1&#39;]
        use_degrees = settings[&#39;option_2_cb2&#39;]
        save_namedtuple_list = False
        save_Pandas_dataframe = False
        if settings[&#39;radio&#39;] == 1:
            save_namedtuple_list = True
        elif settings[&#39;radio&#39;] == 2:
            save_Pandas_dataframe = True
        elif settings[&#39;radio&#39;] == 3:
            save_namedtuple_list = True
            save_Pandas_dataframe = True
        dump_data_number = settings[&#39;input_int1&#39;]
        if dump_data_number != None: dump_data_number = int(dump_data_number)
        dump_data_sequence = settings[&#39;input_str&#39;]
        max_entries_read = settings[&#39;input_int2&#39;]
        if max_entries_read != None: max_entries_read = int(max_entries_read)

        if dump_data_number == None:
            dump_data_number, dump_data_sequence = search_for_dump_parameters(output_file_path)
            if dump_data_number == None or dump_data_sequence == None:
                raise ValueError(
                    &#39;You MUST provide a space-delimited list of integers to the -dvals / --dump_data_sequence input specifying &#39; +
                    &#39;how the data columns in the dump file are to be interpreted, the same as the line following &#34;dump = &#34; in your PHITS tally input. &#39; +
                    &#39;An attempt was made to automatically find these values, but it failed (thus, manual specification is required).&#39;)
        parse_tally_dump_file(output_file_path, dump_data_number, dump_data_sequence,
                              return_directional_info=return_directional_info, use_degrees=use_degrees,
                              max_entries_read=max_entries_read,
                              return_namedtuple_list=False,
                              return_Pandas_dataframe=False,
                              save_namedtuple_list=save_namedtuple_list,
                              save_Pandas_dataframe=save_Pandas_dataframe)

    elif settings[&#39;main_mode&#39;] == 3:  # directory mode
        recursive_search = settings[&#39;option_3_cb1&#39;]
        include_dump_files = settings[&#39;option_3_cb2&#39;]
        make_PandasDF = settings[&#39;option_3_cb3&#39;]
        calculate_absolute_errors = settings[&#39;option_3_cb4&#39;]
        file_suffix = settings[&#39;input_str_2&#39;]
        if file_suffix == None: file_suffix = &#39;&#39;
        file_prefix = settings[&#39;input_str_3&#39;]
        if file_prefix == None: file_prefix = &#39;&#39;
        file_reqstr = settings[&#39;input_str_6&#39;]
        if file_reqstr == None: file_reqstr = &#39;&#39;

        save_namedtuple_list = False
        save_Pandas_dataframe = False
        if settings[&#39;radio&#39;] == 1:
            save_namedtuple_list = True
        elif settings[&#39;radio&#39;] == 2:
            save_Pandas_dataframe = True
        elif settings[&#39;radio&#39;] == 3:
            save_namedtuple_list = True
            save_Pandas_dataframe = True
        dump_data_sequence = settings[&#39;input_str_1&#39;]
        dump_data_number = settings[&#39;input_int_1&#39;]
        if dump_data_number != None: dump_data_number = int(dump_data_number)
        max_entries_read = dump_data_number = settings[&#39;input_int_2&#39;]
        if max_entries_read != None: max_entries_read = int(max_entries_read)
        return_directional_info = settings[&#39;extra_cb1&#39;]
        use_degrees = settings[&#39;extra_cb2&#39;]

        parse_all_tally_output_in_dir(Path(settings[&#39;directory&#39;]),
                                      output_file_suffix=file_suffix, output_file_prefix=file_prefix,
                                      output_file_required_string=file_reqstr, include_subdirectories=recursive_search,
                                      return_tally_output=False,
                                      make_PandasDF=make_PandasDF, calculate_absolute_errors=calculate_absolute_errors,
                                      save_output_pickle=True, prefer_reading_existing_pickle=False,
                                      include_dump_files=include_dump_files,
                                      dump_data_number=dump_data_number, dump_data_sequence=dump_data_sequence,
                                      dump_return_directional_info=return_directional_info,
                                      dump_use_degrees=use_degrees,
                                      dump_max_entries_read=max_entries_read,
                                      dump_save_namedtuple_list=save_namedtuple_list,
                                      dump_save_Pandas_dataframe=save_Pandas_dataframe
                                      )

    else:
        raise ValueError(&#39;ERROR: Main mode for PHITS Tools not selected correctly in first GUI&#39;)








elif test_explicit_files_dirs:
    #base_path = r&#39;G:\Cloud\OneDrive\work\PHITS\test_tallies\tally\\&#39;
    #output_file_path = Path(base_path + &#39;t-deposit\deposit_reg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit\deposit_eng_sp-reg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-track\\track_reg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-track\\track_r-z.out&#39;)
    #output_file_path = Path(base_path + &#39;t-track\\track_xyz-xy.out&#39;)
    #output_file_path = Path(base_path + r&#39;t-track\track_r-z_axis-rad.out&#39;)
    #output_file_path = Path(base_path + r&#39;t-track\track_r-z_axis-deg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit\deposit_r-z.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit\deposit_r-z_2dtype4.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit\deposit_r-z_2dtype5.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit\deposit_xyz_2dtype5.out&#39;)
    #output_file_path = Path(base_path + &#39;tet_test\deposit-tet_axis-tet.out&#39;)
    #output_file_path = Path(base_path + &#39;tet_test\deposit-tet_axis-eng.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\cross_reg_axis-eng.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\cross_reg_axis-reg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\cross_xyz_axis-eng.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\cross_xyz_axis-eng_enclosed.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\cross_xyz_axis-reg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\cross_xyz_axis-xy.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\cross-r-z_axis-eng.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\cross-r-z_axis-eng_0r.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\cross-r-z_axis-eng_enclosed.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\complex\proton_in_hist_rz.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\complex\\neutron_yield_rz-e-a-mesh.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\complex\\neutron_yield.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\complex\\xtra_neutron_yield_EvsTheta_whole-target.out&#39;)
    #output_file_path = Path(base_path + &#39;t-dpa\dpa_reg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-dpa\dpa_xyz.out&#39;)
    #output_file_path = Path(base_path + &#39;t-dpa\dpa_r-z.out&#39;)
    #output_file_path = Path(base_path + &#39;samepage\\proton_in_hist_rz_axis-eng_samepage-z.out&#39;)
    #output_file_path = Path(base_path + &#39;samepage\\proton_in_hist_rz_reduced.out&#39;) # has NULL characters in it
    #output_file_path = Path(base_path + &#39;samepage\\proton_in_hist_rz_sp-eng.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit2\deposit2_reg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit2\deposit2_reg_axis-e21.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit2\deposit2_reg_axis-t-e1.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit2\deposit2_reg_axis-t-e2.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit2\deposit2_reg_axis-e1-t.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit2\deposit2_reg_axis-e2-t.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit2\deposit2_reg_axis-eng1.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit2\deposit2_reg_axis-eng2.out&#39;)
    #output_file_path = Path(base_path + &#39;t-heat\heat_reg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-heat\heat_xyz.out&#39;)
    #output_file_path = Path(base_path + &#39;t-interact\interact_reg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-interact\interact_xyz.out&#39;)
    #output_file_path = Path(base_path + &#39;t-let\let-distribution_reg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-let\let-distribution_r-z.out&#39;)
    #output_file_path = Path(base_path + r&#39;t-point\point.out&#39;)
    #output_file_path = Path(base_path + r&#39;t-point\ring.out&#39;)
    #output_file_path = Path(base_path + &#39;t-product\product_reg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-sed\y-distribution_reg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-sed\y-distribution_xyz.out&#39;)
    #output_file_path = Path(base_path + r&#39;t-time\time_reg.out&#39;)
    #output_file_path = Path(base_path + r&#39;t-time\time_xyz.out&#39;)
    #output_file_path = Path(base_path + r&#39;t-yield\yield_reg_axis-charge.out&#39;)
    #output_file_path = Path(base_path + r&#39;t-yield\yield_reg_axis-mass.out&#39;)
    #output_file_path = Path(base_path + r&#39;t-yield\yield_reg_axis-chart.out&#39;)
    #output_file_path = Path(base_path + r&#39;t-yield\yield_xyz_axis-chart.out&#39;)

    base_path = r&#39;G:\Cloud\OneDrive\work\PHITS\test_tallies\\&#39;
    #output_file_path = Path(base_path + r&#39;tally\t-deposit\deposit_reg_spec-all.out&#39;)
    #output_file_path = Path(base_path + r&#39;sample\icrp\mrcp\External\result\Dose_MRCP-AF_reg.out&#39;)
    #output_file_path = Path(base_path + r&#39;sample\misc\batch_source\track_yz_001.out&#39;)
    #output_file_path = Path(base_path + r&#39;sample\source\Cosmicray\GCR-ground\cross.out&#39;)
    #output_file_path = Path(base_path + r&#39;recommendation\Fusion\track.out&#39;)
    #output_file_path = Path(base_path + r&#39;sample\benchmark\Iwamoto-JNST2022\case5-isis800\output\rr_air_model.out&#39;)
    #output_file_path = Path(base_path + r&#39;recommendation\muon\product.out&#39;)
    #output_file_path = Path(base_path + r&#39;recommendation\BNCT\dose.out&#39;)
    #output_file_path = Path(base_path + r&#39;recommendation\SemiConductor\deposit.out&#39;)
    #output_file_path = Path(base_path + r&#39;recommendation\Shielding\track-rz.out&#39;)
    output_file_path = Path(base_path + r&#39;recommendation\TrackStructure\interact.out&#39;)


    test_parsing_of_dir = False #True
    if test_parsing_of_dir:
        dir_path = output_file_path = Path(base_path + &#39;t-cross\complex\proton_in_hist_rz.out&#39;)
        dir_output_list = parse_all_tally_output_in_dir(dir_path)
        print(dir_output_list)
        sys.exit()


    test_dump_file = False
    if test_dump_file:
        dump_file_path = Path(base_path + &#39;t-cross\complex\\neutron_yield_dmp.out&#39;)
        dump_control_str = &#39;2   3   4   5   6   7   8  10&#39;
        #nt_list, df = parse_tally_dump_file(dump_file_path,8,dump_control_str, save_namedtuple_list=True, save_Pandas_dataframe=True)
        # test automatic finding of dump parameters
        nt_list, df = parse_tally_dump_file(dump_file_path, save_namedtuple_list=True, save_Pandas_dataframe=True)

        # test dill of namedtuple list
        import dill
        path_to_pickle_file = Path(base_path + &#39;t-cross\complex\\neutron_yield_dmp_namedtuple_list.dill&#39;)
        with open(path_to_pickle_file, &#39;rb&#39;) as handle:
            nt_list_dill = dill.load(handle)

        if nt_list==nt_list_dill: print(&#39;It works!&#39;)

        sys.exit()



    tally_output_filepath = output_file_path
    tally_output = parse_tally_output_file(tally_output_filepath, make_PandasDF=True, calculate_absolute_errors=True,
                                           save_output_pickle=True)
    tally_data = tally_output[&#39;tally_data&#39;]
    tally_metadata = tally_output[&#39;tally_metadata&#39;]

    #pprint.pp(dict(tally_metadata))
    #                ir, iy, iz, ie, it, ia, il, ip, ic, ierr
    print(tally_data[ :,  0,  0,  :,  0,  0,  0,  0,  0, 0])
    print(tally_data[ :,  0,  0,  :,  0,  0,  0,  0,  0, 1])
    print(tally_data[0, :, :, 0, 0, 0, 0, 0, 0, 0])
    print(np.shape(tally_data))

    #print(tally_data[ 1,  0,  0,  0,  0,  0,  0,  0,  :, 0])
    #print(tally_metadata[&#39;nuclide_ZZZAAAM_list&#39;])
    #print(tally_metadata[&#39;nuclide_isomer_list&#39;])

    #ic = tally_metadata[&#39;nuclide_ZZZAAAM_list&#39;].index(10020)
    #print(tally_data[1, 0, 0, 0, 0, 0, 0, 0, ic, 0])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="PHITS_tools.parse_tally_output_file"><code class="name flex">
<span>def <span class="ident">parse_tally_output_file</span></span>(<span>tally_output_filepath, make_PandasDF=True, calculate_absolute_errors=True, save_output_pickle=True, prefer_reading_existing_pickle=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Parse any PHITS tally output file, returning tally metadata and an array of its values (and optionally
this data inside of a Pandas dataframe too).
Note the separate <code><a title="PHITS_tools.parse_tally_dump_file" href="#PHITS_tools.parse_tally_dump_file">parse_tally_dump_file()</a></code> function for
parsing PHITS dump files.
If a DCHAIN input file (output from the [T-Dchain] tally) or DCHAIN output
<code>*.act</code> file is provided, an attempt will be made to import the <a href="https://github.com/Lindt8/DCHAIN-Tools">DCHAIN Tools module</a> and process the found
DCHAIN output files, returning the output dictionary object and (optionally) saving it to a pickle file.</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code>import numpy as np</code></li>
<li><code>import pandas as pd</code> (if <code>make_PandasDF = True</code>)</li>
<li><code>import pickle</code> (if <code>save_output_pickle = True</code>)</li>
<li><code>from munch import *</code></li>
<li><code>from pathlib import Path</code></li>
</ul>
<h2 id="inputs">Inputs</h2>
<p>(required)</p>
<ul>
<li><code>tally_output_filepath</code> = file or filepath to the tally output file to be parsed</li>
</ul>
<h2 id="inputs_1">Inputs</h2>
<p>(optional)</p>
<ul>
<li><code>make_PandasDF</code> = A Boolean determining whether a Pandas dataframe of the tally data array will be made (D=<code>True</code>)</li>
<li><code>calculate_absolute_errors</code> = A Boolean determining whether the absolute uncertainty of each tally output value
is to be calculated (simply as the product of the value and relative error); if <code>False</code>, the final
dimension of <code>tally_data</code>, <code>ierr</code>, will be of length-2 rather than length-3 (D=<code>True</code>)</li>
<li><code>save_output_pickle</code> = A Boolean determining whether the <code>tally_output</code> dictionary object is saved as a pickle file;
if <code>True</code>, the file will be saved with the same path and name as the provided PHITS tally output file
but with the .pickle extension. (D=<code>True</code>)</li>
<li><code>prefer_reading_existing_pickle</code> = A Boolean determining what this function does if the pickle file this function
seeks to generate already exists.
If <code>False</code> (default behavior), this function will parse the PHITS
output files as usual and overwrite the existing pickle file.
If <code>True</code>, this function will instead
simply just read the existing found pickle file and return its stored <code>tally_output</code> contents. (D=<code>False</code>)</li>
</ul>
<h2 id="output">Output</h2>
<ul>
<li><code>tally_output</code> = a dictionary object with the below keys and values:<ul>
<li><code>'tally_data'</code> = a 10-dimensional NumPy array containing all tally results, explained in more detail below</li>
<li><code>'tally_metadata'</code> = a dictionary/Munch object with various data extracted from the tally output file, such as axis binning and units</li>
<li><code>'tally_dataframe'</code> = (optionally included if setting <code>make_PandasDF = True</code>) a Pandas dataframe version of <code>tally_data</code></li>
</ul>
</li>
</ul>
<h2 id="notes">Notes</h2>
<p>Many quantities can be scored across the various tallies in the PHITS code.
This function outputs a "universal"
array <code>tally_data</code> that can accomodate all of the different scoring geometry meshes, physical quantities with
assigned meshes, and output axes provided within PHITS.
This is achieved with a 10-dimensional array accessible as</p>
<p><code>tally_data[ ir, iy, iz, ie, it, ia, il, ip, ic, ierr ]</code>, with indices explained below:</p>
<p>Tally data indices and corresponding mesh/axis:</p>
<ul>
<li><code>0</code> | <code>ir</code>, Geometry mesh: <code>reg</code> / <code>x</code> / <code>r</code> / <code>tet</code> ([T-Cross] <code>ir surf</code> if <code>mesh=r-z</code> with <code>enclos=0</code>)</li>
<li><code>1</code> | <code>iy</code>, Geometry mesh:
<code>1</code> / <code>y</code> / <code>1</code></li>
<li><code>2</code> | <code>iz</code>, Geometry mesh:
<code>1</code> / <code>z</code> / <code>z</code> ([T-Cross] <code>iz surf</code> if <code>mesh=xyz</code> or <code>mesh=r-z</code> with <code>enclos=0</code>)</li>
<li><code>3</code> | <code>ie</code>, Energy mesh: <code>eng</code> ([T-Deposit2] <code>eng1</code>)</li>
<li><code>4</code> | <code>it</code>, Time mesh</li>
<li><code>5</code> | <code>ia</code>, Angle mesh</li>
<li><code>6</code> | <code>il</code>, LET mesh</li>
<li><code>7</code> | <code>ip</code>, Particle type (<code>part =</code>)</li>
<li><code>8</code> | <code>ic</code>, Special: [T-Deposit2] <code>eng2</code>; [T-Yield] <code>mass</code>, <code>charge</code>, <code>chart</code>; [T-Interact] <code>act</code></li>
<li><code>9</code> | <code>ierr = 0/1/2</code>, Value / relative uncertainty / absolute uncertainty (expanded to <code>3/4/5</code>, or <code>2/3</code> if
<code>calculate_absolute_errors = False</code>, for [T-Cross] <code>mesh=r-z</code> with <code>enclos=0</code> case; see notes further below)</li>
</ul>
<hr>
<p>By default, all array dimensions are length-1 (except <code>ierr</code>, which is length-3).
These dimensions are set/corrected
automatically when parsing the tally output file.
Thus, for very simple tallies, most of these indices will be
set to 0 when accessing tally results, e.g. <code>tally_data[2,0,0,:,0,0,0,:,0,:]</code> to access the full energy spectrum
in the third region for all scored particles / particle groups with the values and uncertainties.</p>
<p>The output <code>tally_metadata</code> dictionary contains all information needed to identify every bin along every
dimension: region numbers/groups, particle names/groups, bin edges and midpoints for all mesh types
(x, y, z, r, energy, angle, time, and LET) used in the tally.</p>
<p>The <code>tally_dataframe</code> Pandas dataframe output functions as normal.
Note that a dictionary containing supplemental
information that is common to all rows of the dataframe can be accessed with <code>tally_dataframe.attrs</code>.</p>
<hr>
<p><strong>Unsupported tallies and DCHAIN</strong></p>
<p>At present, the following tallies are NOT supported by this function: [T-WWG], [T-WWBG], [T-Volume],
[T-Userdefined], [T-Gshow], [T-Rshow], [T-3Dshow], [T-4Dtrack], and [T-Dchain]&dagger;.</p>
<p>&dagger;If provided with the output file of [T-Dchain] (the input file for the DCHAIN code) or the <code>*.act</code> main
output file produced by the DCHAIN code, this function will attempt to import the <a href="https://github.com/Lindt8/DCHAIN-Tools">DCHAIN Tools module</a>
and process the found DCHAIN output files, returning the output dictionary object and (optionally) saving it to a pickle file.
Otherwise, for [T-Dchain] or [T-Yield] with <code>axis = dchain</code>, you can manually use the separate suite of parsing
functions included in the <a href="https://github.com/Lindt8/DCHAIN-Tools">DCHAIN Tools</a> module.</p>
<hr>
<p><strong>[T-Cross] special case</strong></p>
<p>The [T-Cross] tally is unique (scoring across region boundaries rather than within regions), creating some
additional challenges.
In the <code>mesh = reg</code> case, much is the same except each region number is composed of the <code>r-from</code> and <code>r-to</code> values, e.g. <code>'100 - 101'</code>.</p>
<p>For <code>xyz</code> and <code>r-z</code> meshes, an additional parameter is at play: <code>enclos</code>.
By default, <code>enclos=0</code>.
In the event <code>enclos=1</code> is set, the total number of geometric regions is still either <code>nx*ny*nz</code> or <code>nr*nz</code> for
<code>xyz</code> and <code>r-z</code> meshes, respectively.
For <code>enclos=0</code> in the <code>mesh = xyz</code> case, the length of the z dimension (<code>iz</code> index) is instead equal to <code>nzsurf</code>,
which is simply one greater than <code>nz</code> (# regions = <code>nx*ny*(nz+1)</code>).</p>
<p>For <code>enclos=0</code> in the <code>mesh = r-z</code> case, this is much more complicated as PHITS will output every combination of
<code>nr*nzsurf</code> AND <code>nrsurf*nz</code>, noting <code>nzsurf=nz+1</code> and <code>nrsurf=nr+1</code> (or <code>nrsurf=nr</code> if the first radius bin edge
is <code>r=0.0</code>).
The solution implemented here is to, for only this circumstance (in only the <code>enclos=0 mesh=r-z</code> case),
set the length of the <code>ir</code> and <code>iz</code> dimensions to <code>nrsurf</code> and <code>nzsurf</code>, respectively, and also
to expand the length of the final dimension of <code>tally_data</code> from 3 to 6 (or from 2 to 4 if <code>calculate_absolute_errors=False</code>), where:</p>
<ul>
<li><code>ierr = 0/1/2</code> refer to the combinations of <code>nr</code> and <code>nzsurf</code> (or <code>0/1</code> if <code>calculate_absolute_errors=False</code>)</li>
<li><code>ierr = 3/4/5</code> refer to the combinations of <code>nrsurf</code> and <code>nz</code> (or <code>2/3</code> if <code>calculate_absolute_errors=False</code>)</li>
</ul>
<p>In this case, the Pandas dataframe, if enabled, will contain 3 (or 2) extra columns <code>value2</code> and <code>rel.err.2</code> [and <code>abs.err.2</code>],
which correspond to the combinations of <code>nrsurf</code> and <code>nz</code> (while the original columns without the "2" refer to
values for combinations of and <code>nr</code> and <code>nzsurf</code>).</p>
<hr>
<p><strong>[T-Yield] special case</strong></p>
<p>[T-Yield] is also a bit exceptional.
When setting the <code>axis</code> parameter equal to <code>charge</code>, <code>mass</code>, or <code>chart</code>,
the <code>ic</code> dimension of <code>tally_data</code> is used for each entry of charge (proton number, Z), mass (A), or
isotope/isomer, respectively.</p>
<p>In the case of <code>axis = charge</code> or <code>axis = mass</code>, the value of <code>ic</code> refers to the actual charge/proton number Z
or mass number A when accessing <code>tally_data</code>; for instance, <code>tally_data[:,:,:,:,:,:,:,:,28,:]</code>
references results from nuclei with Z=28 if <code>axis = charge</code> or A=28 if <code>axis = mass</code>.
The length of the <code>ic</code>
dimension is initialized as 130 or 320 but is later reduced to only just include the highest charge or mass value.</p>
<p>In the case of <code>axis = chart</code>, the length of the <code>ic</code> dimension is initially set equal to the <code>mxnuclei</code> parameter
in the [T-Yield] tally.
If <code>mxnuclei = 0</code> is set, then the length of the <code>ic</code> dimension is initially set to 10,000.
This <code>ic</code> dimension length is later reduced to the total number of unique nuclides found in the output.
Owing to the huge number of possible nuclides, a list of found nuclides with nonzero yield is assembled and
added to <code>tally_metadata</code> under the keys <code>nuclide_ZZZAAAM_list</code> and <code>nuclide_isomer_list</code>, i.e.
<code>tally_metadata['nuclide_ZZZAAAM_list']</code> and <code>tally_metadata['nuclide_isomer_list']</code>.
These lists should be referenced to see what nuclide each of index <code>ic</code> refers to.
The entries of the ZZZAAAM list are intergers calculated with the formula 10000*Z + 10*A + M, where M is the
metastable state of the isomer (0 = ground state, 1 = 1st metastable/isomeric state, etc.).
The entries
of the isomer list are these same nuclides in the same order but written as plaintext strings, e.g. <code>'Al-28'</code> and <code>'Xe-133m1'</code>.
The lists are ordered in the same order nuclides are encountered while parsing the output file.
Thus, to sensibly access the yield of a specific nuclide, one must first find its index <code>ic</code> in one of the two
metadata lists of ZZZAAAM values or isomer names and then use that to access <code>tally_data</code>.
For example, to get
the yield results of production of carbon-14 (C-14), one would use the following code:</p>
<p><code>ic = tally_metadata['nuclide_ZZZAAAM_list'].index(60140)</code></p>
<p>OR</p>
<p><code>ic = tally_metadata['nuclide_isomer_list'].index('C-14')</code></p>
<p>then</p>
<p><code>my_yield_values = tally_data[:,:,:,:,:,:,:,:,ic,:]</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_tally_output_file(tally_output_filepath, make_PandasDF = True, calculate_absolute_errors = True,
                            save_output_pickle = True, prefer_reading_existing_pickle = False):
    &#39;&#39;&#39;
    Description:
        Parse any PHITS tally output file, returning tally metadata and an array of its values (and optionally
        this data inside of a Pandas dataframe too).  Note the separate `parse_tally_dump_file` function for
        parsing PHITS dump files.  If a DCHAIN input file (output from the [T-Dchain] tally) or DCHAIN output
        `*.act` file is provided, an attempt will be made to import the [DCHAIN Tools module](https://github.com/Lindt8/DCHAIN-Tools) and process the found
        DCHAIN output files, returning the output dictionary object and (optionally) saving it to a pickle file.

    Dependencies:
        - `import numpy as np`
        - `import pandas as pd` (if `make_PandasDF = True`)
        - `import pickle` (if `save_output_pickle = True`)
        - `from munch import *`
        - `from pathlib import Path`

    Inputs:
       (required)

        - `tally_output_filepath` = file or filepath to the tally output file to be parsed

    Inputs:
       (optional)

       - `make_PandasDF` = A Boolean determining whether a Pandas dataframe of the tally data array will be made (D=`True`)
       - `calculate_absolute_errors` = A Boolean determining whether the absolute uncertainty of each tally output value
                      is to be calculated (simply as the product of the value and relative error); if `False`, the final
                      dimension of `tally_data`, `ierr`, will be of length-2 rather than length-3 (D=`True`)
       - `save_output_pickle` = A Boolean determining whether the `tally_output` dictionary object is saved as a pickle file;
                      if `True`, the file will be saved with the same path and name as the provided PHITS tally output file
                      but with the .pickle extension. (D=`True`)
       - `prefer_reading_existing_pickle` = A Boolean determining what this function does if the pickle file this function
                      seeks to generate already exists.  If `False` (default behavior), this function will parse the PHITS
                      output files as usual and overwrite the existing pickle file.  If `True`, this function will instead
                      simply just read the existing found pickle file and return its stored `tally_output` contents. (D=`False`)

    Output:
        - `tally_output` = a dictionary object with the below keys and values:
            - `&#39;tally_data&#39;` = a 10-dimensional NumPy array containing all tally results, explained in more detail below
            - `&#39;tally_metadata&#39;` = a dictionary/Munch object with various data extracted from the tally output file, such as axis binning and units
            - `&#39;tally_dataframe&#39;` = (optionally included if setting `make_PandasDF = True`) a Pandas dataframe version of `tally_data`


    Notes:

       Many quantities can be scored across the various tallies in the PHITS code.  This function outputs a &#34;universal&#34;
       array `tally_data` that can accomodate all of the different scoring geometry meshes, physical quantities with
       assigned meshes, and output axes provided within PHITS.  This is achieved with a 10-dimensional array accessible as

       `tally_data[ ir, iy, iz, ie, it, ia, il, ip, ic, ierr ]`, with indices explained below:

       Tally data indices and corresponding mesh/axis:

        - `0` | `ir`, Geometry mesh: `reg` / `x` / `r` / `tet` ([T-Cross] `ir surf` if `mesh=r-z` with `enclos=0`)
        - `1` | `iy`, Geometry mesh:  `1` / `y` / `1`
        - `2` | `iz`, Geometry mesh:  `1` / `z` / `z` ([T-Cross] `iz surf` if `mesh=xyz` or `mesh=r-z` with `enclos=0`)
        - `3` | `ie`, Energy mesh: `eng` ([T-Deposit2] `eng1`)
        - `4` | `it`, Time mesh
        - `5` | `ia`, Angle mesh
        - `6` | `il`, LET mesh
        - `7` | `ip`, Particle type (`part = `)
        - `8` | `ic`, Special: [T-Deposit2] `eng2`; [T-Yield] `mass`, `charge`, `chart`; [T-Interact] `act`
        - `9` | `ierr = 0/1/2`, Value / relative uncertainty / absolute uncertainty (expanded to `3/4/5`, or `2/3` if
        `calculate_absolute_errors = False`, for [T-Cross] `mesh=r-z` with `enclos=0` case; see notes further below)

       -----

       By default, all array dimensions are length-1 (except `ierr`, which is length-3).  These dimensions are set/corrected
       automatically when parsing the tally output file.  Thus, for very simple tallies, most of these indices will be
       set to 0 when accessing tally results, e.g. `tally_data[2,0,0,:,0,0,0,:,0,:]` to access the full energy spectrum
       in the third region for all scored particles / particle groups with the values and uncertainties.

       The output `tally_metadata` dictionary contains all information needed to identify every bin along every
       dimension: region numbers/groups, particle names/groups, bin edges and midpoints for all mesh types
       (x, y, z, r, energy, angle, time, and LET) used in the tally.

       The `tally_dataframe` Pandas dataframe output functions as normal.  Note that a dictionary containing supplemental
       information that is common to all rows of the dataframe can be accessed with `tally_dataframe.attrs`.

       -----

       **Unsupported tallies and DCHAIN**

       At present, the following tallies are NOT supported by this function: [T-WWG], [T-WWBG], [T-Volume],
       [T-Userdefined], [T-Gshow], [T-Rshow], [T-3Dshow], [T-4Dtrack], and [T-Dchain]&amp;dagger;.

       &amp;dagger;If provided with the output file of [T-Dchain] (the input file for the DCHAIN code) or the `*.act` main
       output file produced by the DCHAIN code, this function will attempt to import the [DCHAIN Tools module](https://github.com/Lindt8/DCHAIN-Tools)
       and process the found DCHAIN output files, returning the output dictionary object and (optionally) saving it to a pickle file.
       Otherwise, for [T-Dchain] or [T-Yield] with `axis = dchain`, you can manually use the separate suite of parsing
       functions included in the [DCHAIN Tools](https://github.com/Lindt8/DCHAIN-Tools) module.

       -----

       **[T-Cross] special case**

       The [T-Cross] tally is unique (scoring across region boundaries rather than within regions), creating some
       additional challenges.
       In the `mesh = reg` case, much is the same except each region number is composed of the `r-from` and `r-to` values, e.g. `&#39;100 - 101&#39;`.

       For `xyz` and `r-z` meshes, an additional parameter is at play: `enclos`.
       By default, `enclos=0`.
       In the event `enclos=1` is set, the total number of geometric regions is still either `nx*ny*nz` or `nr*nz` for
       `xyz` and `r-z` meshes, respectively.
       For `enclos=0` in the `mesh = xyz` case, the length of the z dimension (`iz` index) is instead equal to `nzsurf`,
       which is simply one greater than `nz` (# regions = `nx*ny*(nz+1)`).

       For `enclos=0` in the `mesh = r-z` case, this is much more complicated as PHITS will output every combination of
       `nr*nzsurf` AND `nrsurf*nz`, noting `nzsurf=nz+1` and `nrsurf=nr+1` (or `nrsurf=nr` if the first radius bin edge
       is `r=0.0`).
       The solution implemented here is to, for only this circumstance (in only the `enclos=0 mesh=r-z` case),
       set the length of the `ir` and `iz` dimensions to `nrsurf` and `nzsurf`, respectively, and also
       to expand the length of the final dimension of `tally_data` from 3 to 6 (or from 2 to 4 if `calculate_absolute_errors=False`), where:

        - `ierr = 0/1/2` refer to the combinations of `nr` and `nzsurf` (or `0/1` if `calculate_absolute_errors=False`)
        - `ierr = 3/4/5` refer to the combinations of `nrsurf` and `nz` (or `2/3` if `calculate_absolute_errors=False`)

       In this case, the Pandas dataframe, if enabled, will contain 3 (or 2) extra columns `value2` and `rel.err.2` [and `abs.err.2`],
       which correspond to the combinations of `nrsurf` and `nz` (while the original columns without the &#34;2&#34; refer to
       values for combinations of and `nr` and `nzsurf`).

       -----

       **[T-Yield] special case**

       [T-Yield] is also a bit exceptional.  When setting the `axis` parameter equal to `charge`, `mass`, or `chart`,
       the `ic` dimension of `tally_data` is used for each entry of charge (proton number, Z), mass (A), or
       isotope/isomer, respectively.

       In the case of `axis = charge` or `axis = mass`, the value of `ic` refers to the actual charge/proton number Z
       or mass number A when accessing `tally_data`; for instance, `tally_data[:,:,:,:,:,:,:,:,28,:]`
       references results from nuclei with Z=28 if `axis = charge` or A=28 if `axis = mass`.  The length of the `ic`
       dimension is initialized as 130 or 320 but is later reduced to only just include the highest charge or mass value.

       In the case of `axis = chart`, the length of the `ic` dimension is initially set equal to the `mxnuclei` parameter
       in the [T-Yield] tally.  If `mxnuclei = 0` is set, then the length of the `ic` dimension is initially set to 10,000.
       This `ic` dimension length is later reduced to the total number of unique nuclides found in the output.
       Owing to the huge number of possible nuclides, a list of found nuclides with nonzero yield is assembled and
       added to `tally_metadata` under the keys `nuclide_ZZZAAAM_list` and `nuclide_isomer_list`, i.e.
       `tally_metadata[&#39;nuclide_ZZZAAAM_list&#39;]` and `tally_metadata[&#39;nuclide_isomer_list&#39;]`.
       These lists should be referenced to see what nuclide each of index `ic` refers to.
       The entries of the ZZZAAAM list are intergers calculated with the formula 10000\*Z + 10\*A + M, where M is the
       metastable state of the isomer (0 = ground state, 1 = 1st metastable/isomeric state, etc.).  The entries
       of the isomer list are these same nuclides in the same order but written as plaintext strings, e.g. `&#39;Al-28&#39;` and `&#39;Xe-133m1&#39;`.
       The lists are ordered in the same order nuclides are encountered while parsing the output file.
       Thus, to sensibly access the yield of a specific nuclide, one must first find its index `ic` in one of the two
       metadata lists of ZZZAAAM values or isomer names and then use that to access `tally_data`.  For example, to get
       the yield results of production of carbon-14 (C-14), one would use the following code:

       `ic = tally_metadata[&#39;nuclide_ZZZAAAM_list&#39;].index(60140)`

       OR

       `ic = tally_metadata[&#39;nuclide_isomer_list&#39;].index(&#39;C-14&#39;)`

       then

       `my_yield_values = tally_data[:,:,:,:,:,:,:,:,ic,:]`


    &#39;&#39;&#39;

    &#39;&#39;&#39;
    The old [T-Cross] mesh=r-z enclos=0 solution is written below:
        The solution implemented here uses `ir` to iterate `nr`, `iy` to iterate `nrsurf`, `iz` to
        iterate `nz`, and `ic` to iterate `nzsurf`.  Since only `rsurf*z [iy,iz]` and `r*zsurf [ir,ic]` pairs exist,
        when one pair is being written, the other will be `[-1,-1]`, thus the lengths of these dimensions for the array
        are increased by an extra 1 to prevent an overlap in the data written.
    &#39;&#39;&#39;
    pickle_filepath = Path(tally_output_filepath.parent, tally_output_filepath.stem + &#39;.pickle&#39;)
    if prefer_reading_existing_pickle and os.path.isfile(pickle_filepath):
        import pickle
        print(&#39;Reading found pickle file: &#39;, pickle_filepath)
        with open(pickle_filepath, &#39;rb&#39;) as handle:
            tally_output = pickle.load(handle)
        return tally_output

    # main toggled settings
    #calculate_absolute_errors = True
    construct_Pandas_frame_from_array = make_PandasDF
    #process_all_tally_out_files_in_directory = False
    save_pickle_files_of_output = save_output_pickle  # save metadata, array, and Pandas frame in a pickled dictionary object

    if construct_Pandas_frame_from_array: import pandas as pd

    # Check if is _err or _dmp file (or normal value file)
    is_val_file = False
    is_err_file = False
    is_dmp_file = False
    if tally_output_filepath.stem[-4:] == &#39;_err&#39;:
        is_err_file = True
    elif tally_output_filepath.stem[-4:] == &#39;_dmp&#39;:
        is_dmp_file = True
    else:
        is_val_file = True

    if is_dmp_file:
        print(&#39;ERROR: The provided file is a &#34;dump&#34; output file. Use the function titled &#34;parse_tally_dump_file&#34; to process it instead.&#39;)
        return None

    if is_err_file:
        print(&#39;WARNING: Provided file contains just relative uncertainties.&#39;,str(tally_output_filepath))
        potential_val_file = Path(tally_output_filepath.parent, tally_output_filepath.stem.replace(&#39;_err&#39;,&#39;&#39;) + tally_output_filepath.suffix)
        if potential_val_file.is_file():
            print(&#39;\t Instead, both it and the file with tally values will be parsed.&#39;)
            potential_err_file = tally_output_filepath
            tally_output_filepath = potential_val_file
            is_val_file = True
            is_err_file = False
        else:
            print(&#39;\t The corresponding file with tally values could not be found, so only these uncertainties will be parsed.&#39;)

    # Split content of output file into header and content
    if in_debug_mode: print(&#34;\nSplitting output into header and content...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    tally_header, tally_content = split_into_header_and_content(tally_output_filepath)
    if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    # print(len(tally_content))

    # Check if *_err file exists
    potential_err_file = Path(tally_output_filepath.parent, tally_output_filepath.stem + &#39;_err&#39; + tally_output_filepath.suffix)
    is_err_in_separate_file = potential_err_file.is_file()  # for some tallies/meshes, uncertainties are stored in a separate identically-formatted file

    # Extract tally metadata
    if in_debug_mode: print(&#34;\nExtracting tally metadata...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    tally_metadata = parse_tally_header(tally_header, tally_content)
    if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    if in_debug_mode: pprint.pp(dict(tally_metadata))
    # Check if tally_type is among those supported.
    unsupported_tally_types = [&#39;[T-WWG]&#39;, &#39;[T-WWBG]&#39;, &#39;[T-Volume]&#39;, &#39;[T-Userdefined]&#39;, &#39;[T-Gshow]&#39;, &#39;[T-Rshow]&#39;,
                               &#39;[T-3Dshow]&#39;, &#39;[T-4Dtrack]&#39;, &#39;[T-Dchain]&#39;, &#39;UNKNOWN&#39;]
    if tally_metadata[&#39;tally_type&#39;] in unsupported_tally_types:
        print(&#39;ERROR! tally type&#39;,tally_metadata[&#39;tally_type&#39;],&#39;is not supported by this function!&#39;)
        if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Dchain]&#39; or tally_output_filepath.suffix == &#39;.act&#39;:
            print(&#39;Instead, the DCHAIN Tools module is used to process the DCHAIN output files with the same basename of the provided file.&#39;)
            dchain_tools_url = &#39;github.com/Lindt8/DCHAIN-Tools&#39;
            dchain_tools_go_to_github_str = &#39;The DCHAIN Tools module ( &#39;+dchain_tools_url+&#39; ) is capable of parsing all DCHAIN-related output.&#39;
            if tally_output_filepath.suffix != &#39;.act&#39;:
                act_filepath = Path(tally_output_filepath.parent, tally_output_filepath.stem + &#39;.act&#39;)
                if not act_filepath.is_file():
                    # DCHAIN output is not present in directory
                    print(&#39;Failed to find the main DCHAIN *.act output file:&#39;,act_filepath)
                    print(&#39;Aborting this process...&#39;)
                    return None
            try:
                from dchain_tools import process_dchain_simulation_output
            except:
                print(&#39;Failed to import the DCHAIN Tools module; to parse DCHAIN output via PHITS Tools, please install DCHAIN Tools and configure it in your Python environment&#39;)
                return None
            simulation_folder_path = str(Path(tally_output_filepath.parent)) + &#39;\\&#39;
            simulation_basename = str(tally_output_filepath.stem)
            dchain_output = process_dchain_simulation_output(simulation_folder_path,simulation_basename,process_DCS_file=True)
            if save_output_pickle:
                import pickle
                path_to_pickle_file = Path(tally_output_filepath.parent, tally_output_filepath.stem + &#39;.pickle&#39;)
                if in_debug_mode: print(&#34;\nWriting output to pickle file...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
                with open(path_to_pickle_file, &#39;wb&#39;) as handle:
                    pickle.dump(dchain_output, handle, protocol=pickle.HIGHEST_PROTOCOL)
                    print(&#39;Pickle file written:&#39;, path_to_pickle_file, &#39;\n&#39;)
                if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
            return dchain_output
        else:
            return None
    if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Yield]&#39; and tally_metadata[&#39;axis&#39;] == &#39;dchain&#39;:
        dchain_tools_url = &#39;github.com/Lindt8/DCHAIN-Tools&#39;
        print(&#39;This function does not support [T-Yield] with setting &#34;axis = dchain&#34;.&#39;)
        print(&#39;However, the DCHAIN Tools module (&#39;, dchain_tools_url, &#39;) is capable of parsing all DCHAIN-related output.&#39;)
        return None

    # Initialize tally data array with zeros
    tally_data = initialize_tally_array(tally_metadata, include_abs_err=calculate_absolute_errors)

    # Parse tally data
    if is_val_file:
        err_mode = False
    else: # if is_err_file
        err_mode = True
    if in_debug_mode: print(&#34;\nParsing tally data...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    if tally_metadata[&#39;tally_type&#39;]==&#39;[T-Yield]&#39; and tally_metadata[&#39;axis&#39;] in [&#39;chart&#39;,&#39;charge&#39;,&#39;mass&#39;]: # need to update metadata too
        tally_data, tally_metadata = parse_tally_content(tally_data, tally_metadata, tally_content, is_err_in_separate_file, err_mode=err_mode)
    else:
        tally_data = parse_tally_content(tally_data, tally_metadata, tally_content, is_err_in_separate_file, err_mode=err_mode)
    if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    err_data_found = True
    if tally_metadata[&#39;axis_dimensions&#39;] == 2 and tally_metadata[&#39;2D-type&#39;] != 4:
        if is_err_file:
            err_data_found = False
        elif is_err_in_separate_file:
            err_tally_header, err_tally_content = split_into_header_and_content(potential_err_file)
            if in_debug_mode: print(&#34;\nParsing tally error...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
            if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Yield]&#39; and tally_metadata[&#39;axis&#39;] in [&#39;chart&#39;,&#39;charge&#39;,&#39;mass&#39;]:  # need to update metadata too
                tally_data, tally_metadata = parse_tally_content(tally_data, tally_metadata, err_tally_content, is_err_in_separate_file,err_mode=True)
            else:
                tally_data = parse_tally_content(tally_data, tally_metadata, err_tally_content, is_err_in_separate_file, err_mode=True)
            if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
        else:
            print(&#39;WARNING: A separate file ending in &#34;_err&#34; containing uncertainties should exist but was not found.&#39;)
            err_data_found = False
    if calculate_absolute_errors:
        if err_data_found:
            if in_debug_mode: print(&#34;\nCalculating absolute errors...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
            tally_data = calculate_tally_absolute_errors(tally_data)
            if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
        elif is_err_file:
            print(&#39;WARNING: Absolute errors not calculated since the main tally values file was not found.&#39;)
        else:
            print(&#39;WARNING: Absolute errors not calculated since the _err file was not found.&#39;)
    # Generate Pandas dataframe of tally results
    if construct_Pandas_frame_from_array:
        if in_debug_mode: print(&#34;\nConstructing Pandas dataframe...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
        tally_Pandas_df = build_tally_Pandas_dataframe(tally_data, tally_metadata)
        if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    else:
        tally_Pandas_df = None

    tally_output = {
        &#39;tally_data&#39;: tally_data,
        &#39;tally_metadata&#39;: tally_metadata,
        &#39;tally_dataframe&#39;: tally_Pandas_df,
    }

    if save_output_pickle:
        import pickle
        path_to_pickle_file = Path(tally_output_filepath.parent, tally_output_filepath.stem + &#39;.pickle&#39;)
        if in_debug_mode: print(&#34;\nWriting output to pickle file...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
        with open(path_to_pickle_file, &#39;wb&#39;) as handle:
            pickle.dump(tally_output, handle, protocol=pickle.HIGHEST_PROTOCOL)
            print(&#39;Pickle file written:&#39;, path_to_pickle_file, &#39;\n&#39;)
        if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))

    return tally_output</code></pre>
</details>
</dd>
<dt id="PHITS_tools.parse_tally_dump_file"><code class="name flex">
<span>def <span class="ident">parse_tally_dump_file</span></span>(<span>path_to_dump_file, dump_data_number=None, dump_data_sequence=None, return_directional_info=False, use_degrees=False, max_entries_read=None, return_namedtuple_list=True, return_Pandas_dataframe=True, save_namedtuple_list=False, save_Pandas_dataframe=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Parses the dump file of a [T-Cross], [T-Product], or [T-Time] tally generated by PHITS, in ASCII or binary format.</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code>from collections import namedtuple</code></li>
<li><code>from scipy.io import FortranFile</code></li>
<li><code>import pandas as pd</code> (if <code>return_Pandas_dataframe = True</code>)</li>
<li><code>import dill</code> (if <code>save_namedtuple_list = True</code>)</li>
<li><code>import lzma</code> (if <code>save_namedtuple_list = True</code>)</li>
</ul>
<h2 id="inputs">Inputs</h2>
<p>(required)</p>
<ul>
<li><code>path_to_dump_file</code> = string or Path object denoting the path to the dump tally output file to be parsed</li>
<li><code>dump_data_number</code> = integer number of data per row in dump file, binary if &gt;0 and ASCII if &lt;0.
This should match the value following <code>dump=</code> in the tally creating the dump file. (D=<code>None</code>)
If not specified, the search_for_dump_parameters() function will attempt to find it automatically.</li>
<li><code>dump_data_sequence</code> = string or list of integers with the same number of entries as <code>dump_data_number</code>,
mapping each column in the dump file to their physical quantities.
(D=<code>None</code>)
This should match the line following the <code>dump=</code> line in the tally creating the dump file.
See PHITS manual section "6.7.22 dump parameter" for further explanations of these values.
If not specified, the search_for_dump_parameters() function will attempt to find it automatically.</li>
</ul>
<h2 id="inputs_1">Inputs</h2>
<p>(optional)</p>
<ul>
<li><code>return_directional_info</code> = (optional, D=<code>False</code>) Boolean designating whether extra directional information
should be calculated and returned; these include: radial distance <code>r</code> from the origin in cm,
radial distance <code>rho</code> from the z-axis in cm,
polar angle <code>theta</code> between the direction vector and z-axis in radians [0,pi] (or degrees), and
azimuthal angle <code>phi</code> of the direction vector in radians [-pi,pi] (or degrees).
Note: This option requires all position and direction values [x,y,z,u,v,w] to be included in the dump file.</li>
<li><code>use_degrees</code> = (optional, D=<code>False</code>) Boolean designating whether angles <code>theta</code> and <code>phi</code> are returned
in units of degrees. Default setting is to return angles in radians.</li>
<li><code>max_entries_read</code> = (optional, D=<code>None</code>) integer number specifying the maximum number of entries/records
of the dump file to be read.
By default, all records in the dump file are read.</li>
<li><code>return_namedtuple_list</code> = (optional, D=<code>True</code>) Boolean designating whether <code>dump_data_list</code> is returned.</li>
<li><code>return_Pandas_dataframe</code> = (optional, D=<code>True</code>) Boolean designating whether <code>dump_data_frame</code> is returned.</li>
<li><code>save_namedtuple_list</code> = (optional, D=<code>False</code>) Boolean designating whether <code>dump_data_list</code> is saved to a dill file,
which will be compressed with LZMA (built-in with Python)
(for complicated reasons, objects containing namedtuples cannot be easily saved with pickle but can with dill).
This *.dill.xz file can then be opened (after importing <code>dill</code> and <code>lzma</code>) as:
<code>with lzma.open(path_to_dillxz_file, 'rb') as file: dump_data_list = dill.load(file)</code></li>
<li><code>save_Pandas_dataframe</code> = (optional, D=<code>False</code>) Boolean designating whether <code>dump_data_frame</code> is saved to a pickle
file (via Pandas .to_pickle()).</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>dump_data_list</code> = List of length equal to the number of records contained in the file. Each entry in the list
is a namedtuple containing all of the physical information in the dump file for a given particle event,
in the same order as specified in <code>dump_data_sequence</code> and using the same naming conventions for keys as
described in the PHITS manual section "6.7.22 dump parameter"
(<code>kf</code>, <code>x</code>, <code>y</code>, <code>z</code>, <code>u</code>, <code>v</code>, <code>w</code>, <code>e</code>, <code>wt</code>, <code>time</code>, <code>c1</code>, <code>c2</code>, <code>c3</code>, <code>sx</code>, <code>sy</code>, <code>sz</code>, <code>name</code>, <code>nocas</code>, <code>nobch</code>, <code>no</code>).
If <code>return_directional_info = True</code>, <code>r</code>, <code>rho</code>, <code>theta</code>, and <code>phi</code> are appended to the end of this namedtuple, in that order.</li>
<li><code>dump_data_frame</code> = A Pandas dataframe created from <code>dump_data_list</code> with columns for each physical quantity
and rows for each record included in the dump file.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_tally_dump_file(path_to_dump_file, dump_data_number=None , dump_data_sequence=None, return_directional_info=False,
                          use_degrees=False,max_entries_read=None,return_namedtuple_list=True,
                          return_Pandas_dataframe=True, save_namedtuple_list=False, save_Pandas_dataframe=False):
    &#39;&#39;&#39;
    Description:
        Parses the dump file of a [T-Cross], [T-Product], or [T-Time] tally generated by PHITS, in ASCII or binary format.

    Dependencies:
        - `from collections import namedtuple`
        - `from scipy.io import FortranFile`
        - `import pandas as pd` (if `return_Pandas_dataframe = True`)
        - `import dill` (if `save_namedtuple_list = True`)
        - `import lzma` (if `save_namedtuple_list = True`)

    Inputs:
       (required)

        - `path_to_dump_file` = string or Path object denoting the path to the dump tally output file to be parsed
        - `dump_data_number` = integer number of data per row in dump file, binary if &gt;0 and ASCII if &lt;0.
                 This should match the value following `dump=` in the tally creating the dump file. (D=`None`)
                 If not specified, the search_for_dump_parameters() function will attempt to find it automatically.
        - `dump_data_sequence` = string or list of integers with the same number of entries as `dump_data_number`,
                 mapping each column in the dump file to their physical quantities.  (D=`None`)
                 This should match the line following the `dump=` line in the tally creating the dump file.
                 See PHITS manual section &#34;6.7.22 dump parameter&#34; for further explanations of these values.
                 If not specified, the search_for_dump_parameters() function will attempt to find it automatically.

    Inputs:
       (optional)

        - `return_directional_info` = (optional, D=`False`) Boolean designating whether extra directional information
                 should be calculated and returned; these include: radial distance `r` from the origin in cm,
                 radial distance `rho` from the z-axis in cm,
                 polar angle `theta` between the direction vector and z-axis in radians [0,pi] (or degrees), and
                 azimuthal angle `phi` of the direction vector in radians [-pi,pi] (or degrees).
                 Note: This option requires all position and direction values [x,y,z,u,v,w] to be included in the dump file.
        - `use_degrees` = (optional, D=`False`) Boolean designating whether angles `theta` and `phi` are returned
                 in units of degrees. Default setting is to return angles in radians.
        - `max_entries_read` = (optional, D=`None`) integer number specifying the maximum number of entries/records
                 of the dump file to be read.  By default, all records in the dump file are read.
        - `return_namedtuple_list` = (optional, D=`True`) Boolean designating whether `dump_data_list` is returned.
        - `return_Pandas_dataframe` = (optional, D=`True`) Boolean designating whether `dump_data_frame` is returned.
        - `save_namedtuple_list` = (optional, D=`False`) Boolean designating whether `dump_data_list` is saved to a dill file,
                which will be compressed with LZMA (built-in with Python)
                (for complicated reasons, objects containing namedtuples cannot be easily saved with pickle but can with dill).
                This *.dill.xz file can then be opened (after importing `dill` and `lzma`) as:
                `with lzma.open(path_to_dillxz_file, &#39;rb&#39;) as file: dump_data_list = dill.load(file)`
        - `save_Pandas_dataframe` = (optional, D=`False`) Boolean designating whether `dump_data_frame` is saved to a pickle
                file (via Pandas .to_pickle()).

    Outputs:
        - `dump_data_list` = List of length equal to the number of records contained in the file. Each entry in the list
                 is a namedtuple containing all of the physical information in the dump file for a given particle event,
                 in the same order as specified in `dump_data_sequence` and using the same naming conventions for keys as
                 described in the PHITS manual section &#34;6.7.22 dump parameter&#34;
                 (`kf`, `x`, `y`, `z`, `u`, `v`, `w`, `e`, `wt`, `time`, `c1`, `c2`, `c3`, `sx`, `sy`, `sz`, `name`, `nocas`, `nobch`, `no`).
                 If `return_directional_info = True`, `r`, `rho`, `theta`, and `phi` are appended to the end of this namedtuple, in that order.
        - `dump_data_frame` = A Pandas dataframe created from `dump_data_list` with columns for each physical quantity
                 and rows for each record included in the dump file.
    &#39;&#39;&#39;

    from collections import namedtuple
    from typing import NamedTuple
    from scipy.io import FortranFile
    if return_Pandas_dataframe or save_Pandas_dataframe:
        import pandas as pd
    if save_Pandas_dataframe or save_namedtuple_list:
        #import pickle
        import dill

    if not return_namedtuple_list and not return_Pandas_dataframe and not save_namedtuple_list and not save_Pandas_dataframe:
        raise ValueError(&#39;ERROR: All &#34;return_namedtuple_list&#34;, &#34;return_Pandas_dataframe&#34;, &#34;save_namedtuple_list&#34;, and &#34;save_Pandas_dataframe&#34; are False. Enable at least one to use this function.&#39;)

    if dump_data_number == None or dump_data_sequence == None:
        dump_data_number, dump_data_sequence = search_for_dump_parameters(path_to_dump_file)
    if dump_data_number == None or dump_data_sequence == None:
        raise ValueError(&#34;Please manually specify &#39;dump_data_number&#39; and &#39;dump_data_sequence&#39;; these were not inputted and could not be automatically found from an origin tally standard output file.&#34;)
        #return None

    if isinstance(dump_data_sequence, str):
        dump_data_sequence = dump_data_sequence.split()
        dump_data_sequence = [int(i) for i in dump_data_sequence]
    dump_file_is_binary = True if (dump_data_number &gt; 0) else False  # if not binary, file will be ASCII
    data_values_per_line = abs(dump_data_number)
    if data_values_per_line != len(dump_data_sequence):
        raise ValueError(&#39;ERROR: Number of values in &#34;dump_data_sequence&#34; is not equal to &#34;dump_data_number&#34;&#39;)

    # Generate NamedTuple for storing record information
    # See PHITS manual section &#34;6.7.22 dump parameter&#34; for descriptions of these values
    dump_quantities = [&#39;kf&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;e&#39;, &#39;wt&#39;, &#39;time&#39;, &#39;c1&#39;, &#39;c2&#39;, &#39;c3&#39;, &#39;sx&#39;, &#39;sy&#39;, &#39;sz&#39;,
                       &#39;name&#39;, &#39;nocas&#39;, &#39;nobch&#39;, &#39;no&#39;]
    ordered_record_entries_list = [dump_quantities[i - 1] for i in dump_data_sequence]
    rawRecord = namedtuple(&#39;rawRecord&#39;, ordered_record_entries_list)
    if return_directional_info:
        ordered_record_entries_list += [&#39;r&#39;, &#39;rho&#39;, &#39;theta&#39;, &#39;phi&#39;]
        angle_units_mult = 1
        if use_degrees: angle_units_mult = 180 / np.pi
    Record = namedtuple(&#39;Record&#39;, ordered_record_entries_list)

    records_list = []
    if dump_file_is_binary:
        # Read binary dump file; extract each record (particle)
        file_size_bytes = os.path.getsize(path_to_dump_file)
        record_size_bytes = (data_values_per_line + 1) * 8  # each record has 8 bytes per data value plus an 8-byte record end
        num_records = int(file_size_bytes / record_size_bytes)
        if max_entries_read != None:
            if max_entries_read &lt; num_records:
                num_records = max_entries_read
        # print(num_records)
        current_record_count = 0
        if return_directional_info:
            with FortranFile(path_to_dump_file, &#39;r&#39;) as f:
                while current_record_count &lt; num_records:
                    current_record_count += 1
                    raw_values = f.read_reals(float)
                    rawrecord = rawRecord(*raw_values)
                    # calculate r, rho, theta (w.r.t. z-axis), and phi (w.r.t. x axis)
                    r = np.sqrt(rawrecord.x ** 2 + rawrecord.y ** 2 + rawrecord.z ** 2)
                    rho = np.sqrt(rawrecord.x ** 2 + rawrecord.y ** 2)
                    dir_vector = [rawrecord.u, rawrecord.v, rawrecord.w]
                    theta = np.arccos(np.clip(np.dot(dir_vector, [0, 0, 1]), -1.0, 1.0)) * angle_units_mult
                    phi = np.arctan2(rawrecord.y, rawrecord.x) * angle_units_mult
                    record = Record(*raw_values, r, rho, theta, phi)
                    records_list.append(record)
        else: # just return data in dump file
            with FortranFile(path_to_dump_file, &#39;r&#39;) as f:
                while current_record_count &lt; num_records:
                    current_record_count += 1
                    raw_values = f.read_reals(float)
                    record = Record(*raw_values)
                    records_list.append(record)
    else: # file is ASCII
        if max_entries_read == None:
            max_entries_read = np.inf
        if return_directional_info:
            with open(path_to_dump_file, &#39;r&#39;) as f:
                current_record_count = 0
                for line in f:
                    current_record_count += 1
                    if current_record_count &gt; max_entries_read: break
                    line_str_values = line.replace(&#39;D&#39;, &#39;E&#39;).split()
                    raw_values = [float(i) for i in line_str_values]
                    rawrecord = rawRecord(*raw_values)
                    # calculate r, rho, theta (w.r.t. z-axis), and phi (w.r.t. x axis)
                    r = np.sqrt(rawrecord.x ** 2 + rawrecord.y ** 2 + rawrecord.z ** 2)
                    rho = np.sqrt(rawrecord.x ** 2 + rawrecord.y ** 2)
                    dir_vector = [rawrecord.u, rawrecord.v, rawrecord.w]
                    theta = np.arccos(np.clip(np.dot(dir_vector, [0, 0, 1]), -1.0, 1.0)) * angle_units_mult
                    phi = np.arctan2(rawrecord.y, rawrecord.x) * angle_units_mult
                    record = Record(*raw_values, r, rho, theta, phi)
                    records_list.append(record)
        else: # just return data in dump file
            with open(path_to_dump_file, &#39;r&#39;) as f:
                current_record_count = 0
                for line in f:
                    current_record_count += 1
                    if current_record_count &gt; max_entries_read: break
                    line_str_values = line.replace(&#39;D&#39;, &#39;E&#39;).split()
                    raw_values = [float(i) for i in line_str_values]
                    record = Record(*raw_values)
                    records_list.append(record)
    #print(record)

    if save_namedtuple_list:
        import lzma
        path_to_dump_file = Path(path_to_dump_file)
        pickle_path = Path(path_to_dump_file.parent, path_to_dump_file.stem + &#39;_namedtuple_list.dill.xz&#39;)
        with lzma.open(pickle_path, &#39;wb&#39;) as handle:
            dill.dump(records_list, handle, protocol=dill.HIGHEST_PROTOCOL)
            print(&#39;Pickle file written:&#39;, pickle_path, &#39;\n&#39;)

    if return_Pandas_dataframe or save_Pandas_dataframe:
        # Make Pandas dataframe from list of records
        records_df = pd.DataFrame(records_list, columns=Record._fields)
        if save_Pandas_dataframe:
            path_to_dump_file= Path(path_to_dump_file)
            pickle_path = Path(path_to_dump_file.parent, path_to_dump_file.stem + &#39;_Pandas_df.pickle&#39;)
            records_df.to_pickle(pickle_path)
            #with open(pickle_path, &#39;wb&#39;) as handle:
            #    pickle.dump(records_df, handle, protocol=pickle.HIGHEST_PROTOCOL)
            #    print(&#39;Pickle file written:&#39;, pickle_path, &#39;\n&#39;)

    if return_namedtuple_list and return_Pandas_dataframe:
        return records_list, records_df
    elif return_namedtuple_list:
        return records_list
    elif return_Pandas_dataframe:
        return records_df
    else:
        return None</code></pre>
</details>
</dd>
<dt id="PHITS_tools.parse_all_tally_output_in_dir"><code class="name flex">
<span>def <span class="ident">parse_all_tally_output_in_dir</span></span>(<span>tally_output_dirpath, output_file_suffix='.out', output_file_prefix='', output_file_required_string='', include_subdirectories=False, return_tally_output=False, make_PandasDF=True, calculate_absolute_errors=True, save_output_pickle=True, prefer_reading_existing_pickle=False, include_dump_files=False, dump_data_number=None, dump_data_sequence=None, dump_return_directional_info=False, dump_use_degrees=False, dump_max_entries_read=None, dump_save_namedtuple_list=True, dump_save_Pandas_dataframe=True)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Parse all standard PHITS tally output files in a directory, returning either a list of dictionaries containing
tally metadata and an array of values from each tally output (and optionally this data inside of a Pandas dataframe too)
or a list of filepaths to pickle files containing these dictionaries, as created with the <code><a title="PHITS_tools.parse_tally_output_file" href="#PHITS_tools.parse_tally_output_file">parse_tally_output_file()</a></code> function.
This function allows selective processing of files in the directory by specification of strings which must
appear at the start, end, and/or anywhere within each filename.
Even if a file satisfies all of these naming criteria, the function will also check the first line of the file
to determine if it is a valid tally output file (meaning, it will skip files such as phits.out and batch.out).
It will also skip over "_err" uncertainty files as these are automatically found by the <code><a title="PHITS_tools.parse_tally_output_file" href="#PHITS_tools.parse_tally_output_file">parse_tally_output_file()</a></code>
function after it processes that tally's main output file.
This function will mainly process standard tally output files, but it can optionally process tally "dump" files too,
though it can only save the dump outputs to its dill/pickle files and not return the (quite large) dump data objects.
The filenames of saved dump data will not be included in the returned list.</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code>import os</code></li>
<li><code>import numpy as np</code></li>
<li><code>import pandas as pd</code> (if <code>make_PandasDF = True</code>)</li>
<li><code>import pickle</code> (if <code>save_output_pickle = True</code>)</li>
<li><code>from munch import *</code></li>
<li><code>from pathlib import Path</code></li>
</ul>
<h2 id="inputs">Inputs</h2>
<p>(required)</p>
<ul>
<li><code>tally_output_dirpath</code> = Path (string or path object) to the tally output directory to be searched and parsed</li>
</ul>
<h2 id="inputs_1">Inputs</h2>
<p>(optional)</p>
<ul>
<li><code>output_file_suffix</code> = A string specifying what characters processed filenames (including the file extension)
must end in to be included.
This condition is not enforced if set to an empty string <code>''</code>. (D=<code>'.out'</code>)</li>
<li><code>output_file_prefix</code> = A string specifying what characters processed filenames (including the file extension)
must begin with to be included.
This condition is not enforced if set to an empty string <code>''</code>. (D=<code>''</code>)</li>
<li><code>output_file_required_string</code> = A string which must be present anywhere within processed filenames (including the
file extension) to be included.
This condition is not enforced if set to an empty string <code>''</code>. (D=<code>''</code>)</li>
<li><code>include_subdirectories</code> = A Boolean determining whether this function searches and processes all included
tally output files in this directory AND deeper subdirectories if set to <code>True</code>
or only the files directly within the provided directory <code>tally_output_dirpath</code> if set to <code>False</code> (D=<code>False</code>)</li>
<li><code>return_tally_output</code> = A Boolean determining whether this function returns a list of <code>tally_output</code> dictionaries
if set to <code>True</code> or just a list of filepaths to the pickle files containing these dictionaries
if set to <code>False</code> (D=<code>False</code>)</li>
<li><code>include_dump_files</code> = A Boolean determining whether dump files will be processed too or skipped. (D=<code>False</code>)
Settings to be applied to all encountered dump files can be specified per the optional inputs
detailed below which are simply passed to the <code><a title="PHITS_tools.parse_tally_dump_file" href="#PHITS_tools.parse_tally_dump_file">parse_tally_dump_file()</a></code> function.
Note that parameters
<code>return_namedtuple_list</code> and <code>return_Pandas_dataframe</code> will always be <code>False</code> when dump files are
processed in a directory with this function; instead, <code>save_namedtuple_list</code> and <code>save_Pandas_dataframe</code>
are by default set to <code>True</code> when parsing dump files in a directory with this function.
(Be warned,
if the dump file is large, the produced files from parsing them will be too.)</li>
</ul>
<h2 id="inputs_2">Inputs</h2>
<p>(optional, the same as in and directly passed to the <code><a title="PHITS_tools.parse_tally_output_file" href="#PHITS_tools.parse_tally_output_file">parse_tally_output_file()</a></code> function)</p>
<ul>
<li><code>make_PandasDF</code> = A Boolean determining whether a Pandas dataframe of the tally data array will be made (D=<code>True</code>)</li>
<li><code>calculate_absolute_errors</code> = A Boolean determining whether the absolute uncertainty of each tally output value
is to be calculated (simply as the product of the value and relative error); if <code>False</code>, the final
dimension of <code>tally_data</code>, <code>ierr</code>, will be of length-2 rather than length-3 (D=<code>True</code>)</li>
<li><code>save_output_pickle</code> = A Boolean determining whether the <code>tally_output</code> dictionary object is saved as a pickle file;
if <code>True</code>, the file will be saved with the same path and name as the provided PHITS tally output file
but with the .pickle extension. (D=<code>True</code>)</li>
<li><code>prefer_reading_existing_pickle</code> = A Boolean determining what this function does if the pickle file this function
seeks to generate already exists.
If <code>False</code> (default behavior), this function will parse the PHITS
output files as usual and overwrite the existing pickle file.
If <code>True</code>, this function will instead
simply just read the existing found pickle file and return its stored <code>tally_output</code> contents. (D=<code>False</code>)</li>
</ul>
<h2 id="inputs_3">Inputs</h2>
<p>(optional, the same as in and directly passed to the <code><a title="PHITS_tools.parse_tally_dump_file" href="#PHITS_tools.parse_tally_dump_file">parse_tally_dump_file()</a></code> function)</p>
<ul>
<li><code>dump_data_number</code> = integer number of data per row in dump file, binary if &gt;0 and ASCII if &lt;0.
This should match the value following <code>dump=</code> in the tally creating the dump file. (D=<code>None</code>)
If not specified, the search_for_dump_parameters() function will attempt to find it automatically.</li>
<li><code>dump_data_sequence</code> = string or list of integers with the same number of entries as <code>dump_data_number</code>,
mapping each column in the dump file to their physical quantities.
(D=<code>None</code>)
This should match the line following the <code>dump=</code> line in the tally creating the dump file.
See PHITS manual section "6.7.22 dump parameter" for further explanations of these values.
If not specified, the search_for_dump_parameters() function will attempt to find it automatically.</li>
<li><code>dump_return_directional_info</code> = (optional, D=<code>False</code>) Boolean designating whether extra directional information
should be calculated and returned; these include: radial distance <code>r</code> from the origin in cm,
radial distance <code>rho</code> from the z-axis in cm,
polar angle <code>theta</code> between the direction vector and z-axis in radians [0,pi] (or degrees), and
azimuthal angle <code>phi</code> of the direction vector in radians [-pi,pi] (or degrees).
Note: This option requires all position and direction values [x,y,z,u,v,w] to be included in the dump file.</li>
<li><code>dump_use_degrees</code> = (optional, D=<code>False</code>) Boolean designating whether angles <code>theta</code> and <code>phi</code> are returned
in units of degrees. Default setting is to return angles in radians.</li>
<li><code>dump_max_entries_read</code> = (optional, D=<code>None</code>) integer number specifying the maximum number of entries/records
of the dump file to be read.
By default, all records in the dump file are read.</li>
<li><code>dump_save_namedtuple_list</code> = (optional, D=<code>True</code>) Boolean designating whether <code>dump_data_list</code> is saved to a dill file
(for complicated reasons, objects containing namedtuples cannot be easily saved with pickle but can with dill).</li>
<li><code>dump_save_Pandas_dataframe</code> = (optional, D=<code>True</code>) Boolean designating whether <code>dump_data_frame</code> is saved to a pickle
file (via Pandas .to_pickle()).</li>
</ul>
<h2 id="output">Output</h2>
<ul>
<li><code>tally_output_list</code> = a list of <code>tally_output</code> dictionary objects with the below keys and values / a list of
file paths to pickle files containing <code>tally_output</code> dictionary objects:<ul>
<li><code>'tally_data'</code> = a 10-dimensional NumPy array containing all tally results, explained in more detail below</li>
<li><code>'tally_metadata'</code> = a dictionary/Munch object with various data extracted from the tally output file, such as axis binning and units</li>
<li><code>'tally_dataframe'</code> = (optionally included if setting <code>make_PandasDF = True</code>) a Pandas dataframe version of <code>tally_data</code></li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_all_tally_output_in_dir(tally_output_dirpath, output_file_suffix = &#39;.out&#39;, output_file_prefix = &#39;&#39;,
                                  output_file_required_string=&#39;&#39;, include_subdirectories=False,  return_tally_output=False,
                                  make_PandasDF=True, calculate_absolute_errors=True,
                                  save_output_pickle=True, prefer_reading_existing_pickle=False,
                                  include_dump_files=False,
                                  dump_data_number=None , dump_data_sequence=None,
                                  dump_return_directional_info=False, dump_use_degrees=False,
                                  dump_max_entries_read=None,
                                  dump_save_namedtuple_list=True, dump_save_Pandas_dataframe=True
                                  ):
    &#39;&#39;&#39;
    Description:
        Parse all standard PHITS tally output files in a directory, returning either a list of dictionaries containing
        tally metadata and an array of values from each tally output (and optionally this data inside of a Pandas dataframe too)
        or a list of filepaths to pickle files containing these dictionaries, as created with the `parse_tally_output_file()` function.
        This function allows selective processing of files in the directory by specification of strings which must
        appear at the start, end, and/or anywhere within each filename.
        Even if a file satisfies all of these naming criteria, the function will also check the first line of the file
        to determine if it is a valid tally output file (meaning, it will skip files such as phits.out and batch.out).
        It will also skip over &#34;_err&#34; uncertainty files as these are automatically found by the `parse_tally_output_file()`
        function after it processes that tally&#39;s main output file.
        This function will mainly process standard tally output files, but it can optionally process tally &#34;dump&#34; files too,
        though it can only save the dump outputs to its dill/pickle files and not return the (quite large) dump data objects.
        The filenames of saved dump data will not be included in the returned list.

    Dependencies:
        - `import os`
        - `import numpy as np`
        - `import pandas as pd` (if `make_PandasDF = True`)
        - `import pickle` (if `save_output_pickle = True`)
        - `from munch import *`
        - `from pathlib import Path`

    Inputs:
       (required)

        - `tally_output_dirpath` = Path (string or path object) to the tally output directory to be searched and parsed

    Inputs:
       (optional)

       - `output_file_suffix` = A string specifying what characters processed filenames (including the file extension)
                      must end in to be included.  This condition is not enforced if set to an empty string `&#39;&#39;`. (D=`&#39;.out&#39;`)
       - `output_file_prefix` = A string specifying what characters processed filenames (including the file extension)
                      must begin with to be included.  This condition is not enforced if set to an empty string `&#39;&#39;`. (D=`&#39;&#39;`)
       - `output_file_required_string` = A string which must be present anywhere within processed filenames (including the
                      file extension) to be included.  This condition is not enforced if set to an empty string `&#39;&#39;`. (D=`&#39;&#39;`)
       - `include_subdirectories` = A Boolean determining whether this function searches and processes all included
                      tally output files in this directory AND deeper subdirectories if set to `True`
                      or only the files directly within the provided directory `tally_output_dirpath` if set to `False` (D=`False`)
       - `return_tally_output` = A Boolean determining whether this function returns a list of `tally_output` dictionaries
                      if set to `True` or just a list of filepaths to the pickle files containing these dictionaries
                      if set to `False` (D=`False`)
       - `include_dump_files` = A Boolean determining whether dump files will be processed too or skipped. (D=`False`)
                      Settings to be applied to all encountered dump files can be specified per the optional inputs
                      detailed below which are simply passed to the `parse_tally_dump_file()` function.  Note that parameters
                      `return_namedtuple_list` and `return_Pandas_dataframe` will always be `False` when dump files are
                      processed in a directory with this function; instead, `save_namedtuple_list` and `save_Pandas_dataframe`
                      are by default set to `True` when parsing dump files in a directory with this function.  (Be warned,
                      if the dump file is large, the produced files from parsing them will be too.)

    Inputs:
       (optional, the same as in and directly passed to the `parse_tally_output_file()` function)

       - `make_PandasDF` = A Boolean determining whether a Pandas dataframe of the tally data array will be made (D=`True`)
       - `calculate_absolute_errors` = A Boolean determining whether the absolute uncertainty of each tally output value
                      is to be calculated (simply as the product of the value and relative error); if `False`, the final
                      dimension of `tally_data`, `ierr`, will be of length-2 rather than length-3 (D=`True`)
       - `save_output_pickle` = A Boolean determining whether the `tally_output` dictionary object is saved as a pickle file;
                      if `True`, the file will be saved with the same path and name as the provided PHITS tally output file
                      but with the .pickle extension. (D=`True`)
       - `prefer_reading_existing_pickle` = A Boolean determining what this function does if the pickle file this function
                      seeks to generate already exists.  If `False` (default behavior), this function will parse the PHITS
                      output files as usual and overwrite the existing pickle file.  If `True`, this function will instead
                      simply just read the existing found pickle file and return its stored `tally_output` contents. (D=`False`)

    Inputs:
       (optional, the same as in and directly passed to the `parse_tally_dump_file()` function)

       - `dump_data_number` = integer number of data per row in dump file, binary if &gt;0 and ASCII if &lt;0.
                This should match the value following `dump=` in the tally creating the dump file. (D=`None`)
                If not specified, the search_for_dump_parameters() function will attempt to find it automatically.
       - `dump_data_sequence` = string or list of integers with the same number of entries as `dump_data_number`,
                mapping each column in the dump file to their physical quantities.  (D=`None`)
                This should match the line following the `dump=` line in the tally creating the dump file.
                See PHITS manual section &#34;6.7.22 dump parameter&#34; for further explanations of these values.
                If not specified, the search_for_dump_parameters() function will attempt to find it automatically.
       - `dump_return_directional_info` = (optional, D=`False`) Boolean designating whether extra directional information
                should be calculated and returned; these include: radial distance `r` from the origin in cm,
                radial distance `rho` from the z-axis in cm,
                polar angle `theta` between the direction vector and z-axis in radians [0,pi] (or degrees), and
                azimuthal angle `phi` of the direction vector in radians [-pi,pi] (or degrees).
                Note: This option requires all position and direction values [x,y,z,u,v,w] to be included in the dump file.
       - `dump_use_degrees` = (optional, D=`False`) Boolean designating whether angles `theta` and `phi` are returned
                in units of degrees. Default setting is to return angles in radians.
       - `dump_max_entries_read` = (optional, D=`None`) integer number specifying the maximum number of entries/records
                of the dump file to be read.  By default, all records in the dump file are read.
       - `dump_save_namedtuple_list` = (optional, D=`True`) Boolean designating whether `dump_data_list` is saved to a dill file
               (for complicated reasons, objects containing namedtuples cannot be easily saved with pickle but can with dill).
       - `dump_save_Pandas_dataframe` = (optional, D=`True`) Boolean designating whether `dump_data_frame` is saved to a pickle
               file (via Pandas .to_pickle()).

    Output:
        - `tally_output_list` = a list of `tally_output` dictionary objects with the below keys and values / a list of
             file paths to pickle files containing `tally_output` dictionary objects:
            - `&#39;tally_data&#39;` = a 10-dimensional NumPy array containing all tally results, explained in more detail below
            - `&#39;tally_metadata&#39;` = a dictionary/Munch object with various data extracted from the tally output file, such as axis binning and units
            - `&#39;tally_dataframe&#39;` = (optionally included if setting `make_PandasDF = True`) a Pandas dataframe version of `tally_data`

    &#39;&#39;&#39;
    import os

    if not os.path.isdir(tally_output_dirpath):
        print(&#39;The provided path to &#34;tally_output_dir&#34; is not a directory:&#39;,tally_output_dirpath)
        if os.path.isfile(tally_output_dirpath):
            head, tail = os.path.split(tally_output_dirpath)
            tally_output_dirpath = head
            print(&#39;However, it is a valid path to a file; thus, its parent directory will be used:&#39;,tally_output_dirpath)
        else:
            print(&#39;Nor is it a valid path to a file. ERROR! Aborting...&#39;)
            return None

    if include_subdirectories:
        # Get paths to all files in this dir and subdirs
        files_in_dir = []
        for path, subdirs, files in os.walk(tally_output_dirpath):
            for name in files:
                files_in_dir.append(os.path.join(path, name))
    else:
        # Just get paths to files in this dir
        files_in_dir = [os.path.join(tally_output_dirpath, f) for f in os.listdir(tally_output_dirpath) if os.path.isfile(os.path.join(tally_output_dirpath, f))]

    # Determine which files should be parsed
    filepaths_to_process = []
    dump_filepaths_to_process = []
    len_suffix = len(output_file_suffix)
    len_prefix = len(output_file_prefix)
    len_reqstr = len(output_file_required_string)
    for f in files_in_dir:
        head, tail = os.path.split(f)
        if len_suffix &gt; 0 and tail[-len_suffix:] != output_file_suffix: continue
        if len_prefix &gt; 0 and tail[:len_prefix] != output_file_prefix: continue
        if len_reqstr &gt; 0 and output_file_required_string not in tail: continue
        if tail[(-4-len_suffix):] == &#39;_err&#39; + output_file_suffix: continue
        with open(f) as ff:
            try:
                first_line = ff.readline().strip()
            except: # triggered if encountering binary / non ASCII or UTF-8 file
                if include_dump_files and tail[(-4-len_suffix):] == &#39;_dmp&#39; + output_file_suffix:
                    dump_filepaths_to_process.append(f)
                continue
            if len(first_line) == 0: continue
            if first_line[0] != &#39;[&#39; :
                if include_dump_files and tail[(-4-len_suffix):] == &#39;_dmp&#39; + output_file_suffix:
                    dump_filepaths_to_process.append(f)
                continue
        filepaths_to_process.append(f)

    tally_output_pickle_path_list = []
    tally_output_list = []
    for f in filepaths_to_process:
        f = Path(f)
        path_to_pickle_file = Path(f.parent, f.stem + &#39;.pickle&#39;)
        tally_output_pickle_path_list.append(path_to_pickle_file)
        tally_output = parse_tally_output_file(f, make_PandasDF=make_PandasDF,
                                               calculate_absolute_errors=calculate_absolute_errors,
                                               save_output_pickle=save_output_pickle,
                                               prefer_reading_existing_pickle=prefer_reading_existing_pickle)
        if return_tally_output: tally_output_list.append(tally_output)

    if include_dump_files:
        for f in dump_filepaths_to_process:
            f = Path(f)
            parse_tally_dump_file(f, dump_data_number=dump_data_number, dump_data_sequence=dump_data_number,
                                  return_directional_info=dump_return_directional_info, use_degrees=dump_use_degrees,
                                  max_entries_read=dump_max_entries_read,
                                  return_namedtuple_list=False, return_Pandas_dataframe=False,
                                  save_namedtuple_list=dump_save_namedtuple_list,
                                  save_Pandas_dataframe=dump_save_Pandas_dataframe)

    if return_tally_output:
        return tally_output_list
    else:
        return tally_output_pickle_path_list</code></pre>
</details>
</dd>
<dt id="PHITS_tools.fetch_MC_material"><code class="name flex">
<span>def <span class="ident">fetch_MC_material</span></span>(<span>matid=None, matname=None, matsource=None, concentration_type=None, particle=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Returns a materials definition string formatted for use in PHITS or MCNP</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code>import os</code></li>
<li><code>import pickle</code></li>
<li>PYTHONPATH environmental variable must be set and one entry must contain the directory
which contains the vital "MC_materials/Compiled_MC_materials.pkl" file.</li>
</ul>
<h2 id="inputs">Inputs</h2>
<p>(required to enter <code>matid</code> OR <code>matname</code>, with <code>matid</code> taking priority if conflicting)</p>
<ul>
<li><code>matid</code> = ID number in the "Compiled_MC_materials" file</li>
<li><code>matname</code> = exact name of material in "Compiled_MC_materials" file</li>
<li><code>matsource</code> = exact source of material in "Compiled_MC_materials" file, only used when multiple
materials have identical names</li>
<li><code>concentration_type</code> = selection between <code>'weight fraction'</code> (default if no formula) and <code>'atom fraction'</code> (default if formula present) to be returned</li>
<li><code>particle</code> = selection of whether natural (<code>'photons'</code>, default) or isotopic (<code>'neutrons'</code>) elements are used
Note that if "enriched" or "depleted" appears in the material's name, particle=<code>'neutrons'</code> is set automatically.</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>mat_str</code> = string containing the material's information, ready to be inserted directly into a PHITS/MCNP input file</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch_MC_material(matid=None,matname=None,matsource=None,concentration_type=None,particle=None):
    &#39;&#39;&#39;
    Description:
        Returns a materials definition string formatted for use in PHITS or MCNP

    Dependencies:
        - `import os`
        - `import pickle`
        - PYTHONPATH environmental variable must be set and one entry must contain the directory
                which contains the vital &#34;MC_materials/Compiled_MC_materials.pkl&#34; file.

    Inputs:
       (required to enter `matid` OR `matname`, with `matid` taking priority if conflicting)

       - `matid` = ID number in the &#34;Compiled_MC_materials&#34; file
       - `matname` = exact name of material in &#34;Compiled_MC_materials&#34; file
       - `matsource` = exact source of material in &#34;Compiled_MC_materials&#34; file, only used when multiple
                materials have identical names
       - `concentration_type` = selection between `&#39;weight fraction&#39;` (default if no formula) and `&#39;atom fraction&#39;` (default if formula present) to be returned
       - `particle` = selection of whether natural (`&#39;photons&#39;`, default) or isotopic (`&#39;neutrons&#39;`) elements are used
                Note that if &#34;enriched&#34; or &#34;depleted&#34; appears in the material&#39;s name, particle=`&#39;neutrons&#39;` is set automatically.

    Outputs:
       - `mat_str` = string containing the material&#39;s information, ready to be inserted directly into a PHITS/MCNP input file
    &#39;&#39;&#39;
    import os
    import pickle
    if not matid and not matname:
        print(&#39;Either &#34;matid&#34; or &#34;matname&#34; MUST be defined&#39;)
        return None

    # First, locate and open materials library
    try:
        user_paths = os.environ[&#39;PYTHONPATH&#39;].split(os.pathsep)
        lib_file = None
        for i in user_paths:
            if &#39;phits_tools&#39; in i.lower() or &#39;phits-tools&#39; in i.lower():
                lib_file = i + r&#34;\MC_materials\Compiled_MC_materials&#34;
        if not lib_file:
            print(&#39;Could not find &#34;PHITS_tools&#34; folder in PYTHONPATH; this folder contains the vital &#34;MC_materials/Compiled_MC_materials.pkl&#34; file.&#39;)
    except KeyError:
        print(&#39;The PYTHONPATH environmental variable must be defined and contain the path to the directory holding &#34;MC_materials/Compiled_MC_materials.pkl&#34;&#39;)
        return None

    # Load materials library
    def load_obj(name ):
        with open(name + &#39;.pkl&#39;, &#39;rb&#39;) as f:
            return pickle.load(f)
    all_mats_list = load_obj(lib_file)

    if matid: # use mat ID number
        mi = int(matid)-1
        matname = all_mats_list[mi][&#39;name&#39;]
    else: # use material name and possibly source too
        # determine material
        mi = None
        # first check for exact matches
        matching_mi = []
        for i in range(len(all_mats_list)):
            if all_mats_list[i][&#39;name&#39;].lower()==matname.lower():
                matching_mi.append(i)
        if len(matching_mi)==1:
            mi = matching_mi[0]
        elif len(matching_mi)&gt;1:
            print(&#39;Found multiple materials with this identical matname value:&#39;)
            for mmi in matching_mi:
                print(&#39;\tmatid={}  matname=&#34;{}&#34;  source=&#34;{}&#34;&#39;.format(str(mmi+1),all_mats_list[mmi][&#39;name&#39;],all_mats_list[mmi][&#39;source&#39;]))
                if all_mats_list[mmi][&#39;source&#39;] and all_mats_list[mmi][&#39;source&#39;]==matsource:
                    mi = mmi
                    print(&#39;\t\t^ matches inputed &#34;matsource&#34; and will be used&#39;)
            if mi==None:
                print(&#39;Please enter a &#34;matsource&#34; value identical to one of these two (or the matid).&#39;)
                return None
        else: # Exact material name not found
            # search for similar entries
            similar_mi = []
            for i in range(len(all_mats_list)):
                if matname.lower() in all_mats_list[i][&#39;name&#39;].lower():
                    similar_mi.append(i)
            if len(similar_mi)==0:
                print(&#39;No materials with that exact name or names containing &#34;matname&#34; were found.&#39;)
                return None
            elif len(similar_mi)==1:
                mi = similar_mi[0]
                print(&#39;Found one similar material (matid={}  matname=&#34;{}&#34;  source=&#34;{}&#34;); using it.&#39;.format(str(mi+1),all_mats_list[mi][&#39;name&#39;],all_mats_list[mi][&#39;source&#39;]))
            else:
                print(&#39;Found no material with exact &#34;matname&#34; but {} with similar names:&#39;.format(len(similar_mi)))
                for smi in similar_mi:
                    print(&#39;\tmatid={}  matname=&#34;{}&#34;  source=&#34;{}&#34;&#39;.format(str(smi+1),all_mats_list[smi][&#39;name&#39;],all_mats_list[smi][&#39;source&#39;]))
                print(&#39;The first of these will be used.  If another material was desired, please enter its &#34;matid&#34; or exact &#34;matname&#34;.&#39;)
                mi = similar_mi[0]

    # Now that material ID has been found, generate text entry
    mat = all_mats_list[mi]
    banner_width = 60
    cc = &#39;$&#39;  # comment character

    entry_text  = &#39;\n&#39;+cc+&#39;*&#39;*banner_width + &#39;\n&#39;
    entry_text += cc+&#39;  {:&lt;3d} : {} \n&#39;.format(mi+1,mat[&#39;name&#39;])
    if mat[&#39;source&#39;] and mat[&#39;source&#39;]!=&#39;-&#39;:
        entry_text += cc+&#39;  Source = {} \n&#39;.format(mat[&#39;source&#39;])
    if mat[&#39;formula&#39;] and mat[&#39;formula&#39;]!=&#39;-&#39;:
        entry_text += cc+&#39;  Formula = {} \n&#39;.format(mat[&#39;formula&#39;])
    if mat[&#39;molecular weight&#39;] and mat[&#39;molecular weight&#39;]!=&#39;-&#39;:
        entry_text += cc+&#39;  Molecular weight (g/mole) = {} \n&#39;.format(mat[&#39;molecular weight&#39;])
    if mat[&#39;density&#39;] and mat[&#39;density&#39;]!=&#39;-&#39;:
        entry_text += cc+&#39;  Density (g/cm3) = {} \n&#39;.format(mat[&#39;density&#39;])
    if mat[&#39;total atom density&#39;] and mat[&#39;total atom density&#39;]!=&#39;-&#39;:
        if isinstance(mat[&#39;total atom density&#39;],str):
            entry_text += cc+&#39;  Total atom density (atoms/b-cm) = {} \n&#39;.format(mat[&#39;total atom density&#39;])
        else:
            entry_text += cc+&#39;  Total atom density (atoms/b-cm) = {:&lt;13.4E} \n&#39;.format(mat[&#39;total atom density&#39;])

    if concentration_type==None: # user did not select this, determine which is more appropriate automatically
        if mat[&#39;formula&#39;] and mat[&#39;formula&#39;]!=&#39;-&#39;:
            concentration_type = &#39;atom fraction&#39;
        else:
            concentration_type = &#39;weight fraction&#39;

    entry_text += cc+&#39;  Composition by {} \n&#39;.format(concentration_type)

    # Determine if neutron or photon entry will be used
    neutron_keyword_list = [&#39;depleted&#39;,&#39;enriched&#39;,&#39; heu&#39;,&#39; leu&#39;,&#39;uranium&#39;,&#39;plutonium&#39;,&#39;uranyl&#39;]
    if particle==None: # user did not select this, determine which is more appropriate automatically
        neutron_kw_found_in_name = False
        for nki in neutron_keyword_list:
            if nki in matname.lower():
                neutron_kw_found_in_name = True
        if neutron_kw_found_in_name:
            particle = &#39;neutrons&#39;
        else:
            particle = &#39;photons&#39;


    for j in range(len(mat[particle][concentration_type][&#39;ZA&#39;])):

        if isinstance(mat[particle][concentration_type][&#39;value&#39;][j],str):
            entry_format = &#39;{:4}    {:&gt;7}  {:13}   &#39;+cc+&#39;  {}&#39;  + &#39;\n&#39;
        else:
            entry_format = &#39;{:4}    {:&gt;7d}  {:&lt;13.6f}   &#39;+cc+&#39;  {}&#39;  + &#39;\n&#39;

        if j==0:
            mstr = &#39;M{:&lt;3}&#39;.format(mi+1)
        else:
            mstr = &#39; &#39;*4

        ZZZAAA = mat[particle][concentration_type][&#39;ZA&#39;][j]
        if ZZZAAA == &#39;-&#39;:
            ZZZAAA = mat[&#39;photons&#39;][concentration_type][&#39;ZA&#39;][j]

        Z = int(str(ZZZAAA)[:-3])
        A = str(ZZZAAA)[-3:]
        sym = Element_Z_to_Sym(Z)
        if A != &#39;000&#39;:
            isotope = sym+&#39;-&#39;+A.lstrip(&#39;0&#39;)
        else:
            isotope = sym

        entry_text += entry_format.format(mstr,ZZZAAA,mat[particle][concentration_type][&#39;value&#39;][j],isotope)
    entry_text  += cc+&#39;*&#39;*banner_width + &#39;\n&#39;

    return entry_text</code></pre>
</details>
</dd>
<dt id="PHITS_tools.tally"><code class="name flex">
<span>def <span class="ident">tally</span></span>(<span>data, bin_edges=[], min_bin_left_edge=None, max_bin_right_edge=None, nbins=None, bin_width=None, divide_by_bin_width=False, normalization=None, scaling_factor=1, place_overflow_at_ends=True, return_uncertainties=False, return_event_indices_histogram=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Tally number of incidences of values falling within a desired binning structure</p>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>data</code> = list of values to be tallied/histogrammed</li>
<li><code>bin_edges</code> = list of N+1 bin edge values for a tally of N bins</li>
<li><code>min_bin_left_edge</code> = left/minimum edge value of the first bin</li>
<li><code>max_bin_right_edge</code> = right/maximum edge value of the last bin</li>
<li><code>nbins</code> = number of equally-sized bins to be created from <code>min_bin_left_edge</code> to <code>max_bin_right_edge</code></li>
<li><code>bin_width</code> = constant width of bins to be created from <code>min_bin_left_edge</code> to <code>max_bin_right_edge</code></li>
<li><code>divide_by_bin_width</code> = Boolean denoting whether final bin values are divided by their bin widths (D=<code>False</code>)</li>
<li><code>normalization</code> = determine how the resulting histogram is normalized (D=<code>None</code>), options are:
<code>[None, 'unity-sum', 'unity-max-val']</code>.
If <code>None</code>, no additional normalization is done.
If <code>unity-sum</code>, the data is normalized such that its sum will be 1.
If <code>unity-max-val</code>, the
data is normalized such that the maximum value is 1.
The operation occurs after any bin
width normalization from <code>divide_by_bin_width</code> but before any scaling from <code>scaling_factor</code>.</li>
<li><code>scaling_factor</code> = value which all final bins are multiplied/scaled by (D=<code>1</code>)</li>
<li><code>place_overflow_at_ends</code> = handling of values outside of binning range (D=<code>True</code>); if <code>True</code> extreme
values are tallied in the first/last bin, if <code>False</code> extreme values are discarded</li>
<li><code>return_uncertainties</code> = Boolean denoting if should return an extra N-length list whose elements
are the statistical uncertainties (square root w/ normalizations) of the tally bins (D=<code>False</code>)</li>
<li><code>return_event_indices_histogram</code> = Boolean denoting if should return an extra N-length list whose elements
are each a list of the event indices corresponding to each bin (D=<code>False</code>)</li>
</ul>
<h2 id="notes">Notes</h2>
<p>Regarding the binning structure, this function only needs to be provided <code>bin_edges</code> directly (takes priority)
or the information needed to calculate <code>bin_edges</code>, that is: <code>min_bin_left_edge</code> and <code>max_bin_right_edge</code> and
either <code>nbins</code> or <code>bin_width</code>.
(Priority is given to <code>nbins</code> if both are provided.)</p>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>tallied_hist</code> = N-length list of tallied data</li>
<li><code>bin_edges</code> = list of N+1 bin edge values for a tally of N bins</li>
<li><code>tallied_hist_err</code> = (optional) N-length list of statistical uncertainties of tallied data</li>
<li><code>tallied_event_indicies</code> = (optional) N-length list of, for each bin, a list of the event indices populating it</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tally(data, bin_edges=[], min_bin_left_edge=None, max_bin_right_edge=None, nbins=None, bin_width=None, divide_by_bin_width=False, normalization=None, scaling_factor=1, place_overflow_at_ends=True, return_uncertainties=False, return_event_indices_histogram=False):
    &#39;&#39;&#39;
    Description:
        Tally number of incidences of values falling within a desired binning structure

    Inputs:
        - `data` = list of values to be tallied/histogrammed
        - `bin_edges` = list of N+1 bin edge values for a tally of N bins
        - `min_bin_left_edge` = left/minimum edge value of the first bin
        - `max_bin_right_edge` = right/maximum edge value of the last bin
        - `nbins` = number of equally-sized bins to be created from `min_bin_left_edge` to `max_bin_right_edge`
        - `bin_width` = constant width of bins to be created from `min_bin_left_edge` to `max_bin_right_edge`
        - `divide_by_bin_width` = Boolean denoting whether final bin values are divided by their bin widths (D=`False`)
        - `normalization` = determine how the resulting histogram is normalized (D=`None`), options are:
                       `[None, &#39;unity-sum&#39;, &#39;unity-max-val&#39;]`.  If `None`, no additional normalization is done.
                       If `unity-sum`, the data is normalized such that its sum will be 1.  If `unity-max-val`, the
                       data is normalized such that the maximum value is 1.  The operation occurs after any bin
                       width normalization from `divide_by_bin_width` but before any scaling from `scaling_factor`.
        - `scaling_factor` = value which all final bins are multiplied/scaled by (D=`1`)
        - `place_overflow_at_ends` = handling of values outside of binning range (D=`True`); if `True` extreme
                       values are tallied in the first/last bin, if `False` extreme values are discarded
        - `return_uncertainties` = Boolean denoting if should return an extra N-length list whose elements
                       are the statistical uncertainties (square root w/ normalizations) of the tally bins (D=`False`)
        - `return_event_indices_histogram` = Boolean denoting if should return an extra N-length list whose elements
                       are each a list of the event indices corresponding to each bin (D=`False`)

    Notes:
        Regarding the binning structure, this function only needs to be provided `bin_edges` directly (takes priority)
        or the information needed to calculate `bin_edges`, that is: `min_bin_left_edge` and `max_bin_right_edge` and
        either `nbins` or `bin_width`.  (Priority is given to `nbins` if both are provided.)

    Outputs:
        - `tallied_hist` = N-length list of tallied data
        - `bin_edges` = list of N+1 bin edge values for a tally of N bins
        - `tallied_hist_err` = (optional) N-length list of statistical uncertainties of tallied data
        - `tallied_event_indicies` = (optional) N-length list of, for each bin, a list of the event indices populating it
    &#39;&#39;&#39;

    normalization_valid_entries = [None, &#39;unity-sum&#39;, &#39;unity-max-val&#39;]
    if normalization not in normalization_valid_entries:
        print(&#34;Entered normalization option of &#34;,normalization,&#34; is not a valid option; please select from the following: [None, &#39;unity-sum&#39;, &#39;unity-max-val&#39;]&#34;.format())

    if len(bin_edges)!=0:
        bin_edges = np.array(bin_edges)
    else:
        if nbins != None:
            bin_edges = np.linspace(min_bin_left_edge,max_bin_right_edge,num=nbins+1)
        else:
            bin_edges = np.arange(min_bin_left_edge,max_bin_right_edge+bin_width,step=bin_width)

    nbins = len(bin_edges) - 1

    if return_event_indices_histogram:
        tallied_event_indicies = []
        tallied_hist = np.zeros(nbins)
        for i in range(nbins):
            tallied_event_indicies.append([])
        # events must be histogrammed manually
        for i, val in enumerate(data):
            if val &lt; bin_edges[0]:
                if place_overflow_at_ends:
                    tallied_hist[0] += 1
                    tallied_event_indicies[0].append(i)
                continue
            if val &gt; bin_edges[-1]:
                if place_overflow_at_ends:
                    tallied_hist[-1] += 1
                    tallied_event_indicies[-1].append(i)
                continue
            for j, be in enumerate(bin_edges):
                if be &gt; val: # found right edge of bin containing val
                    tallied_hist[j-1] += 1
                    tallied_event_indicies[j-1].append(i)
                    break



    else:
        tallied_hist, bins = np.histogram(data,bins=bin_edges)

    if return_uncertainties:
        tallied_hist_err = np.sqrt(tallied_hist)
        if divide_by_bin_width: tallied_hist_err = tallied_hist_err/(bin_edges[1:]-bin_edges[:-1])
        if normalization==&#39;unity-sum&#39;: tallied_hist_err = tallied_hist_err/np.sum(tallied_hist)
        if normalization==&#39;unity-max-val&#39;: tallied_hist_err = tallied_hist_err/np.max(tallied_hist)
        if scaling_factor != 1: tallied_hist_err = tallied_hist_err*scaling_factor

    if divide_by_bin_width: tallied_hist = tallied_hist/(bin_edges[1:]-bin_edges[:-1])
    if normalization==&#39;unity-sum&#39;: tallied_hist = tallied_hist/np.sum(tallied_hist)
    if normalization==&#39;unity-max-val&#39;: tallied_hist = tallied_hist/np.max(tallied_hist)
    if scaling_factor != 1: tallied_hist = tallied_hist*scaling_factor

    if return_event_indices_histogram:
        if return_uncertainties:
            return tallied_hist,bin_edges,tallied_hist_err,tallied_event_indicies
        else:
            return tallied_hist,bin_edges,tallied_event_indicies
    else:
        if return_uncertainties:
            return tallied_hist,bin_edges,tallied_hist_err
        else:
            return tallied_hist,bin_edges</code></pre>
</details>
</dd>
<dt id="PHITS_tools.rebinner"><code class="name flex">
<span>def <span class="ident">rebinner</span></span>(<span>output_xbins, input_xbins, input_ybins)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>The purpose of this function is to rebin a set of y values corresponding to a set of x bins to a new set of x bins.
The function seeks to be as generalized as possible, meaning bin sizes do not need to be consistent.</p>
<h2 id="dependencies">Dependencies</h2>
<p><code>import numpy as np</code></p>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>output_xbins</code> = output array containing bounds of x bins of length N; first entry is leftmost bin boundary</li>
<li><code>input_xbins</code>
= input array containing bounds of x bins of length M; first entry is leftmost bin boundary</li>
<li><code>input_ybins</code>
= input array containing y values of length M-1</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>output_ybins</code> = output array containing y values of length N-1</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rebinner(output_xbins,input_xbins,input_ybins):
    &#34;&#34;&#34;
    Description:
        The purpose of this function is to rebin a set of y values corresponding to a set of x bins to a new set of x bins.
        The function seeks to be as generalized as possible, meaning bin sizes do not need to be consistent.

    Dependencies:
        `import numpy as np`

    Inputs:
      - `output_xbins` = output array containing bounds of x bins of length N; first entry is leftmost bin boundary
      - `input_xbins`  = input array containing bounds of x bins of length M; first entry is leftmost bin boundary
      - `input_ybins`  = input array containing y values of length M-1

    Outputs:
      - `output_ybins` = output array containing y values of length N-1
    &#34;&#34;&#34;

    N = len(output_xbins)
    M = len(input_xbins)
    output_ybins = np.zeros(N-1)

    for i in range(0,N-1):
        # For each output bin
        lxo = output_xbins[i]   # lower x value of output bin
        uxo = output_xbins[i+1] # upper x value of output bin
        dxo = uxo - lxo         # width of current x output bin

        # Scan input x bins to see if any fit in this output bin
        for j in range(0,M-1):
            lxi = input_xbins[j]    # lower x value of input bin
            uxi = input_xbins[j+1]  # upper x value of input bin
            dxi = uxi - lxi         # width of current x input bin

            if uxi&lt;lxo or lxi&gt;uxo:
                # no bins are aligned
                continue
            elif lxi &gt;= lxo and lxi &lt; uxo:
                # start of an input bin occurs in this output bin
                if lxi &gt;= lxo and uxi &lt;= uxo:
                    # input bin completely encompassed by output bin
                    output_ybins[i] = output_ybins[i] + input_ybins[j]
                else:
                    # input bin spans over at least one output bin
                    # count fraction in current output x bin
                    f_in_dxo = (uxo-lxi)/dxi
                    output_ybins[i] = output_ybins[i] + f_in_dxo*input_ybins[j]
            elif lxi &lt; lxo and uxi &gt; uxo:
                # output bin is completely encompassed by input bin
                f_in_dxo = (uxo-lxo)/dxi
                output_ybins[i] = output_ybins[i] + f_in_dxo*input_ybins[j]
            elif lxi &lt; lxo and uxi &gt; lxo and uxi &lt;= uxo:
                # tail of input bin is located in this output bin
                f_in_dxo = (uxi-lxo)/dxi
                output_ybins[i] = output_ybins[i] + f_in_dxo*input_ybins[j]

    return output_ybins</code></pre>
</details>
</dd>
<dt id="PHITS_tools.is_number"><code class="name flex">
<span>def <span class="ident">is_number</span></span>(<span>n)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Determine if a string is that of a number or not.</p>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>n</code> = string to be tested</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>True</code> if value is a number (can be converted to float() without an error)</li>
<li><code>False</code> otherwise</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_number(n):
    &#39;&#39;&#39;
    Description:
        Determine if a string is that of a number or not.

    Inputs:
        - `n` = string to be tested

    Outputs:
        - `True` if value is a number (can be converted to float() without an error)
        - `False` otherwise
    &#39;&#39;&#39;
    try:
        float(n)
    except ValueError:
        return False
    return True</code></pre>
</details>
</dd>
<dt id="PHITS_tools.ZZZAAAM_to_nuclide_plain_str"><code class="name flex">
<span>def <span class="ident">ZZZAAAM_to_nuclide_plain_str</span></span>(<span>ZZZAAAM, include_Z=False, ZZZAAA=False, delimiter='-')</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Converts a plaintext string of a nuclide to an integer ZZZAAAM = 10000*Z + 10*A + M</p>
<h2 id="dependencies">Dependencies</h2>
<p><code><a title="PHITS_tools.Element_Z_to_Sym" href="#PHITS_tools.Element_Z_to_Sym">Element_Z_to_Sym()</a></code> (function within the "Hunter's tools" package)</p>
<h2 id="input">Input</h2>
<ul>
<li><code>ZZZAAAM</code> = integer equal to 10000<em>Z + 10</em>A + M, where M designates the metastable state (0=ground)</li>
<li><code>include_Z</code> = Boolean denoting whether the Z number should be included in the output string (D=<code>False</code>)</li>
<li><code>ZZZAAA</code> = Boolean denoting whether the input should be interpreted as a ZZZAAA value (1000Z+A) instead (D=<code>False</code>)</li>
<li><code>delimiter</code> = string which will be used to separate elements of the output string (D=<code>-</code>)</li>
</ul>
<h2 id="output">Output</h2>
<ul>
<li><code>nuc_str</code> = string describing the input nuclide formatted as [Z]-[Symbol]-[A][m]</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ZZZAAAM_to_nuclide_plain_str(ZZZAAAM,include_Z=False,ZZZAAA=False,delimiter=&#39;-&#39;):
    &#39;&#39;&#39;
    Description:
        Converts a plaintext string of a nuclide to an integer ZZZAAAM = 10000\*Z + 10\*A + M

    Dependencies:
        `Element_Z_to_Sym` (function within the &#34;Hunter&#39;s tools&#34; package)

    Input:
       - `ZZZAAAM` = integer equal to 10000*Z + 10*A + M, where M designates the metastable state (0=ground)
       - `include_Z` = Boolean denoting whether the Z number should be included in the output string (D=`False`)
       - `ZZZAAA` = Boolean denoting whether the input should be interpreted as a ZZZAAA value (1000Z+A) instead (D=`False`)
       - `delimiter` = string which will be used to separate elements of the output string (D=`-`)

    Output:
       - `nuc_str` = string describing the input nuclide formatted as [Z]-[Symbol]-[A][m]
    &#39;&#39;&#39;
    ZZZAAAM = int(ZZZAAAM)
    if ZZZAAA:
        ZZZAAAM = ZZZAAAM*10
    m = ZZZAAAM % 10
    A = (ZZZAAAM % 10000) // 10
    Z = ZZZAAAM // 10000
    symbol = Element_Z_to_Sym(Z)

    m_str = &#39;&#39;
    if m&gt;0:
        m_str = &#39;m&#39; + str(m)

    nuc_str = &#39;&#39;
    if include_Z:
        nuc_str += str(Z) + delimiter
    nuc_str += symbol + delimiter + str(A) + m_str

    return nuc_str</code></pre>
</details>
</dd>
<dt id="PHITS_tools.nuclide_plain_str_to_latex_str"><code class="name flex">
<span>def <span class="ident">nuclide_plain_str_to_latex_str</span></span>(<span>nuc_str, include_Z=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Converts a plaintext string of a nuclide to a LaTeX-formatted raw string
Note: if you already have the Z, A, and isomeric state information determined, the "nuclide_to_Latex_form" function can be used instead</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code><a title="PHITS_tools.Element_Z_to_Sym" href="#PHITS_tools.Element_Z_to_Sym">Element_Z_to_Sym()</a></code> (function within the "Hunter's tools" package) (only required if <code>include_Z = True</code>)</li>
</ul>
<h2 id="input">Input</h2>
<p>(required)</p>
<ul>
<li><code>nuc_str</code> = string to be converted; a huge variety of formats are supported, but they all must follow the following rules:<ul>
<li>Isomeric/metastable state characters must always immediately follow the atomic mass characters.
Isomeric state labels MUST either:<ul>
<li>(1) be a single lower-case character OR</li>
<li>(2) begin with any non-numeric character and end with a number</li>
</ul>
</li>
<li>Atomic mass numbers must be nonnegative integers OR the string <code>"nat"</code> (in which case no metastable states can be written)</li>
<li>Elemental symbols MUST begin with an upper-case character</li>
</ul>
</li>
</ul>
<h2 id="input_1">Input</h2>
<p>(optional)</p>
<ul>
<li><code>include_Z</code> = <code>True</code>/<code>False</code> determining whether the nuclide's atomic number Z will be printed as a subscript beneath the atomic mass</li>
</ul>
<h2 id="output">Output</h2>
<ul>
<li>LaTeX-formatted raw string of nuclide</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nuclide_plain_str_to_latex_str(nuc_str,include_Z=False):
    &#39;&#39;&#39;
    Description:
        Converts a plaintext string of a nuclide to a LaTeX-formatted raw string
        Note: if you already have the Z, A, and isomeric state information determined, the &#34;nuclide_to_Latex_form&#34; function can be used instead

    Dependencies:
        - `Element_Z_to_Sym` (function within the &#34;Hunter&#39;s tools&#34; package) (only required if `include_Z = True`)

    Input:
        (required)

       - `nuc_str` = string to be converted; a huge variety of formats are supported, but they all must follow the following rules:
           + Isomeric/metastable state characters must always immediately follow the atomic mass characters.
               Isomeric state labels MUST either:
               - (1) be a single lower-case character OR
               - (2) begin with any non-numeric character and end with a number
           + Atomic mass numbers must be nonnegative integers OR the string `&#34;nat&#34;` (in which case no metastable states can be written)
           + Elemental symbols MUST begin with an upper-case character

    Input:
       (optional)

       - `include_Z` = `True`/`False` determining whether the nuclide&#39;s atomic number Z will be printed as a subscript beneath the atomic mass

    Output:
        - LaTeX-formatted raw string of nuclide
    &#39;&#39;&#39;
    tex_str = r&#39;&#39;

    # remove unwanted characters from provided string
    delete_characters_list = [&#39; &#39;, &#39;-&#39;, &#39;_&#39;]
    for dc in delete_characters_list:
        nuc_str = nuc_str.replace(dc,&#39;&#39;)

    # determine which characters are letters versus numbers
    isalpha_list = []
    isdigit_list = []
    for c in nuc_str:
        isalpha_list.append(c.isalpha())
        isdigit_list.append(c.isdigit())

    symbol = &#39;&#39;
    mass = &#39;&#39;
    isost = &#39;&#39;

    # string MUST begin with either mass number or elemental symbol
    if isdigit_list[0] or nuc_str[0:3]==&#39;nat&#39;: # mass first
        mass_first = True
    else:
        mass_first = False

    if mass_first:
        if nuc_str[0:3]==&#39;nat&#39;:
            mass = &#39;nat&#39;
            ci = 3
        else:
            ci = 0
            while isdigit_list[ci]:
                mass += nuc_str[ci]
                ci += 1
            mass = str(int(mass)) # eliminate any extra leading zeros
            # encountered a non-numeric character, end of mass
            # now, determine if metastable state is listed or if element is listed next
            # first, check to see if any other numerals are in string
            lni = 0 # last numeral index
            for i in range(ci,len(nuc_str)):
                if isdigit_list[i]:
                    lni = i
            if lni != 0:
                # grab all characters between ci and last numeral as metastable state
                isost = nuc_str[ci:lni+1]
                ci = lni + 1
            else: # no more numerals in string, now check for single lower-case letter
                if isalpha_list[ci] and nuc_str[ci].islower():
                    isost = nuc_str[ci]
                    ci += 1

            # Now extract elemental symbol
            for i in range(ci,len(nuc_str)):
                if isalpha_list[i]:
                    symbol += nuc_str[i]

    else: # if elemental symbol is listed first
        if &#39;nat&#39; in nuc_str:
            mass = &#39;nat&#39;
            nuc_str = nuc_str.replace(&#39;nat&#39;,&#39;&#39;)

        ci = 0
        # Extract all characters before first number as the elemental symbol
        while nuc_str[ci].isalpha():
            symbol += nuc_str[ci]
            ci += 1

        # now, extract mass
        if mass != &#39;nat&#39;:
            while nuc_str[ci].isdigit():
                mass += nuc_str[ci]
                ci += 1
                if ci == len(nuc_str):
                    break

            # lastly, extract isomeric state, if present
            if ci != len(nuc_str):
                isost = nuc_str[ci:]

    # treating the cases of lowercase-specified particles (n, d, t, etc.)
    if symbol == &#39;&#39; and isost != &#39;&#39;:
        symbol = isost
        isost = &#39;&#39;

    # Now assemble LaTeX string for nuclides
    if include_Z:
        if symbol == &#39;n&#39;:
            Z = 0
        elif symbol == &#39;p&#39; or symbol == &#39;d&#39; or symbol == &#39;t&#39;:
            Z = 1
        else:
            Z = Element_Sym_to_Z(symbol)
        Z = str(int(Z))
        tex_str = r&#34;$^{{{}{}}}_{{{}}}$&#34;.format(mass,isost,Z) + &#34;{}&#34;.format(symbol)
    else:
        tex_str = r&#34;$^{{{}{}}}$&#34;.format(mass,isost) + &#34;{}&#34;.format(symbol)

    return tex_str</code></pre>
</details>
</dd>
<dt id="PHITS_tools.Element_Z_to_Sym"><code class="name flex">
<span>def <span class="ident">Element_Z_to_Sym</span></span>(<span>Z)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Returns elemental symbol for a provided atomic number Z</p>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>Z</code> = atomic number</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>sym</code> = string of elemental symbol for element of atomic number Z</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Element_Z_to_Sym(Z):
    &#39;&#39;&#39;
    Description:
        Returns elemental symbol for a provided atomic number Z

    Inputs:
        - `Z` = atomic number

    Outputs:
        - `sym` = string of elemental symbol for element of atomic number Z
    &#39;&#39;&#39;
    elms = [&#34;n &#34;,\
            &#34;H &#34;,&#34;He&#34;,&#34;Li&#34;,&#34;Be&#34;,&#34;B &#34;,&#34;C &#34;,&#34;N &#34;,&#34;O &#34;,&#34;F &#34;,&#34;Ne&#34;,\
            &#34;Na&#34;,&#34;Mg&#34;,&#34;Al&#34;,&#34;Si&#34;,&#34;P &#34;,&#34;S &#34;,&#34;Cl&#34;,&#34;Ar&#34;,&#34;K &#34;,&#34;Ca&#34;,\
            &#34;Sc&#34;,&#34;Ti&#34;,&#34;V &#34;,&#34;Cr&#34;,&#34;Mn&#34;,&#34;Fe&#34;,&#34;Co&#34;,&#34;Ni&#34;,&#34;Cu&#34;,&#34;Zn&#34;,\
            &#34;Ga&#34;,&#34;Ge&#34;,&#34;As&#34;,&#34;Se&#34;,&#34;Br&#34;,&#34;Kr&#34;,&#34;Rb&#34;,&#34;Sr&#34;,&#34;Y &#34;,&#34;Zr&#34;,\
            &#34;Nb&#34;,&#34;Mo&#34;,&#34;Tc&#34;,&#34;Ru&#34;,&#34;Rh&#34;,&#34;Pd&#34;,&#34;Ag&#34;,&#34;Cd&#34;,&#34;In&#34;,&#34;Sn&#34;,\
            &#34;Sb&#34;,&#34;Te&#34;,&#34;I &#34;,&#34;Xe&#34;,&#34;Cs&#34;,&#34;Ba&#34;,&#34;La&#34;,&#34;Ce&#34;,&#34;Pr&#34;,&#34;Nd&#34;,\
            &#34;Pm&#34;,&#34;Sm&#34;,&#34;Eu&#34;,&#34;Gd&#34;,&#34;Tb&#34;,&#34;Dy&#34;,&#34;Ho&#34;,&#34;Er&#34;,&#34;Tm&#34;,&#34;Yb&#34;,\
            &#34;Lu&#34;,&#34;Hf&#34;,&#34;Ta&#34;,&#34;W &#34;,&#34;Re&#34;,&#34;Os&#34;,&#34;Ir&#34;,&#34;Pt&#34;,&#34;Au&#34;,&#34;Hg&#34;,\
            &#34;Tl&#34;,&#34;Pb&#34;,&#34;Bi&#34;,&#34;Po&#34;,&#34;At&#34;,&#34;Rn&#34;,&#34;Fr&#34;,&#34;Ra&#34;,&#34;Ac&#34;,&#34;Th&#34;,\
            &#34;Pa&#34;,&#34;U &#34;,&#34;Np&#34;,&#34;Pu&#34;,&#34;Am&#34;,&#34;Cm&#34;,&#34;Bk&#34;,&#34;Cf&#34;,&#34;Es&#34;,&#34;Fm&#34;,\
            &#34;Md&#34;,&#34;No&#34;,&#34;Lr&#34;,&#34;Rf&#34;,&#34;Db&#34;,&#34;Sg&#34;,&#34;Bh&#34;,&#34;Hs&#34;,&#34;Mt&#34;,&#34;Ds&#34;,\
            &#34;Rg&#34;,&#34;Cn&#34;,&#34;Nh&#34;,&#34;Fl&#34;,&#34;Mc&#34;,&#34;Lv&#34;,&#34;Ts&#34;,&#34;Og&#34;]
    i = int(Z)
    if i &lt; 0 or i &gt; len(elms):
        print(&#39;Z={} is not valid, please select a number from 0 to 118 (inclusive).&#39;.format(str(Z)))
        return None
    return elms[i].strip()</code></pre>
</details>
</dd>
<dt id="PHITS_tools.Element_Sym_to_Z"><code class="name flex">
<span>def <span class="ident">Element_Sym_to_Z</span></span>(<span>sym)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Returns atomic number Z for a provided elemental symbol</p>
<h2 id="dependencies">Dependencies</h2>
<p><code><a title="PHITS_tools.find" href="#PHITS_tools.find">find()</a></code> (function within the "Hunter's tools" package)</p>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>sym</code> = string of elemental symbol for element of atomic number Z</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>Z</code> = atomic number</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Element_Sym_to_Z(sym):
    &#39;&#39;&#39;
    Description:
        Returns atomic number Z for a provided elemental symbol

    Dependencies:
        `find` (function within the &#34;Hunter&#39;s tools&#34; package)

    Inputs:
        - `sym` = string of elemental symbol for element of atomic number Z

    Outputs:
        - `Z` = atomic number
    &#39;&#39;&#39;
    elms = [&#34;n &#34;,\
            &#34;H &#34;,&#34;He&#34;,&#34;Li&#34;,&#34;Be&#34;,&#34;B &#34;,&#34;C &#34;,&#34;N &#34;,&#34;O &#34;,&#34;F &#34;,&#34;Ne&#34;,\
            &#34;Na&#34;,&#34;Mg&#34;,&#34;Al&#34;,&#34;Si&#34;,&#34;P &#34;,&#34;S &#34;,&#34;Cl&#34;,&#34;Ar&#34;,&#34;K &#34;,&#34;Ca&#34;,\
            &#34;Sc&#34;,&#34;Ti&#34;,&#34;V &#34;,&#34;Cr&#34;,&#34;Mn&#34;,&#34;Fe&#34;,&#34;Co&#34;,&#34;Ni&#34;,&#34;Cu&#34;,&#34;Zn&#34;,\
            &#34;Ga&#34;,&#34;Ge&#34;,&#34;As&#34;,&#34;Se&#34;,&#34;Br&#34;,&#34;Kr&#34;,&#34;Rb&#34;,&#34;Sr&#34;,&#34;Y &#34;,&#34;Zr&#34;,\
            &#34;Nb&#34;,&#34;Mo&#34;,&#34;Tc&#34;,&#34;Ru&#34;,&#34;Rh&#34;,&#34;Pd&#34;,&#34;Ag&#34;,&#34;Cd&#34;,&#34;In&#34;,&#34;Sn&#34;,\
            &#34;Sb&#34;,&#34;Te&#34;,&#34;I &#34;,&#34;Xe&#34;,&#34;Cs&#34;,&#34;Ba&#34;,&#34;La&#34;,&#34;Ce&#34;,&#34;Pr&#34;,&#34;Nd&#34;,\
            &#34;Pm&#34;,&#34;Sm&#34;,&#34;Eu&#34;,&#34;Gd&#34;,&#34;Tb&#34;,&#34;Dy&#34;,&#34;Ho&#34;,&#34;Er&#34;,&#34;Tm&#34;,&#34;Yb&#34;,\
            &#34;Lu&#34;,&#34;Hf&#34;,&#34;Ta&#34;,&#34;W &#34;,&#34;Re&#34;,&#34;Os&#34;,&#34;Ir&#34;,&#34;Pt&#34;,&#34;Au&#34;,&#34;Hg&#34;,\
            &#34;Tl&#34;,&#34;Pb&#34;,&#34;Bi&#34;,&#34;Po&#34;,&#34;At&#34;,&#34;Rn&#34;,&#34;Fr&#34;,&#34;Ra&#34;,&#34;Ac&#34;,&#34;Th&#34;,\
            &#34;Pa&#34;,&#34;U &#34;,&#34;Np&#34;,&#34;Pu&#34;,&#34;Am&#34;,&#34;Cm&#34;,&#34;Bk&#34;,&#34;Cf&#34;,&#34;Es&#34;,&#34;Fm&#34;,\
            &#34;Md&#34;,&#34;No&#34;,&#34;Lr&#34;,&#34;Rf&#34;,&#34;Db&#34;,&#34;Sg&#34;,&#34;Bh&#34;,&#34;Hs&#34;,&#34;Mt&#34;,&#34;Ds&#34;,\
            &#34;Rg&#34;,&#34;Cn&#34;,&#34;Nh&#34;,&#34;Fl&#34;,&#34;Mc&#34;,&#34;Lv&#34;,&#34;Ts&#34;,&#34;Og&#34;]

    if len(sym.strip())&gt;2:
        print(&#39;Please provide a valid elemental symbol (1 or 2 characters), {} is too long&#39;.format(sym))
        return -1

    # handle exception for neutron first
    if sym.strip()==&#39;XX&#39;:
        return 0

    # make sure string is formatted to match entries in elms list
    sym2 = sym.strip()
    if len(sym2)==1: sym2 += &#39; &#39;
    sym2 = sym2[0].upper() + sym2[1].lower()

    Z = find(sym2,elms)

    if Z==None:
        print(&#39;Z could not be found for element &#34;{}&#34;; please make sure entry is correct.&#39;.format(sym))
        return -1

    return Z</code></pre>
</details>
</dd>
<dt id="PHITS_tools.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>target, myList)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Search for and return the index of the first occurance of a value in a list.</p>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>target</code> = value to be searched for</li>
<li><code>myList</code> = list of values</li>
</ul>
<h2 id="output">Output</h2>
<ul>
<li>index of first instance of <code>target</code> in <code>myList</code></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(target, myList):
    &#39;&#39;&#39;
    Description:
        Search for and return the index of the first occurance of a value in a list.

    Inputs:
        - `target` = value to be searched for
        - `myList` = list of values

    Output:
        - index of first instance of `target` in `myList`
    &#39;&#39;&#39;
    for i in range(len(myList)):
        if myList[i] == target:
            return i</code></pre>
</details>
</dd>
<dt id="PHITS_tools.ICRP116_effective_dose_coeff"><code class="name flex">
<span>def <span class="ident">ICRP116_effective_dose_coeff</span></span>(<span>E=1.0, particle='photon', geometry='AP', interp_scale='log', interp_type='cubic', extrapolation_on=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>For a given particle at a given energy in a given geometry, returns its
effective dose conversion coefficient from ICRP 116</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code>import numpy as np</code></li>
<li><code>from scipy.interpolate import CubicSpline, lagrange, interp1d</code></li>
<li><code><a title="PHITS_tools.find" href="#PHITS_tools.find">find()</a></code> (function within the "PHITS Tools" package)</li>
</ul>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>E</code> = energy of the particle in MeV (D=<code>1</code>)</li>
<li><code>particle</code> = select particle (D=<code>'photon'</code>, options include: <code>['photon', 'electron', 'positron' ,'neutron' ,'proton', 'negmuon', 'posmuon', 'negpion', 'pospion', 'He3ion']</code>)</li>
<li><code>geometry</code> = geometric arrangement (D=<code>'AP'</code>, options include: <code>['AP', 'PA', 'LLAT', 'RLAT', 'ROT', 'ISO', 'H*(10)']</code> (<code>'LLAT'</code>,<code>'RLAT'</code>,<code>'ROT'</code> only available for photon, proton, and neutron))<ul>
<li>Meanings:
AP, antero-posterior; PA, postero-anterior; LLAT, left lateral; RLAT, right lateral; ROT, rotational; ISO, isotropic.</li>
<li>Note: <code>'H*(10)'</code> ambient dose equivalent is available for photons only</li>
</ul>
</li>
<li><code>interp_scale</code> = interpolation scale (D=<code>'log'</code> to interpolate on a log scale, options include: <code>['log','lin']</code>, ICRP 74/116 suggest log-log cubic interpolation)</li>
<li><code>interp_type</code>
= interpolation method (D=<code>'cubic'</code> to interpolate with a cubic spline, options include: <code>['cubic','linear']</code>, ICRP 74/116 suggest log-log cubic interpolation)
technically, any options available for scipy.interpolate.interp1d() can be used: <code>['linear', 'nearest', 'zero', 'slinear', 'quadratic', 'cubic', 'previous']</code></li>
<li>
<p><code>extrapolation_on</code> = boolean designating whether values outside of the tabulated energies will be extrapolated (D=<code>False</code>)</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>if False &amp; E &lt; E_min</td>
<td>f(E) = 0</td>
</tr>
<tr>
<td>if False &amp; E &gt; E_max</td>
<td>f(E) = f(E_max)</td>
</tr>
<tr>
<td>if True
&amp; E &lt; E_min</td>
<td>f(E) is linearly interpolated between (0,0) and (E_min,f(E_min))</td>
</tr>
<tr>
<td>if True
&amp; E &gt; E_max</td>
<td>f(E) is extrapolated using the specified interpolation scale and type</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>f</code> = effective dose conversion coefficient in pSv*cm^2</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ICRP116_effective_dose_coeff(E=1.0,particle=&#39;photon&#39;,geometry=&#39;AP&#39;,interp_scale=&#39;log&#39;,interp_type=&#39;cubic&#39;,extrapolation_on=False):
    &#39;&#39;&#39;
    Description:
        For a given particle at a given energy in a given geometry, returns its
        effective dose conversion coefficient from ICRP 116

    Dependencies:
        - `import numpy as np`
        - `from scipy.interpolate import CubicSpline, lagrange, interp1d`
        - `find` (function within the &#34;PHITS Tools&#34; package)

    Inputs:
       - `E` = energy of the particle in MeV (D=`1`)
       - `particle` = select particle (D=`&#39;photon&#39;`, options include: `[&#39;photon&#39;, &#39;electron&#39;, &#39;positron&#39; ,&#39;neutron&#39; ,&#39;proton&#39;, &#39;negmuon&#39;, &#39;posmuon&#39;, &#39;negpion&#39;, &#39;pospion&#39;, &#39;He3ion&#39;]`)
       - `geometry` = geometric arrangement (D=`&#39;AP&#39;`, options include: `[&#39;AP&#39;, &#39;PA&#39;, &#39;LLAT&#39;, &#39;RLAT&#39;, &#39;ROT&#39;, &#39;ISO&#39;, &#39;H*(10)&#39;]` (`&#39;LLAT&#39;`,`&#39;RLAT&#39;`,`&#39;ROT&#39;` only available for photon, proton, and neutron))
              - Meanings:
               AP, antero-posterior; PA, postero-anterior; LLAT, left lateral; RLAT, right lateral; ROT, rotational; ISO, isotropic.
              - Note: `&#39;H*(10)&#39;` ambient dose equivalent is available for photons only
       - `interp_scale` = interpolation scale (D=`&#39;log&#39;` to interpolate on a log scale, options include: `[&#39;log&#39;,&#39;lin&#39;]`, ICRP 74/116 suggest log-log cubic interpolation)
       - `interp_type`  = interpolation method (D=`&#39;cubic&#39;` to interpolate with a cubic spline, options include: `[&#39;cubic&#39;,&#39;linear&#39;]`, ICRP 74/116 suggest log-log cubic interpolation)
                                              technically, any options available for scipy.interpolate.interp1d() can be used: `[&#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;, &#39;previous&#39;]`
       - `extrapolation_on` = boolean designating whether values outside of the tabulated energies will be extrapolated (D=`False`)

             |                      |                                                                       |
             | -------------------- | --------------------------------------------------------------------- |
             | if False &amp; E &lt; E_min | f(E) = 0                                                              |
             | if False &amp; E &gt; E_max | f(E) = f(E_max)                                                       |
             | if True  &amp; E &lt; E_min | f(E) is linearly interpolated between (0,0) and (E_min,f(E_min))      |
             | if True  &amp; E &gt; E_max | f(E) is extrapolated using the specified interpolation scale and type |
    Outputs:
       - `f` = effective dose conversion coefficient in pSv*cm^2
    &#39;&#39;&#39;
    import numpy as np
    from scipy.interpolate import CubicSpline, lagrange, interp1d

    pars_list = [&#39;photon&#39;,&#39;electron&#39;,&#39;positron&#39;,&#39;neutron&#39;,&#39;proton&#39;,&#39;negmuon&#39;,&#39;posmuon&#39;,&#39;negpion&#39;,&#39;pospion&#39;,&#39;He3ion&#39;]
    geo_list_all = [&#39;AP&#39;,&#39;PA&#39;,&#39;LLAT&#39;,&#39;RLAT&#39;,&#39;ROT&#39;,&#39;ISO&#39;,&#39;H*(10)&#39;]
    geo_list_short = [&#39;AP&#39;,&#39;PA&#39;,&#39;ISO&#39;]

    if particle not in pars_list or geometry not in geo_list_all:
        pstr = &#39;Please select a valid particle and geometry.\n&#39;
        pstr += &#34;Particle selected = {}, options include: [&#39;photon&#39;,&#39;electron&#39;,&#39;positron&#39;,&#39;neutron&#39;,&#39;proton&#39;,&#39;negmuon&#39;,&#39;posmuon&#39;,&#39;negpion&#39;,&#39;pospion&#39;,&#39;He3ion&#39;]&#34;.format(particle)
        pstr += &#34;Geometry selected = {}, options include: [&#39;AP&#39;,&#39;PA&#39;,&#39;LLAT&#39;,&#39;RLAT&#39;,&#39;ROT&#39;,&#39;ISO&#39;] (&#39;LLAT&#39;,&#39;RLAT&#39;,&#39;ROT&#39; only available for photon, proton, and neutron)&#34;
        print(pstr)
        return None

    if (particle not in [&#39;photon&#39;,&#39;neutron&#39;,&#39;proton&#39;] and geometry in [&#39;LLAT&#39;,&#39;RLAT&#39;,&#39;ROT&#39;]) or (particle!=&#39;photon&#39; and geometry==&#39;H*(10)&#39;):
        if (particle!=&#39;photon&#39; and geometry==&#39;H*(10)&#39;):
            pstr = &#34;geometry = {} is only available for photons\n&#34;.format(geometry)
        else:
            pstr = &#34;geometry = {} is only available for photon, neutron, and proton\n&#34;.format(geometry)
            pstr += &#34;For selected particle = {}, please choose geometry from [&#39;AP&#39;,&#39;PA&#39;,&#39;ISO&#39;]&#34;.format(particle)
        print(pstr)
        return None

    E_photon = [0.01, 0.015, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.511, 0.6, 0.662, 0.8, 1, 1.117, 1.33, 1.5, 2, 3, 4, 5, 6, 6.129, 8, 10, 15, 20, 30, 40, 50, 60, 80, 100, 150, 200, 300, 400, 500, 600, 800, 1000, 1500, 2000, 3000, 4000, 5000, 6000, 8000, 10000]
    f_photon = [
    [0.0685, 0.156, 0.225, 0.313, 0.351, 0.37, 0.39, 0.413, 0.444, 0.519, 0.748, 1, 1.51, 2, 2.47, 2.52, 2.91, 3.17, 3.73, 4.49, 4.9, 5.59, 6.12, 7.48, 9.75, 11.7, 13.4, 15, 15.1, 17.8, 20.5, 26.1, 30.8, 37.9, 43.1, 47.1, 50.1, 54.5, 57.8, 63.3, 67.3, 72.3, 75.5, 77.5, 78.9, 80.5, 81.7, 83.8, 85.2, 86.9, 88.1, 88.9, 89.5, 90.2, 90.7],
    [0.0184, 0.0155, 0.026, 0.094, 0.161, 0.208, 0.242, 0.271, 0.301, 0.361, 0.541, 0.741, 1.16, 1.57, 1.98, 2.03, 2.38, 2.62, 3.13, 3.83, 4.22, 4.89, 5.39, 6.75, 9.12, 11.2, 13.1, 15, 15.2, 18.6, 22, 30.3, 38.2, 51.4, 62, 70.4, 76.9, 86.6, 93.2, 104, 111, 119, 124, 128, 131, 135, 138, 142, 145, 148, 150, 152, 153, 155, 155],
    [0.0189, 0.0416, 0.0655, 0.11, 0.14, 0.16, 0.177, 0.194, 0.214, 0.259, 0.395, 0.552, 0.888, 1.24, 1.58, 1.62, 1.93, 2.14, 2.59, 3.23, 3.58, 4.2, 4.68, 5.96, 8.21, 10.2, 12, 13.7, 13.9, 17, 20.1, 27.4, 34.4, 47.4, 59.2, 69.5, 78.3, 92.4, 103, 121, 133, 148, 158, 165, 170, 178, 183, 193, 198, 206, 212, 216, 219, 224, 228],
    [0.0182, 0.039, 0.0573, 0.0891, 0.114, 0.133, 0.15, 0.167, 0.185, 0.225, 0.348, 0.492, 0.802, 1.13, 1.45, 1.49, 1.78, 1.98, 2.41, 3.03, 3.37, 3.98, 4.45, 5.7, 7.9, 9.86, 11.7, 13.4, 13.6, 16.6, 19.7, 27.1, 34.4, 48.1, 60.9, 72.2, 82, 97.9, 110, 130, 143, 161, 172, 180, 186, 195, 201, 212, 220, 229, 235, 240, 244, 251, 255],
    [0.0337, 0.0664, 0.0986, 0.158, 0.199, 0.226, 0.248, 0.273, 0.297, 0.355, 0.528, 0.721, 1.12, 1.52, 1.92, 1.96, 2.3, 2.54, 3.04, 3.72, 4.1, 4.75, 5.24, 6.55, 8.84, 10.8, 12.7, 14.4, 14.6, 17.6, 20.6, 27.7, 34.4, 46.1, 56, 64.4, 71.2, 82, 89.7, 102, 111, 121, 128, 133, 136, 142, 145, 152, 156, 161, 165, 168, 170, 172, 175],
    [0.0288, 0.056, 0.0812, 0.127, 0.158, 0.18, 0.199, 0.218, 0.239, 0.287, 0.429, 0.589, 0.932, 1.28, 1.63, 1.67, 1.97, 2.17, 2.62, 3.25, 3.6, 4.2, 4.66, 5.9, 8.08, 10, 11.8, 13.5, 13.7, 16.6, 19.6, 26.8, 33.8, 46.1, 56.9, 66.2, 74.1, 87.2, 97.5, 116, 130, 147, 159, 168, 174, 185, 193, 208, 218, 232, 243, 251, 258, 268, 276],
    [0.061, 0.83, 1.05, 0.81, 0.64, 0.55, 0.51, 0.52, 0.53, 0.61, 0.89, 1.20, 1.80, 2.38, 2.93, 2.99, 3.44, 3.73, 4.38, 5.20, 5.60, 6.32, 6.90, 8.60, 11.10, 13.40, 15.50, 17.60, 17.86, 21.60, 25.60, 8.53, 8.29, 8.23, 8.26, 8.64, 8.71, 8.86, 9.00, 9.60, 10.20, 10.73, 11.27, 11.80, 11.78, 11.74, 11.70, 11.60, 11.50, 12.10, 12.70, 13.30, 13.08, 12.64, 12.20]
    ]

    E_electron = [0.01, 0.015, 0.02, 0.03, 0.04, 0.05, 0.06, 0.08, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.8, 1, 1.5, 2, 3, 4, 5, 6, 8, 10, 15, 20, 30, 40, 50, 60, 80, 100, 150, 200, 300, 400, 500, 600, 800, 1000, 1500, 2000, 3000, 4000, 5000, 6000, 8000, 10000]
    f_electron = [
    [0.0269, 0.0404, 0.0539, 0.081, 0.108, 0.135, 0.163, 0.218, 0.275, 0.418, 0.569, 0.889, 1.24, 1.63, 2.05, 4.04, 7.1, 15, 22.4, 36.1, 48.2, 59.3, 70.6, 97.9, 125, 188, 236, 302, 329, 337, 341, 346, 349, 355, 359, 365, 369, 372, 375, 379, 382, 387, 391, 397, 401, 405, 407, 411, 414],
    [0.0268, 0.0402, 0.0535, 0.0801, 0.107, 0.133, 0.16, 0.213, 0.267, 0.399, 0.53, 0.787, 1.04, 1.28, 1.5, 1.68, 1.68, 1.62, 1.62, 1.95, 2.62, 3.63, 5.04, 9.46, 18.3, 53.1, 104, 220, 297, 331, 344, 358, 366, 379, 388, 399, 408, 414, 419, 428, 434, 446, 455, 468, 477, 484, 490, 499, 507],
    [0.0188, 0.0283, 0.0377, 0.0567, 0.0758, 0.0948, 0.114, 0.152, 0.191, 0.291, 0.393, 0.606, 0.832, 1.08, 1.35, 1.97, 2.76, 4.96, 7.24, 11.9, 16.4, 21, 25.5, 35.5, 46.7, 76.9, 106, 164, 212, 249, 275, 309, 331, 363, 383, 410, 430, 445, 457, 478, 495, 525, 549, 583, 608, 628, 646, 675, 699]
    ]

    E_positron = [0.01, 0.015, 0.02, 0.03, 0.04, 0.05, 0.06, 0.08, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.8, 1, 1.5, 2, 3, 4, 5, 6, 8, 10, 15, 20, 30, 40, 50, 60, 80, 100, 150, 200, 300, 400, 500, 600, 800, 1000, 1500, 2000, 3000, 4000, 5000, 6000, 8000, 10000]
    f_positron = [
    [3.28, 3.29, 3.3, 3.33, 3.36, 3.39, 3.42, 3.47, 3.53, 3.67, 3.84, 4.16, 4.52, 4.9, 5.36, 7.41, 10.5, 18.3, 25.7, 39.1, 51, 61.7, 72.9, 99, 126, 184, 229, 294, 320, 327, 333, 339, 342, 349, 354, 362, 366, 369, 372, 376, 379, 385, 389, 395, 399, 402, 404, 408, 411],
    [1.62, 1.64, 1.65, 1.68, 1.71, 1.73, 1.76, 1.82, 1.87, 2.01, 2.14, 2.4, 2.65, 2.9, 3.12, 3.32, 3.37, 3.44, 3.59, 4.19, 5.11, 6.31, 8.03, 14, 23.6, 59, 111, 221, 291, 321, 334, 349, 357, 371, 381, 393, 402, 409, 415, 424, 430, 443, 451, 465, 473, 480, 486, 495, 503],
    [1.39, 1.4, 1.41, 1.43, 1.45, 1.47, 1.49, 1.53, 1.57, 1.67, 1.77, 1.98, 2.21, 2.45, 2.72, 3.38, 4.2, 6.42, 8.7, 13.3, 18, 22.4, 26.9, 36.7, 47.6, 75.5, 104, 162, 209, 243, 268, 302, 323, 356, 377, 405, 425, 440, 453, 474, 491, 522, 545, 580, 605, 627, 645, 674, 699]
    ]

    E_neutron = [1.00E-09, 1.00E-08, 2.50E-08, 1.00E-07, 2.00E-07, 5.00E-07, 1.00E-06, 2.00E-06, 5.00E-06, 1.00E-05, 2.00E-05, 5.00E-05, 1.00E-04, 2.00E-04, 5.00E-04, 0.001, 0.002, 0.005, 0.01, 0.02, 0.03, 0.05, 0.07, 0.1, 0.15, 0.2, 0.3, 0.5, 0.7, 0.9, 1, 1.2, 1.5, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 30, 50, 75, 100, 130, 150, 180, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 2000, 5000, 10000]
    f_neutron = [
    [3.09, 3.55, 4, 5.2, 5.87, 6.59, 7.03, 7.39, 7.71, 7.82, 7.84, 7.82, 7.79, 7.73, 7.54, 7.54, 7.61, 7.97, 9.11, 12.2, 15.7, 23, 30.6, 41.9, 60.6, 78.8, 114, 177, 232, 279, 301, 330, 365, 407, 458, 483, 494, 498, 499, 499, 500, 500, 499, 495, 493, 490, 484, 477, 474, 453, 433, 420, 402, 382, 373, 363, 359, 363, 389, 422, 457, 486, 508, 524, 537, 612, 716, 933],
    [1.85, 2.11, 2.44, 3.25, 3.72, 4.33, 4.73, 5.02, 5.3, 5.44, 5.51, 5.55, 5.57, 5.59, 5.6, 5.6, 5.62, 5.95, 6.81, 8.93, 11.2, 15.7, 20, 25.9, 34.9, 43.1, 58.1, 85.9, 112, 136, 148, 167, 195, 235, 292, 330, 354, 371, 383, 392, 398, 404, 412, 417, 419, 420, 422, 423, 423, 422, 428, 439, 444, 446, 446, 447, 448, 464, 496, 533, 569, 599, 623, 640, 654, 740, 924, 1.17E+03],
    [1.04, 1.15, 1.32, 1.7, 1.94, 2.21, 2.4, 2.52, 2.64, 2.65, 2.68, 2.66, 2.65, 2.66, 2.62, 2.61, 2.6, 2.74, 3.13, 4.21, 5.4, 7.91, 10.5, 14.4, 20.8, 27.2, 39.7, 63.7, 85.5, 105, 115, 130, 150, 179, 221, 249, 269, 284, 295, 303, 310, 316, 325, 333, 336, 338, 343, 347, 348, 360, 380, 399, 409, 416, 420, 425, 427, 441, 472, 510, 547, 579, 603, 621, 635, 730, 963, 1.23E+03],
    [0.893, 0.978, 1.12, 1.42, 1.63, 1.86, 2.02, 2.11, 2.21, 2.24, 2.26, 2.24, 2.23, 2.24, 2.21, 2.21, 2.2, 2.33, 2.67, 3.6, 4.62, 6.78, 8.95, 12.3, 17.9, 23.4, 34.2, 54.4, 72.6, 89.3, 97.4, 110, 128, 153, 192, 220, 240, 255, 267, 276, 284, 290, 301, 310, 313, 317, 323, 328, 330, 345, 370, 392, 404, 413, 418, 425, 429, 451, 483, 523, 563, 597, 620, 638, 651, 747, 979, 1.26E+03],
    [1.7, 2.03, 2.31, 2.98, 3.36, 3.86, 4.17, 4.4, 4.59, 4.68, 4.72, 4.73, 4.72, 4.67, 4.6, 4.58, 4.61, 4.86, 5.57, 7.41, 9.46, 13.7, 18, 24.3, 34.7, 44.7, 63.8, 99.1, 131, 160, 174, 193, 219, 254, 301, 331, 351, 365, 374, 381, 386, 390, 395, 398, 398, 399, 399, 398, 398, 395, 395, 402, 406, 411, 414, 418, 422, 443, 472, 503, 532, 558, 580, 598, 614, 718, 906, 1.14E+03],
    [1.29, 1.56, 1.76, 2.26, 2.54, 2.92, 3.15, 3.32, 3.47, 3.52, 3.54, 3.55, 3.54, 3.52, 3.47, 3.46, 3.48, 3.66, 4.19, 5.61, 7.18, 10.4, 13.7, 18.6, 26.6, 34.4, 49.4, 77.1, 102, 126, 137, 153, 174, 203, 244, 271, 290, 303, 313, 321, 327, 332, 339, 344, 346, 347, 350, 352, 353, 358, 371, 387, 397, 407, 412, 421, 426, 455, 488, 521, 553, 580, 604, 624, 642, 767, 1.01E+03, 1.32E+03]
    ]

    E_proton = [1, 1.5, 2, 3, 4, 5, 6, 8, 10, 15, 20, 30, 40, 50, 60, 80, 100, 150, 200, 300, 400, 500, 600, 800, 1000, 1500, 2000, 3000, 4000, 5000, 6000, 8000, 10000]
    f_proton = [
    [5.46, 8.2, 10.9, 16.4, 21.9, 27.3, 32.8, 43.7, 54.9, 189, 428, 750, 1.02E+03, 1.18E+03, 1.48E+03, 2.16E+03, 2.51E+03, 2.38E+03, 1.77E+03, 1.38E+03, 1.23E+03, 1.15E+03, 1.16E+03, 1.11E+03, 1.09E+03, 1.15E+03, 1.12E+03, 1.23E+03, 1.27E+03, 1.23E+03, 1.37E+03, 1.45E+03, 1.41E+03],
    [5.47, 8.21, 10.9, 16.4, 21.9, 27.3, 32.8, 43.7, 54.6, 56.1, 43.6, 36.1, 45.5, 71.5, 156, 560, 1.19E+03, 2.82E+03, 1.93E+03, 1.45E+03, 1.30E+03, 1.24E+03, 1.23E+03, 1.23E+03, 1.23E+03, 1.25E+03, 1.28E+03, 1.34E+03, 1.40E+03, 1.45E+03, 1.53E+03, 1.65E+03, 1.74E+03],
    [2.81, 4.21, 5.61, 8.43, 11.2, 14, 16.8, 22.4, 28.1, 50.7, 82.8, 180, 290, 379, 500, 799, 994, 1.64E+03, 2.15E+03, 1.44E+03, 1.27E+03, 1.21E+03, 1.20E+03, 1.19E+03, 1.18E+03, 1.21E+03, 1.25E+03, 1.32E+03, 1.31E+03, 1.39E+03, 1.44E+03, 1.56E+03, 1.63E+03],
    [2.81, 4.2, 5.62, 8.41, 11.2, 14, 16.8, 22.4, 28.1, 48.9, 78.8, 172, 278, 372, 447, 602, 818, 1.46E+03, 2.18E+03, 1.45E+03, 1.28E+03, 1.21E+03, 1.20E+03, 1.20E+03, 1.20E+03, 1.23E+03, 1.25E+03, 1.32E+03, 1.33E+03, 1.41E+03, 1.45E+03, 1.59E+03, 1.67E+03],
    [4.5, 6.75, 8.98, 13.4, 17.8, 22.1, 26.3, 34.5, 50.1, 93.7, 165, 296, 422, 532, 687, 1.09E+03, 1.44E+03, 2.16E+03, 1.96E+03, 1.44E+03, 1.28E+03, 1.22E+03, 1.22E+03, 1.20E+03, 1.19E+03, 1.23E+03, 1.23E+03, 1.30E+03, 1.29E+03, 1.35E+03, 1.41E+03, 1.49E+03, 1.56E+03],
    [3.52, 5.28, 7.02, 10.5, 13.9, 17.3, 20.5, 26.8, 45.8, 80.1, 136, 249, 358, 451, 551, 837, 1.13E+03, 1.79E+03, 1.84E+03, 1.42E+03, 1.25E+03, 1.18E+03, 1.17E+03, 1.17E+03, 1.15E+03, 1.21E+03, 1.22E+03, 1.31E+03, 1.40E+03, 1.43E+03, 1.57E+03, 1.71E+03, 1.78E+03]
    ]

    E_negmuon = [1, 1.5, 2, 3, 4, 5, 6, 8, 10, 15, 20, 30, 40, 50, 60, 80, 100, 150, 200, 300, 400, 500, 600, 800, 1000, 1500, 2000, 3000, 4000, 5000, 6000, 8000, 10000]
    f_negmuon = [
    [180, 180, 184, 188, 193, 205, 242, 293, 332, 414, 465, 657, 735, 755, 628, 431, 382, 340, 326, 319, 320, 321, 325, 327, 333, 331, 333, 336, 337, 337, 337, 337, 338],
    [75.2, 76.8, 78.3, 81.4, 84.8, 87.7, 86.7, 86.8, 88.6, 100, 122, 251, 457, 703, 775, 485, 402, 345, 329, 321, 321, 324, 326, 332, 337, 338, 341, 344, 345, 346, 346, 347, 347],
    [78.7, 79.5, 80.9, 83.7, 87.1, 91.5, 98.1, 113, 127, 161, 191, 275, 363, 446, 496, 498, 432, 354, 332, 321, 321, 323, 326, 331, 337, 338, 341, 344, 346, 347, 347, 348, 348]
    ]

    E_posmuon = [1, 1.5, 2, 3, 4, 5, 6, 8, 10, 15, 20, 30, 40, 50, 60, 80, 100, 150, 200, 300, 400, 500, 600, 800, 1000, 1500, 2000, 3000, 4000, 5000, 6000, 8000, 10000]
    f_posmuon = [
    [194, 196, 198, 202, 207, 216, 251, 300, 340, 425, 481, 674, 751, 768, 635, 431, 381, 339, 326, 318, 319, 320, 322, 325, 327, 331, 333, 336, 337, 337, 337, 337, 339],
    [82.6, 84.1, 85.7, 88.9, 92.1, 94.3, 92.5, 92.8, 94.8, 108, 133, 265, 473, 721, 787, 483, 399, 345, 328, 320, 321, 323, 325, 330, 333, 339, 341, 344, 345, 346, 346, 347, 347],
    [85.2, 86.2, 87.5, 90.3, 93.6, 97.7, 103, 117, 132, 167, 199, 284, 373, 456, 506, 502, 432, 354, 332, 320, 320, 322, 324, 329, 333, 338, 341, 344, 346, 347, 347, 348, 348]
    ]

    E_negpion = [1, 1.5, 2, 3, 4, 5, 6, 8, 10, 15, 20, 30, 40, 50, 60, 80, 100, 150, 200, 300, 400, 500, 600, 800, 1000, 1500, 2000, 3000, 4000, 5000, 6000, 8000, 10000, 15000, 20000, 30000, 40000, 50000, 60000, 80000, 100000, 150000, 200000]
    f_negpion = [
    [406, 422, 433, 458, 491, 528, 673, 965, 1.09E+03, 1.25E+03, 1.28E+03, 1.77E+03, 1.92E+03, 1.93E+03, 1.68E+03, 1.14E+03, 995, 927, 902, 848, 844, 869, 901, 947, 977, 1.03E+03, 1.05E+03, 1.03E+03, 1.03E+03, 1.06E+03, 1.09E+03, 1.14E+03, 1.17E+03, 1.21E+03, 1.24E+03, 1.30E+03, 1.35E+03, 1.39E+03, 1.42E+03, 1.48E+03, 1.54E+03, 1.67E+03, 1.78E+03],
    [194, 201, 210, 225, 233, 237, 208, 181, 178, 197, 244, 547, 1.02E+03, 1.70E+03, 1.99E+03, 1.31E+03, 991, 889, 871, 843, 850, 880, 917, 976, 1.02E+03, 1.08E+03, 1.12E+03, 1.11E+03, 1.13E+03, 1.18E+03, 1.22E+03, 1.29E+03, 1.34E+03, 1.41E+03, 1.47E+03, 1.56E+03, 1.63E+03, 1.70E+03, 1.75E+03, 1.86E+03, 1.95E+03, 2.15E+03, 2.33E+03],
    [176, 189, 198, 215, 232, 251, 271, 317, 361, 439, 508, 676, 868, 1.02E+03, 1.15E+03, 1.15E+03, 1.03E+03, 857, 815, 794, 807, 838, 875, 935, 979, 1.05E+03, 1.09E+03, 1.11E+03, 1.15E+03, 1.20E+03, 1.26E+03, 1.36E+03, 1.43E+03, 1.55E+03, 1.64E+03, 1.79E+03, 1.91E+03, 2.02E+03, 2.11E+03, 2.29E+03, 2.46E+03, 2.80E+03, 3.04E+03]
    ]

    E_pospion = [1, 1.5, 2, 3, 4, 5, 6, 8, 10, 15, 20, 30, 40, 50, 60, 80, 100, 150, 200, 300, 400, 500, 600, 800, 1000, 1500, 2000, 3000, 4000, 5000, 6000, 8000, 10000, 15000, 20000, 30000, 40000, 50000, 60000, 80000, 100000, 150000, 200000]
    f_pospion = [
    [314, 324, 340, 379, 429, 489, 540, 717, 819, 1000, 1.10E+03, 1.52E+03, 1.75E+03, 1.83E+03, 1.66E+03, 1.22E+03, 1.13E+03, 1.22E+03, 1.25E+03, 1.07E+03, 969, 943, 952, 999, 1.04E+03, 1.10E+03, 1.10E+03, 1.06E+03, 1.06E+03, 1.07E+03, 1.10E+03, 1.14E+03, 1.17E+03, 1.22E+03, 1.25E+03, 1.30E+03, 1.34E+03, 1.38E+03, 1.42E+03, 1.48E+03, 1.54E+03, 1.67E+03, 1.78E+03],
    [121, 125, 133, 151, 170, 183, 185, 177, 179, 201, 247, 494, 906, 1.48E+03, 1.82E+03, 1.38E+03, 1.12E+03, 1.15E+03, 1.23E+03, 1.10E+03, 998, 970, 980, 1.04E+03, 1.09E+03, 1.16E+03, 1.19E+03, 1.16E+03, 1.16E+03, 1.20E+03, 1.24E+03, 1.31E+03, 1.35E+03, 1.42E+03, 1.48E+03, 1.57E+03, 1.64E+03, 1.70E+03, 1.75E+03, 1.84E+03, 1.94E+03, 2.14E+03, 2.33E+03],
    [151, 160, 168, 183, 198, 216, 233, 265, 296, 367, 439, 602, 787, 953, 1.09E+03, 1.16E+03, 1.10E+03, 1.05E+03, 1.08E+03, 1.02E+03, 953, 930, 938, 993, 1.05E+03, 1.13E+03, 1.16E+03, 1.16E+03, 1.18E+03, 1.23E+03, 1.28E+03, 1.37E+03, 1.43E+03, 1.55E+03, 1.64E+03, 1.79E+03, 1.90E+03, 2.01E+03, 2.10E+03, 2.27E+03, 2.42E+03, 2.76E+03, 3.07E+03]
    ]

    E_He3ion = [1, 2, 3, 5, 10, 14, 20, 30, 50, 75, 100, 150, 200, 300, 500, 700, 1000, 2000, 3000, 5000, 10000, 20000, 50000, 100000]
    f_He3ion = [
    [219, 438, 656, 1.09E+03, 2.19E+03, 4.61E+03, 1.72E+04, 3.01E+04, 4.75E+04, 8.05E+04, 1.01E+05, 9.25E+04, 6.74E+04, 5.14E+04, 4.27E+04, 4.11E+04, 4.00E+04, 4.02E+04, 4.08E+04, 4.12E+04, 4.56E+04, 5.12E+04, 6.12E+04, 7.14E+04],
    [219, 438, 657, 1.09E+03, 2.19E+03, 2.56E+03, 1.74E+03, 1.44E+03, 2.88E+03, 1.75E+04, 4.84E+04, 1.10E+05, 7.29E+04, 5.33E+04, 4.49E+04, 4.60E+04, 4.47E+04, 4.80E+04, 5.01E+04, 5.17E+04, 6.26E+04, 6.10E+04, 8.14E+04, 1.01E+05],
    [141, 281, 419, 689, 1.82E+03, 2.81E+03, 5.46E+03, 9.86E+03, 1.78E+04, 3.00E+04, 4.55E+04, 6.95E+04, 7.01E+04, 5.25E+04, 4.27E+04, 4.19E+04, 4.09E+04, 4.31E+04, 4.50E+04, 4.76E+04, 5.73E+04, 7.10E+04, 9.67E+04, 1.24E+05]
    ]


    E_all = [E_photon, E_electron, E_positron, E_neutron, E_proton, E_negmuon, E_posmuon, E_negpion, E_pospion, E_He3ion]
    f_all = [f_photon, f_electron, f_positron, f_neutron, f_proton, f_negmuon, f_posmuon, f_negpion, f_pospion, f_He3ion]

    pi = find(particle, pars_list)
    if particle in [&#39;photon&#39;,&#39;neutron&#39;,&#39;proton&#39;]:
        gi = find(geometry, geo_list_all)
    else:
        gi = find(geometry, geo_list_short)

    E_list = E_all[pi]
    f_list = f_all[pi][gi]

    # Interpolate f given E
    if E in E_list:
        f = f_list[find(E,E_list)]
    else:
        if not extrapolation_on and (E &lt; E_list[0] or E &gt; E_list[-1]):  # E is outside of bounds and extrapolation is off
            if E &lt; E_list[0]:
                f = 0   # assume negligibly low energy particle
            if E &gt; E_list[-1]:
                f = f_list[-1]  # just set equal to max energy particle&#39;s coefficient
        else:
            if E &lt; E_list[0]:
                E_list = [0] + E_list
                f_list = [0] + f_list
                interp_scale = &#39;linear&#39;

            if interp_scale==&#39;log&#39;:
                cs = interp1d(np.log10(np.array(E_list)),np.log10(np.array(f_list)), kind=interp_type,fill_value=&#39;extrapolate&#39;)
                f = 10**cs(np.log10(E))
            else:
                cs = interp1d(np.array(E_list),np.array(f_list), kind=interp_type,fill_value=&#39;extrapolate&#39;)
                f = cs(E)

            # for sake of sanity, return zero for values quite below minimum coefficients
            if f &lt; 1e-4:
                f = 0.0


        #if interp_type==&#39;cubic&#39;:
        #    if interp_scale==&#39;log&#39;:
        #        cs = interp1d(np.log10(np.array(E_list)),np.log10(np.array(f_list)), kind=&#39;cubic&#39;,fill_value=&#39;extrapolate&#39;)
        #        f = 10**cs(np.log10(E))
        #    else:
        #        cs = interp1d(np.array(E_list),np.array(f_list), kind=&#39;cubic&#39;,fill_value=&#39;extrapolate&#39;)
        #        f = cs(E)
        #else:
        #    if interp_scale==&#39;log&#39;:
        #        f = 10**np.interp(np.log10(E),np.log10(np.array(E_list)),np.log10(np.array(f_list)))
        #    else:
        #        f = np.interp(E,np.array(E_list),np.array(f_list))

        #if interp_type==&#39;cubic&#39;:
        #    if interp_scale==&#39;log&#39;:
        #        cs = lagrange(np.log10(np.array(E_list)),np.log10(np.array(f_list)))
        #        f = 10**cs(np.log10(E))
        #    else:
        #        cs = lagrange(np.array(E_list),np.array(f_list))
        #        f = cs(E)
        #if interp_type==&#39;cubic&#39;:
        #    if interp_scale==&#39;log&#39;:
        #        cs = CubicSpline(np.log10(np.array(E_list)),np.log10(np.array(f_list)))
        #        f = 10**cs(np.log10(E))
        #    else:
        #        cs = CubicSpline(np.array(E_list),np.array(f_list))
        #        f = cs(E)

    return f</code></pre>
</details>
</dd>
<dt id="PHITS_tools.split_into_header_and_content"><code class="name flex">
<span>def <span class="ident">split_into_header_and_content</span></span>(<span>output_file_path)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Initial parsing of a PHITS tally output file to isolate its header section (containing metadata) and main
tally results "content" section for later processing.</p>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>output_file_path</code> = path to a PHITS tally output file</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>header</code> = list of lines belonging to the tally output's header section</li>
<li><code>content</code> = list of lists of remaining lines after the tally output's header section; the top level list is
broken into "blocks" ("newpage:"-separated) which are lists of lines belonging to each block/page.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_into_header_and_content(output_file_path):
    &#39;&#39;&#39;
    Description:
        Initial parsing of a PHITS tally output file to isolate its header section (containing metadata) and main
        tally results &#34;content&#34; section for later processing.

    Inputs:
        - `output_file_path` = path to a PHITS tally output file

    Outputs:
        - `header` = list of lines belonging to the tally output&#39;s header section
        - `content` = list of lists of remaining lines after the tally output&#39;s header section; the top level list is
                broken into &#34;blocks&#34; (&#34;newpage:&#34;-separated) which are lists of lines belonging to each block/page.

    &#39;&#39;&#39;
    in_content = False
    header, content = [], [[]]
    with open(output_file_path, mode=&#39;rb&#39;) as f:
        for line in f:
            if b&#39;\x00&#39; in line:
                line = line.replace(b&#34;\x00&#34;, b&#34;&#34;)
            line = line.decode()
            #if &#34;\x00&#34; in line: line = line.replace(&#34;\x00&#34;, &#34;&#34;)
            if &#39;#newpage:&#39; in line:
                in_content = True
                continue
            if in_content:
                if &#39;newpage:&#39; in line:
                    content.append([])
                    continue
                content[-1].append(line.strip())
            else:
                header.append(line.strip())
    # add &#34;footer&#34; to peel off last bit of &#34;content&#34; section?
    return header, content</code></pre>
</details>
</dd>
<dt id="PHITS_tools.extract_data_from_header_line"><code class="name flex">
<span>def <span class="ident">extract_data_from_header_line</span></span>(<span>line)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Extract a "key" and its corresponding value from a PHITS tally output header line</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code><a title="PHITS_tools.is_number" href="#PHITS_tools.is_number">is_number()</a></code> (function within the "PHITS tools" package)</li>
</ul>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>line</code> = string to be processed</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>key</code> = a string "key" to become a key in the metadata dictionary</li>
<li><code>value</code> = corresponding value they "key" is equal to; dtype is string, int, or float</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_data_from_header_line(line):
    &#39;&#39;&#39;
    Description:
        Extract a &#34;key&#34; and its corresponding value from a PHITS tally output header line

    Dependencies:
        - `is_number` (function within the &#34;PHITS tools&#34; package)

    Inputs:
        - `line` = string to be processed

    Outputs:
        - `key` = a string &#34;key&#34; to become a key in the metadata dictionary
        - `value` = corresponding value they &#34;key&#34; is equal to; dtype is string, int, or float
    &#39;&#39;&#39;
    if &#39;#&#39; in line:
        info, trash = line.split(&#39;#&#39;,1)
    else:
        info = line
    key, value = info.split(&#39;=&#39;)
    key = key.strip()
    value = value.strip()
    if is_number(value):
        if &#39;.&#39; in value:
            value = float(value)
        else:
            value = int(value)
    return key, value</code></pre>
</details>
</dd>
<dt id="PHITS_tools.data_row_to_num_list"><code class="name flex">
<span>def <span class="ident">data_row_to_num_list</span></span>(<span>line)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Extract numeric values from line of text from PHITS tally output content section</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code><a title="PHITS_tools.is_number" href="#PHITS_tools.is_number">is_number()</a></code> (function within the "PHITS tools" package)</li>
</ul>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>line</code> = string to be processed</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>values</code> = a list of ints and/or floats of numeric values in <code>line</code></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data_row_to_num_list(line):
    &#39;&#39;&#39;
    Description:
        Extract numeric values from line of text from PHITS tally output content section

    Dependencies:
        - `is_number` (function within the &#34;PHITS tools&#34; package)

    Inputs:
        - `line` = string to be processed

    Outputs:
        - `values` = a list of ints and/or floats of numeric values in `line`
    &#39;&#39;&#39;
    value_strs = line.strip().split()
    values = []
    for value in value_strs:
        if is_number(value):
            if &#39;.&#39; in value:
                value = float(value)
            else:
                value = int(value)
        values.append(value)
    return values</code></pre>
</details>
</dd>
<dt id="PHITS_tools.parse_group_string"><code class="name flex">
<span>def <span class="ident">parse_group_string</span></span>(<span>text)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Separate "groups" in a string, wherein a group is a standalone value or a series of values inside parentheses.</p>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>text</code> = string to be processed</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>groups</code> = a list of strings extracted from <code>text</code></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_group_string(text):
    &#39;&#39;&#39;
    Description:
        Separate &#34;groups&#34; in a string, wherein a group is a standalone value or a series of values inside parentheses.

    Inputs:
        - `text` = string to be processed

    Outputs:
        - `groups` = a list of strings extracted from `text`
    &#39;&#39;&#39;
    # returns list of items from PHITS-formatted string, e.g. w/ ()
    parts = text.strip().split()
    #print(parts)
    groups = []
    curly_vals = []
    in_brackets_group = False
    in_curly_brace_group = False
    num_group_members = 0
    for i in parts:
        if &#39;(&#39; in i and &#39;)&#39; in i:
            in_brackets_group = False
            groups.append(i)
        elif &#39;(&#39; in i:
            in_brackets_group = True
            groups.append(i)
        elif &#39;)&#39; in i:
            in_brackets_group = False
            num_group_members = 0
            groups[-1] += i
        elif &#39;{&#39; in i:
            in_curly_brace_group = True
            curly_vals = []
        elif &#39;}&#39; in i:
            in_curly_brace_group = False
            curly_int_strs = [str(j) for j in range(int(curly_vals[0]), int(curly_vals[-1])+1)]
            curly_vals = []
            groups += curly_int_strs
        else:
            if in_brackets_group or in_curly_brace_group:
                if in_brackets_group:
                    if num_group_members&gt;0: groups[-1] += &#39; &#39;
                    groups[-1] += i
                    num_group_members += 1
                if in_curly_brace_group:
                    if i != &#39;-&#39;:
                        curly_vals.append(i)
            else:
                groups.append(i)
    #print(groups)
    return groups</code></pre>
</details>
</dd>
<dt id="PHITS_tools.parse_tally_header"><code class="name flex">
<span>def <span class="ident">parse_tally_header</span></span>(<span>tally_header, tally_content)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Extracts metadata from PHITS tally output header (and some extra info from its contents section)</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code><a title="PHITS_tools.extract_data_from_header_line" href="#PHITS_tools.extract_data_from_header_line">extract_data_from_header_line()</a></code> (function within the "PHITS tools" package)</li>
<li><code><a title="PHITS_tools.parse_group_string" href="#PHITS_tools.parse_group_string">parse_group_string()</a></code> (function within the "PHITS tools" package)</li>
</ul>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>tally_header</code> = list of lines belonging to the tally output's header section</li>
<li><code>tally_content</code> = list of lists of remaining lines after the tally output's header section; the top level list is
broken into "blocks" ("newpage:"-separated) which are lists of lines belonging to each block/page.</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>meta</code> = Munch object / dictionary containing tally metadata</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_tally_header(tally_header,tally_content):
    &#39;&#39;&#39;
    Description:
        Extracts metadata from PHITS tally output header (and some extra info from its contents section)

    Dependencies:
        - `extract_data_from_header_line` (function within the &#34;PHITS tools&#34; package)
        - `parse_group_string` (function within the &#34;PHITS tools&#34; package)

    Inputs:
        - `tally_header` = list of lines belonging to the tally output&#39;s header section
        - `tally_content` = list of lists of remaining lines after the tally output&#39;s header section; the top level list is
                broken into &#34;blocks&#34; (&#34;newpage:&#34;-separated) which are lists of lines belonging to each block/page.

    Outputs:
        - `meta` = Munch object / dictionary containing tally metadata

    &#39;&#39;&#39;
    nlines = len(tally_header)
    tally_type = tally_header[0].replace(&#39; &#39;,&#39;&#39;).replace(&#39;off&#39;,&#39;&#39;)
    if &#39;[&#39; not in tally_type and &#39;]&#39; not in tally_type: # file is not PHITS tally output
        if &#39;htitle&#39; in tally_type:
            tally_type = &#39;[T-Dchain]&#39;
        else:
            tally_type = &#39;UNKNOWN&#39;
    meta = Munch({})
    meta.tally_type = tally_type
    unsupported_tally_types = [&#39;[T-WWG]&#39;, &#39;[T-WWBG]&#39;, &#39;[T-Volume]&#39;, &#39;[T-Userdefined]&#39;, &#39;[T-Gshow]&#39;, &#39;[T-Rshow]&#39;,
                               &#39;[T-3Dshow]&#39;, &#39;[T-4Dtrack]&#39;, &#39;[T-Dchain]&#39;, &#39;UNKNOWN&#39;]
    if tally_type in unsupported_tally_types:
        return meta
    # Initialize variables for possible array
    mesh_types = [&#39;e&#39;,&#39;t&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;,&#39;r&#39;,&#39;a&#39;,&#39;l&#39;]
    for m in mesh_types: meta[&#39;n&#39;+m] = None
    meta[&#39;reg&#39;] = None
    meta[&#39;part&#39;] = None
    meta[&#39;npart&#39;] = None
    meta[&#39;nc&#39;] = None
    meta[&#39;samepage&#39;] = &#39;part&#39;
    found_mesh_kinds = []

    reading_axis_data = False
    reading_regions = False
    in_exceptional_mesh_kind = False
    for li, line in enumerate(tally_header):
        #if line[0]==&#39;#&#39;: # commented line
        if &#39;data =&#39; in line: # data section to parse
            reading_axis_data = True
            n_values_to_read = meta[&#39;n&#39;+current_data_mesh_kind] + 1
            remaining_n_values_to_read = n_values_to_read
            data_values = []
            in_exceptional_mesh_kind = False
            #print(&#39;read &#39;,n_values_to_read,current_data_mesh_kind,&#39; values&#39;)
            continue
        elif &#39;=&#39; in line:
            if line[0] == &#39;#&#39;:  # commented line
                key, value = extract_data_from_header_line(line[1:])
            else:
                key, value = extract_data_from_header_line(line)
            if in_exceptional_mesh_kind:
                if key[0]==&#39;e&#39;:
                    key = current_data_mesh_kind + key[1:]
                elif key==&#39;ne&#39;:
                    key = &#39;n&#39; + current_data_mesh_kind
            meta[key] = value

            if &#39;type&#39; in key:
                current_data_mesh_kind = key.replace(&#39;-type&#39;,&#39;&#39;)
                if current_data_mesh_kind == &#39;se&#39;: current_data_mesh_kind = &#39;e&#39;
                current_data_mesh_type = value
                found_mesh_kinds.append(current_data_mesh_kind)
                if current_data_mesh_kind in [&#39;e1&#39;,&#39;e2&#39;]:
                    in_exceptional_mesh_kind = True
                #print(current_data_mesh_kind,current_data_mesh_type)
            if key==&#39;part&#39;:
                part_groups = parse_group_string(str(value))
                kf_groups = parse_group_string(tally_header[li + 1].split(&#39;:&#39;)[1])
                if meta[&#39;npart&#39;] == None: # first instance of &#34;part&#34;
                    meta[&#39;part_groups&#39;] = part_groups
                    meta[&#39;kf_groups&#39;] = kf_groups
                    meta[&#39;npart&#39;] = len(part_groups)
                    meta[&#39;part_serial_groups&#39;] = [&#39;p&#39;+str(gi+1)+&#39;-group&#39; for gi in range(len(part_groups))]
                else: # an additional occurance of part?
                    if &#39;multiplier&#39; not in tally_header[li - 1]: # the multiplier can also be followed by an erroneous &#34;part&#34; specification
                        for pi,pg in enumerate(part_groups):
                            if pg not in meta[&#39;part_groups&#39;]:
                                meta[&#39;part_groups&#39;] += [pg]
                                meta[&#39;kf_groups&#39;] += kf_groups[pi]
                                meta[&#39;npart&#39;] += 1
                                meta[&#39;part_serial_groups&#39;] += [&#39;p&#39; + str(pi + 1) + &#39;-group&#39;]
            if key==&#39;reg&#39;:
                if meta[&#39;tally_type&#39;]==&#39;[T-Cross]&#39;:
                    num_regs = value
                    meta[&#39;num_reg_groups&#39;] = num_regs
                    meta[&#39;reg_groups&#39;] = []
                    # manually read in reg groups
                    li_start = li+2
                    li_stop = li_start + num_regs
                    for lii in range(li_start,li_stop):
                        non, rfrom, rto, area = tally_header[lii].split()
                        meta[&#39;reg_groups&#39;].append(rfrom+&#39; - &#39;+rto)
                else:
                    reg_groups = parse_group_string(str(value))
                    eli = 0 # extra line index
                    if &#39;=&#39; not in tally_header[eli+li+1] and &#39;volume&#39; not in tally_header[eli+li+1]: # reg specification continues to next line
                        while &#39;=&#39; not in tally_header[eli+li+1] and &#39;volume&#39; not in tally_header[eli+li+1]:
                            reg_groups += parse_group_string(tally_header[eli+li+1].strip())
                            eli += 1
                    if &#39;all&#39; in reg_groups and &#39;volume&#39; in tally_header[li+1] and &#39;=&#39; not in tally_header[eli+li+1]:
                        # parse table of regions...
                        found_reg_grps = []
                        meta[&#39;reg_groups_inputted&#39;] = reg_groups
                        reg_lines = tally_header[li+3:]
                        for reg_line in reg_lines:
                            if &#39;=&#39; in reg_line: break
                            line_parts = reg_line.split(&#39;#&#39;)
                            if len(line_parts) &gt;= 2:
                                found_reg_grps.append(line_parts[1].strip())
                            else:
                                found_reg_grps.append(line_parts[0].split()[1])
                        meta[&#39;reg_groups&#39;] = found_reg_grps
                        meta[&#39;num_reg_groups&#39;] = len(found_reg_grps)
                    else:
                        meta[&#39;reg_groups&#39;] = reg_groups
                        meta[&#39;num_reg_groups&#39;] = len(reg_groups)
            if key == &#39;point&#39;:
                num_regs = value
                meta[&#39;point_detectors&#39;] = {&#39;non&#39;:[], &#39;x&#39;:[], &#39;y&#39;:[], &#39;z&#39;:[], &#39;r0&#39;:[]} # [T-Point] points
                li_start = li + 2
                li_stop = li_start + num_regs
                for lii in range(li_start, li_stop):
                    non, tppx, tppy, tppz, tppr0 = tally_header[lii].split()
                    meta[&#39;point_detectors&#39;][&#39;non&#39;].append(non)
                    meta[&#39;point_detectors&#39;][&#39;x&#39;].append(tppx)
                    meta[&#39;point_detectors&#39;][&#39;y&#39;].append(tppy)
                    meta[&#39;point_detectors&#39;][&#39;z&#39;].append(tppz)
                    meta[&#39;point_detectors&#39;][&#39;r0&#39;].append(tppr0)
            if key == &#39;ring&#39;:
                num_regs = value
                meta[&#39;point_detectors&#39;] = {&#39;non&#39;:[], &#39;axis&#39;:[], &#39;ar&#39;:[], &#39;rr&#39;:[], &#39;r0&#39;:[]} # [T-Point] points
                li_start = li + 2
                li_stop = li_start + num_regs
                for lii in range(li_start, li_stop):
                    non, tppx, tppy, tppz, tppr0 = tally_header[lii].split()
                    meta[&#39;point_detectors&#39;][&#39;non&#39;].append(non)
                    meta[&#39;point_detectors&#39;][&#39;axis&#39;].append(tppx)
                    meta[&#39;point_detectors&#39;][&#39;ar&#39;].append(tppy)
                    meta[&#39;point_detectors&#39;][&#39;rr&#39;].append(tppz)
                    meta[&#39;point_detectors&#39;][&#39;r0&#39;].append(tppr0)
        elif reading_axis_data:
            values = line.replace(&#39;#&#39;,&#39;&#39;).strip().split()
            for val in values:
                data_values.append(float(val))
                remaining_n_values_to_read += -1
            if remaining_n_values_to_read &lt;= 0:
                reading_axis_data = False
                data_values = np.array(data_values)
                meta[current_data_mesh_kind+&#39;-mesh_bin_edges&#39;] = data_values
                meta[current_data_mesh_kind+&#39;-mesh_bin_mids&#39;] = 0.5*(data_values[1:]+data_values[:-1])
                #meta[current_data_mesh_kind+&#39;-mesh_bin_mids_log&#39;] = np.sqrt(data_values[1:]*data_values[:-1])
                # generate log-centered bin mids
                bin_mids_log = []
                for i in range(len(data_values)-1):
                    if data_values[i+1]&lt;=0 or data_values[i]&lt;=0: # if one or both edges &lt;= 0
                        if data_values[i+1]&lt;0 and data_values[i]&lt;0: # both values are negative
                            bin_mids_log.append(-1*np.sqrt(data_values[i]*data_values[i+1]))
                        elif data_values[i+1]==0 or data_values[i]==0: # one value is zero
                            # use linear center instead...
                            bin_mids_log.append(0.5*(data_values[i]+data_values[i+1]))
                        elif data_values[i+1]&lt;0 or data_values[i]&lt;0: # bin straddles zero
                            # use linear center instead...
                            bin_mids_log.append(0.5*(data_values[i]+data_values[i+1]))
                        else:
                            print(&#39;unknown binning encountered, skipping generation of log-scale bin mids for &#39;+current_data_mesh_kind+&#39;-mesh&#39;)
                            break
                    else:
                        bin_mids_log.append(np.sqrt(data_values[i]*data_values[i+1]))
                meta[current_data_mesh_kind+&#39;-mesh_bin_mids_log&#39;] = np.array(bin_mids_log)
            continue
        else:
            continue

    meta[&#39;found_mesh_kinds&#39;] = found_mesh_kinds

    if meta[&#39;tally_type&#39;]==&#39;[T-Cross]&#39;:
        if meta[&#39;mesh&#39;]==&#39;xyz&#39;:
            if &#39;enclos&#39; in meta and meta[&#39;enclos&#39;]==1:
                pass # total items remains nx*ny*nz
            else:
                meta[&#39;nz_original&#39;] = meta[&#39;nz&#39;]
                meta[&#39;nz&#39;] += 1 # zmesh surfaces are scored, making array nx*ny*(nz+1)
        elif meta[&#39;mesh&#39;]==&#39;r-z&#39;:
            if &#39;enclos&#39; in meta and meta[&#39;enclos&#39;]==1:
                pass # total items remains nr*nz
            else:
                # Current solution addresses this by expanding the ierr axis
                meta[&#39;nr_original&#39;] = meta[&#39;nr&#39;]
                meta[&#39;nz_original&#39;] = meta[&#39;nz&#39;]
                meta[&#39;nr&#39;] = meta[&#39;nr&#39;] + 1
                meta[&#39;nz&#39;] = meta[&#39;nz&#39;] + 1
                # OLD SOLUTION IMPLEMENTED IS BELOW
                # max total num of pages = nrsurf*nz + nzsurf*nr = (nr+1)*nz + nr*(nz+1) = 2*nr*nz + nr + nz
                # if one radius is 0, this becomes = nr*nz + nr*(nz+1) = 2*nr*nz + nr
                # Solution used here:
                # use ir to iterate nr, use iy to iterate nrsurf, use iz to iterate nz, use ic to iterate nzsurf
                # since only rsurf*z [iy,iz] and r*zsurf [ir,ic] pairs exist, when one pair is being written
                # the other will be [-1,-1], hence the dimensions for the array are increased by an extra 1 to prevent overlap
                #meta[&#39;nr_original&#39;] = meta[&#39;nr&#39;]
                #meta[&#39;nz_original&#39;] = meta[&#39;nz&#39;]
                #meta[&#39;ny_original&#39;] = meta[&#39;ny&#39;]
                ##meta[&#39;nc_original&#39;] = meta[&#39;nc&#39;]
                #meta[&#39;ny&#39;] = meta[&#39;nr&#39;] + 1 + 1
                #meta[&#39;nc&#39;] = meta[&#39;nz&#39;] + 1 + 1
                #meta[&#39;nr&#39;] = meta[&#39;nr&#39;] + 1
                #meta[&#39;nz&#39;] = meta[&#39;nz&#39;] + 1

    if meta[&#39;tally_type&#39;] == &#39;[T-Point]&#39;:
        if &#39;mesh&#39; not in meta:
            if &#39;point&#39; in meta:
                meta[&#39;mesh&#39;] = &#39;point&#39;
                meta[&#39;nreg&#39;] = meta[&#39;point&#39;]
            elif &#39;ring&#39; in meta:
                meta[&#39;mesh&#39;] = &#39;ring&#39;
                meta[&#39;nreg&#39;] = meta[&#39;ring&#39;]


    axes_1D = [&#39;eng&#39;,&#39;reg&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;,&#39;r&#39;,&#39;t&#39;,&#39;cos&#39;,&#39;the&#39;,&#39;mass&#39;,&#39;charge&#39;,&#39;let&#39;,&#39;tet&#39;,&#39;eng1&#39;,&#39;eng2&#39;,&#39;sed&#39;,&#39;rad&#39;,&#39;deg&#39;,&#39;act&#39;]
    axes_2D = [&#39;xy&#39;,&#39;yz&#39;,&#39;zx&#39;,&#39;rz&#39;,&#39;chart&#39;,&#39;dchain&#39;,&#39;t-eng&#39;,&#39;eng-t&#39;,&#39;t-e1&#39;,&#39;e1-t&#39;,&#39;t-e2&#39;,&#39;e2-t&#39;,&#39;e12&#39;,&#39;e21&#39;,&#39;xz&#39;,&#39;yx&#39;,&#39;zy&#39;,&#39;zr&#39;]

    axes_ital_1D = [3,   0,  0,  1,  2,  0,  4,    5,    5,     8,       8,    6,    0,     3,     8,    3,    5,    5,   8]
    axes_ital_2D = [ [0,1],[1,2],[2,0],[0,2],[None,None],[None,None],[4,3],[3,4],[4,3],[3,4],[4,8],[8,4],[3,8],[8,3],[0,2],[1,0],[2,1],[2,0]]


    if meta[&#39;axis&#39;] in axes_1D:
        meta[&#39;axis_dimensions&#39;] = 1
        meta[&#39;axis_index_of_tally_array&#39;] = axes_ital_1D[axes_1D.index(meta[&#39;axis&#39;])]
    elif meta[&#39;axis&#39;] in axes_2D:
        meta[&#39;axis_dimensions&#39;] = 2
        meta[&#39;axis_index_of_tally_array&#39;] = axes_ital_2D[axes_2D.index(meta[&#39;axis&#39;])]
    else:
        print(&#34;WARNING: axis value of &#34;,meta[&#39;axis&#39;],&#34; is not in list of known/registered values&#34;)
        meta[&#39;axis_dimensions&#39;] = None
        meta[&#39;axis_index_of_tally_array&#39;] = None




    # Now extract portion of metadata only available from tally content

    if meta[&#39;mesh&#39;] == &#39;reg&#39; or meta[&#39;mesh&#39;] == &#39;tet&#39;:
        num, reg, vol = [], [], []
        if meta[&#39;axis&#39;]==&#39;reg&#39; or meta[&#39;axis&#39;]==&#39;tet&#39;:  # get number of regions and region data from first block of tally content
            outblock = tally_content[0]
            in_reg_list = False
            for line in outblock:
                if &#39;#&#39; in line and &#39; num &#39; in line:
                    cols = line[1:].split()
                    #print(cols)
                    in_reg_list = True
                    continue
                if len(line.split()) == 0 or &#39;{&#39; in line:
                    in_reg_list = False
                if in_reg_list:
                    vals = line.split()
                    if meta[&#39;tally_type&#39;] == &#39;[T-Cross]&#39;:
                        num.append(vals[0])
                        reg.append(vals[0])
                        vol.append(vals[1])
                    else:
                        num.append(vals[0])
                        reg.append(vals[1])
                        vol.append(vals[2])
        else: # scan output for region numbers:
            regcount = 0
            for outblock in tally_content:
                for line in outblock:
                    if &#39;reg =&#39; in line or &#39;reg  =&#39; in line:
                        eq_strs = split_str_of_equalities(line[1:])
                        reg_eq_str = &#39;&#39;
                        for eqsi in eq_strs:
                            if &#39;reg&#39; in eqsi:
                                reg_eq_str = eqsi
                                break
                        regnum = reg_eq_str.split(&#39;=&#39;)[1].strip()
                        #regnum = line.strip().split(&#39;reg =&#39;)[1].strip().replace(&#34;&#39;&#34;,&#39;&#39;)
                        if regnum not in reg:
                            regcount += 1
                            num.append(regcount)
                            reg.append(regnum)
                            vol.append(None)
                        continue
        if meta[&#39;mesh&#39;] == &#39;reg&#39;:
            meta.reg_serial_num = num
            meta.reg_num = reg
            if meta[&#39;tally_type&#39;] == &#39;[T-Cross]&#39;:
                meta.reg_area = vol
            else:
                meta.reg_volume = vol
            meta.nreg = len(reg)
        elif meta[&#39;mesh&#39;] == &#39;tet&#39;:
            meta.tet_serial_num = num
            meta.tet_num = reg
            meta.reg_num = reg
            #meta.tet_volume = vol
            if meta[&#39;tally_type&#39;] == &#39;[T-Cross]&#39;:
                meta.tet_area = vol
            else:
                meta.tet_volume = vol
            meta.ntet = len(reg)

        #if meta[&#39;tally_type&#39;] == &#39;[T-Cross]&#39;:
        #    meta[&#39;reg_groups&#39;] = reg



    elif meta[&#39;mesh&#39;] == &#39;tet&#39;:
        num, reg, vol = [], [], []
        if meta[&#39;axis&#39;] == &#39;tet&#39;:
            pass
        else:
            pass
        print(&#39;mesh=tet has not been tested!&#39;)
        meta.ntet = 0

    axis1_label = &#39;&#39;
    axis2_label = &#39;&#39;
    value_label = &#39;&#39;
    hc_passed = False # passed colorbar definition line
    outblock = tally_content[0]
    for line in outblock:
        if len(line) == 0: continue
        if line[:2] == &#39;x:&#39;:
            axis1_label = line[2:].strip()
        if line[:2] == &#39;y:&#39;:
            if meta.axis_dimensions == 1:
                value_label = line[2:].strip()
                #break
            elif meta.axis_dimensions == 2:
                if hc_passed: # second instance of y:
                    value_label = line[2:].strip()
                    #break
                else: # first instance of y:
                    axis2_label = line[2:].strip()
                    hc_passed = True
        #if line[:3] == &#39;hc:&#39;:
        #    hc_passed = True
        h_line_str = &#39;&#39;
        if line[0] == &#39;h&#39; and (line[1] == &#39;:&#39; or line[2] == &#39;:&#39;):
            if meta[&#39;axis_dimensions&#39;] == 1:
                ndatacol = line.count(&#39; y&#39;)
                if ndatacol != 1:  # multiple columns are present &#34;samepage&#34;
                    # get first string with y
                    col_groups = parse_group_string(line)
                    i_first_y = next((i for i,v in enumerate(col_groups) if v[0]==&#39;y&#39;), None) # index of first column with &#34;y&#34;
                    first_data_col_header = col_groups[i_first_y][2:]
                    for m in mesh_types:
                        if first_data_col_header[0] == m:
                            if m == &#39;e&#39;:
                                meta[&#39;samepage&#39;] = &#39;eng&#39;
                            elif m == &#39;r&#39;:
                                if first_data_col_header[:3] == &#39;reg&#39;:
                                    meta[&#39;samepage&#39;] = &#39;reg&#39;
                                else:
                                    meta[&#39;samepage&#39;] = m
                            elif m == &#39;l&#39;:
                                meta[&#39;samepage&#39;] = &#39;let&#39;
                            elif m == &#39;a&#39;:
                                if first_data_col_header[:3] not in [&#39;all&#39;,&#39;alp&#39;]:
                                    meta[&#39;samepage&#39;] = &#39;the&#39; # or cos
                            else:
                                meta[&#39;samepage&#39;] = m
                    if meta[&#39;samepage&#39;] == &#39;part&#39;:  # still is default value
                        # double check to see if it could be region numbers vs particle names
                        if ndatacol != meta[&#39;npart&#39;]:
                            if &#39;num_reg_groups&#39; in meta and ndatacol == meta[&#39;num_reg_groups&#39;]:
                                meta[&#39;samepage&#39;] = &#39;reg&#39;
                            else:
                                print(&#39;&#34;samepage&#34; was not correctly identified; needs to be implemented&#39;)
                    if meta[&#39;samepage&#39;] == &#39;reg&#39;:
                        hcols = parse_group_string(line[3:])
                        num, reg, vol = [], [], []
                        reg_ser_num = 1
                        for hcol in hcols:
                            if hcol[0] == &#39;y&#39;:
                                num.append(reg_ser_num)
                                reg_ser_num += 1
                                reg.append(hcol.split(&#39;)&#39;)[0].replace(&#39;y(reg&#39;,&#39;&#39;))
                                vol.append(None)
                        meta.reg_serial_num = num
                        meta.reg_num = reg
                        meta.reg_volume = vol
                        meta.nreg = len(reg)

            break
    meta.axis1_label = axis1_label
    meta.axis2_label = axis2_label
    meta.value_label = value_label

    # Now do any final overrides for specific tallies / circumstances

    if meta[&#39;tally_type&#39;] == &#39;[T-Deposit2]&#39;:
        meta[&#39;nreg&#39;] = 1
        meta[&#39;reg_serial_num&#39;] = [1]
        meta[&#39;reg_num&#39;] = [&#39;1&#39;]
        meta[&#39;reg_volume&#39;] = [None]
        if meta[&#39;num_reg_groups&#39;] &gt; 1:
            meta[&#39;num_reg_groups&#39;] = 1
            meta[&#39;reg_groups&#39;] = [meta[&#39;reg_groups&#39;][0] + &#39; &#39; + meta[&#39;reg_groups&#39;][1]]

    if meta[&#39;tally_type&#39;] == &#39;[T-Heat]&#39;:
        if &#39;npart&#39; not in meta or meta[&#39;npart&#39;] == None: meta[&#39;npart&#39;] = 1
        if &#39;part_groups&#39; not in meta: meta[&#39;part_groups&#39;] = [&#39;all&#39;]

    return meta</code></pre>
</details>
</dd>
<dt id="PHITS_tools.initialize_tally_array"><code class="name flex">
<span>def <span class="ident">initialize_tally_array</span></span>(<span>tally_metadata, include_abs_err=True)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Initializes main tally data array in which tally results will be stored when read</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code>import numpy as np</code></li>
</ul>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>tally_metadata</code> = Munch object / dictionary containing tally metadata</li>
<li><code>include_abs_err</code> = a Boolean (D=<code>True</code>) on whether absolute error will be calculated; the final dimension of <code>tdata</code> is
<code>3/2</code> if this value is <code>True/False</code></li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>tdata</code> = 10-dimensional NumPy array of zeros of correct size for holding tally results</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_tally_array(tally_metadata,include_abs_err=True):
    &#39;&#39;&#39;
    Description:
        Initializes main tally data array in which tally results will be stored when read

    Dependencies:
        - `import numpy as np`

    Inputs:
        - `tally_metadata` = Munch object / dictionary containing tally metadata
        - `include_abs_err` = a Boolean (D=`True`) on whether absolute error will be calculated; the final dimension of `tdata` is
                `3/2` if this value is `True/False`

    Outputs:
        - `tdata` = 10-dimensional NumPy array of zeros of correct size for holding tally results

    &#39;&#39;&#39;
    ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max = 1, 1, 1, 1, 1, 1, 1, 1, 1
    if include_abs_err:
        ierr_max = 3
    else:
        ierr_max = 2
    if tally_metadata[&#39;mesh&#39;] == &#39;reg&#39;:
        ir_max = tally_metadata.nreg
    elif tally_metadata[&#39;mesh&#39;] == &#39;xyz&#39;:
        ir_max = tally_metadata.nx
        iy_max = tally_metadata.ny
        iz_max = tally_metadata.nz
    elif tally_metadata[&#39;mesh&#39;] == &#39;r-z&#39;:
        ir_max = tally_metadata.nr
        iz_max = tally_metadata.nz
        if &#39;ny&#39; in tally_metadata and tally_metadata.ny != None: iy_max = tally_metadata.ny
        if &#39;nc&#39; in tally_metadata and tally_metadata.nc != None: ic_max = tally_metadata.nc
    elif tally_metadata[&#39;mesh&#39;] == &#39;tet&#39;:
        ir_max = tally_metadata.ntet
    elif tally_metadata[&#39;mesh&#39;] == &#39;point&#39; or tally_metadata[&#39;mesh&#39;] == &#39;ring&#39;:
        ir_max = tally_metadata.nreg
    else:
        raise ValueError(&#39;ERROR! Unknown geometry mesh:&#39;+ str(tally_metadata[&#39;mesh&#39;]))

    if tally_metadata.na != None: ia_max = tally_metadata.na
    if tally_metadata.nt != None: it_max = tally_metadata.nt
    if tally_metadata.nl != None: il_max = tally_metadata.nl
    if &#39;nc&#39; in tally_metadata and tally_metadata.nc != None: ic_max = tally_metadata.nc
    #if &#39;npart&#39; in tally_metadata and tally_metadata.npart != None: ip_max = tally_metadata.np

    if tally_metadata.ne == None:
        if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Deposit2]&#39;:
            if &#39;ne1&#39; in tally_metadata:
                ie_max = tally_metadata.ne1
            if &#39;ne2&#39; in tally_metadata:
                ic_max = tally_metadata.ne2
        elif &#39;e1&#39; in tally_metadata.axis or &#39;e2&#39; in tally_metadata.axis:  # This should now be redundant?
            if tally_metadata.axis == &#39;e12&#39;:
                ie_max = tally_metadata.ne1
                ic_max = tally_metadata.ne2
            elif tally_metadata.axis == &#39;e21&#39;:
                ie_max = tally_metadata.ne1
                ic_max = tally_metadata.ne2
            elif &#39;e1&#39; in tally_metadata.axis or &#39;eng1&#39; in tally_metadata.axis:
                ie_max = tally_metadata.ne1
                if &#39;ne2&#39; in tally_metadata:
                    ic_max = tally_metadata.ne2
            elif &#39;e2&#39; in tally_metadata.axis or &#39;eng2&#39; in tally_metadata.axis:
                ic_max = tally_metadata.ne2
                if &#39;ne1&#39; in tally_metadata:
                    ie_max = tally_metadata.ne1
            else:
                if &#39;ne1&#39; in tally_metadata:
                    ie_max = tally_metadata.ne1
                if &#39;ne2&#39; in tally_metadata:
                    ic_max = tally_metadata.ne2

    else:
        ie_max = tally_metadata.ne

    ip_max = tally_metadata.npart

    if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Cross]&#39; and tally_metadata.mesh == &#39;r-z&#39;:
        if &#39;enclos&#39; in tally_metadata and tally_metadata[&#39;enclos&#39;] == 1:
            pass
        else: # enclos = 0 case
            ierr_max = 2*ierr_max

    if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Yield]&#39;:
        if tally_metadata.axis == &#39;charge&#39;:
            ic_max = 130
        elif tally_metadata.axis == &#39;mass&#39;:
            ic_max = 320
        elif tally_metadata.axis == &#39;chart&#39;:
            if int(tally_metadata.mxnuclei) == 0:
                ic_max = 10000
            else:
                ic_max = int(tally_metadata.mxnuclei)

    if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Interact]&#39; and tally_metadata[&#39;axis&#39;] == &#39;act&#39;:
        ic_max = 100
        if &#39;maxact&#39; in tally_metadata:
            ic_max = tally_metadata.maxact

    if in_debug_mode:
        dims_str = &#39;tally dims: nr={:g}, ny={:g}, nz={:g}, ne={:g}, nt={:g}, na={:g}, nl={:g}, np={:g}, nc={:g}, nerr={:g}&#39;
        print(dims_str.format(ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max, ierr_max))
    tally_data = np.zeros((ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max, ierr_max))
    return tally_data</code></pre>
</details>
</dd>
<dt id="PHITS_tools.calculate_tally_absolute_errors"><code class="name flex">
<span>def <span class="ident">calculate_tally_absolute_errors</span></span>(<span>tdata)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Calculates the absolute uncertainty for every value in the PHITS tally data array</p>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>tdata</code> = 10-dimensional NumPy array containing read/extracted tally results</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>tdata</code> = updated <code>tdata</code> array now with absolute uncertainties in <code>ierr = 2</code> index</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_tally_absolute_errors(tdata):
    &#39;&#39;&#39;
    Description:
        Calculates the absolute uncertainty for every value in the PHITS tally data array

    Inputs:
        - `tdata` = 10-dimensional NumPy array containing read/extracted tally results

    Outputs:
        - `tdata` = updated `tdata` array now with absolute uncertainties in `ierr = 2` index

    &#39;&#39;&#39;

    ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max, ierr_max = np.shape(tdata)
    for ir in range(ir_max):
        for iy in range(iy_max):
            for iz in range(iz_max):
                for ie in range(ie_max):
                    for it in range(it_max):
                        for ia in range(ia_max):
                            for il in range(il_max):
                                for ip in range(ip_max):
                                    for ic in range(ic_max):
                                        tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 2] = \
                                            tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 0] * \
                                            tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 1]
    if ierr_max==6:
        for ir in range(ir_max):
            for iy in range(iy_max):
                for iz in range(iz_max):
                    for ie in range(ie_max):
                        for it in range(it_max):
                            for ia in range(ia_max):
                                for il in range(il_max):
                                    for ip in range(ip_max):
                                        for ic in range(ic_max):
                                            tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 5] = \
                                                tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 3] * \
                                                tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 4]

    return tdata</code></pre>
</details>
</dd>
<dt id="PHITS_tools.split_str_of_equalities"><code class="name flex">
<span>def <span class="ident">split_str_of_equalities</span></span>(<span>text)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Extract relevant regions, indices, etc. from somewhat inconsistently formatted lines in PHITS tally output content section.</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code><a title="PHITS_tools.is_number" href="#PHITS_tools.is_number">is_number()</a></code> (function within the "PHITS tools" package)</li>
</ul>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>text</code> = string to be processed</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>equalities_str_list</code> = list of strings of equalities each of the format "key = value"</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_str_of_equalities(text):
    &#39;&#39;&#39;
    Description:
        Extract relevant regions, indices, etc. from somewhat inconsistently formatted lines in PHITS tally output content section.

    Dependencies:
        - `is_number` (function within the &#34;PHITS tools&#34; package)

    Inputs:
        - `text` = string to be processed

    Outputs:
        - `equalities_str_list` = list of strings of equalities each of the format &#34;key = value&#34;

    &#39;&#39;&#39;
    equalities_str_list = []
    original_text = text
    #if text[0] == &#34;&#39;&#34;: # more loosely formatted text
    #    problem_strs = [&#39;tot DPA&#39;]
    text = text.replace(&#34;&#39;&#34;,&#39;&#39;).replace(&#39;,&#39;,&#39; &#39;).replace(&#39;#&#39;,&#39;&#39;).replace(&#39;=&#39;,&#39; = &#39;)
    text_pieces = text.split()
    #i_equal_sign = [i for i, x in enumerate(text_pieces) if x == &#34;=&#34;]
    is_i_equal_sign = [x==&#39;=&#39; for x in text_pieces]
    #i_is_number = [i for i, x in enumerate(text_pieces) if is_number(x)]
    is_i_number = [is_number(x) for x in text_pieces]
    #num_equalities = len(i_equal_sign)
    #remaining_equalities = num_equalities
    equality_str = &#39;&#39;
    # the only condition enforced is that the last item in each value be numeric or )
    current_equality_contains_equalsign = False
    for i in reversed(range(len(text_pieces))): # easiest to build from right to left
        equality_str = text_pieces[i] + &#39; &#39; + equality_str
        if is_i_equal_sign[i]:
            current_equality_contains_equalsign = True
        elif current_equality_contains_equalsign: # looking to terminate if next item is numeric
            if i==0 or (is_i_number[i-1] or text_pieces[i-1][-1]==&#39;)&#39;): # either final equality completed or next item belongs to next equality
                equalities_str_list.insert(0,equality_str.strip())
                equality_str = &#39;&#39;
                current_equality_contains_equalsign = False
    if &#39;(&#39; in text: # need to break up potential (ia,ib) pairs
        new_eq_str_list = []
        for x in equalities_str_list:
            if &#39;(&#39; in x:
                keys, values = x.split(&#39;=&#39;)
                keys = keys.strip().replace(&#39;(&#39;,&#39;&#39;).replace(&#39;)&#39;,&#39;&#39;).split()
                values = values.strip().replace(&#39;(&#39;,&#39;&#39;).replace(&#39;)&#39;,&#39;&#39;).split()
                for i in range(len(keys)):
                    new_eq_str = keys[i].strip() + &#39; = &#39; + values[i].strip()
                    new_eq_str_list.append(new_eq_str)
            else:
                new_eq_str_list.append(x)
        equalities_str_list = new_eq_str_list
    #print(equalities_str_list)
    return equalities_str_list</code></pre>
</details>
</dd>
<dt id="PHITS_tools.parse_tally_content"><code class="name flex">
<span>def <span class="ident">parse_tally_content</span></span>(<span>tdata, meta, tally_blocks, is_err_in_separate_file, err_mode=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Parses the PHITS tally output content section and extract its results</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code><a title="PHITS_tools.split_str_of_equalities" href="#PHITS_tools.split_str_of_equalities">split_str_of_equalities()</a></code> (function within the "PHITS tools" package)</li>
<li><code><a title="PHITS_tools.parse_group_string" href="#PHITS_tools.parse_group_string">parse_group_string()</a></code> (function within the "PHITS tools" package)</li>
<li><code><a title="PHITS_tools.data_row_to_num_list" href="#PHITS_tools.data_row_to_num_list">data_row_to_num_list()</a></code> (function within the "PHITS tools" package)</li>
</ul>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>tdata</code> = 10-dimensional NumPy array of zeros of correct size to hold tally output/results</li>
<li><code>meta</code> = Munch object / dictionary containing tally metadata</li>
<li><code>tally_blocks</code> = blocks of tally output as outputted by the <code><a title="PHITS_tools.split_into_header_and_content" href="#PHITS_tools.split_into_header_and_content">split_into_header_and_content()</a></code> function</li>
<li><code>is_err_in_separate_file</code> = Boolean denoting whether the tally's relative errors are located in a separate file</li>
<li><code>err_mode</code> = Boolean (D=<code>False</code>) used for manually forcing all read values to be regarded as relative uncertainties
as is necessary when processing dedicated *_err files.</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>tdata</code> = updated <code>tdata</code> array containing read/extracted tally results</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_tally_content(tdata,meta,tally_blocks,is_err_in_separate_file,err_mode=False):
    &#39;&#39;&#39;
    Description:
        Parses the PHITS tally output content section and extract its results

    Dependencies:
        - `split_str_of_equalities` (function within the &#34;PHITS tools&#34; package)
        - `parse_group_string` (function within the &#34;PHITS tools&#34; package)
        - `data_row_to_num_list` (function within the &#34;PHITS tools&#34; package)

    Inputs:
        - `tdata` = 10-dimensional NumPy array of zeros of correct size to hold tally output/results
        - `meta` = Munch object / dictionary containing tally metadata
        - `tally_blocks` = blocks of tally output as outputted by the `split_into_header_and_content` function
        - `is_err_in_separate_file` = Boolean denoting whether the tally&#39;s relative errors are located in a separate file
        - `err_mode` = Boolean (D=`False`) used for manually forcing all read values to be regarded as relative uncertainties
                as is necessary when processing dedicated *_err files.

    Outputs:
        - `tdata` = updated `tdata` array containing read/extracted tally results

    &#39;&#39;&#39;
    global ir, iy, iz, ie, it, ia, il, ip, ic, ierr
    global ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max, ierr_max
    ierr = 0
    if is_err_in_separate_file and err_mode:
        ierr = 1

    mesh_kind_chars = [&#39;e&#39;, &#39;t&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;r&#39;, &#39;a&#39;, &#39;l&#39;]
    mesh_kind_iax = [3, 4, 0, 1, 2, 0, 5, 6]
    tdata_ivar_strs = [&#39;ir&#39;, &#39;iy&#39;, &#39;iz&#39;, &#39;ie&#39;, &#39;it&#39;, &#39;ia&#39;, &#39;il&#39;, &#39;ip&#39;, &#39;ic&#39;]
    ir, iy, iz, ie, it, ia, il, ip, ic = 0, 0, 0, 0, 0, 0, 0, 0, 0

    ignored_eq_strs = [&#39;axis&#39;,&#39;axs&#39;,&#39;ar&#39;,&#39;rr&#39;,&#39;m jm&#39;,&#39;Z&#39;,&#39;cmax nmax&#39;]
    replace_eq_strs_dict = {&#39;ang&#39;:&#39;a&#39;}

    ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max, ierr_max = np.shape(tdata)

    axes_1D = [&#39;eng&#39;, &#39;reg&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;r&#39;, &#39;t&#39;, &#39;cos&#39;, &#39;the&#39;, &#39;mass&#39;, &#39;charge&#39;, &#39;let&#39;, &#39;tet&#39;, &#39;eng1&#39;, &#39;eng2&#39;,
               &#39;sed&#39;, &#39;rad&#39;, &#39;deg&#39;, &#39;act&#39;]
    axes_2D = [&#39;xy&#39;, &#39;yz&#39;, &#39;zx&#39;, &#39;rz&#39;, &#39;chart&#39;, &#39;dchain&#39;,
               &#39;t-eng&#39;, &#39;eng-t&#39;, &#39;t-e1&#39;, &#39;e1-t&#39;, &#39;t-e2&#39;, &#39;e2-t&#39;,
               &#39;e12&#39;, &#39;e21&#39;, &#39;xz&#39;, &#39;yx&#39;, &#39;zy&#39;, &#39;zr&#39;]

    axes_ital_1D = [3, 0, 0, 1, 2, 0, 4, 5, 5, 8, 8, 6, 0, 3, 8,
                    3, 5, 5, 8]
    axes_ital_2D = [[0, 1], [1, 2], [2, 0], [0, 2], [None, None], [None, None],
                    [4, 3], [3, 4], [4, 3], [3, 4], [4, 8], [8, 4],
                    [3, 8], [8, 3], [0, 2], [1, 0], [2, 1], [2, 0]]

    ierr_mod = 0 # add to ierr for weird [T-Cross], mesh=r-z, enclos=0 case

    banked_uninterpreted_lines = [] # store lines with equalities that may be useful but are skipped owing to being a bit exceptional
    i_metastable = 0
    ZZZAAAM_list = []

    if meta.axis_dimensions==1:
        for bi, block in enumerate(tally_blocks):
            hli, fli = 0,0
            ierr_mod = 0
            hli_found = False
            for li, line in enumerate(block):
                if len(line) == 0: continue
                if line[:2].lower() == &#39;h:&#39;:  # start of data is here
                    hli = li
                    hli_found = True
                    continue
                if hli_found and (line[:12] == &#39;#   sum over&#39; or line[:7] == &#39;#   sum&#39; or line[:5] == &#39;#----&#39; or (len(block[li-1]) == 0 and hli != 0 and li&gt;hli+2) or &#34;&#39;&#34; in line or &#39;{&#39; in line):
                    fli = li
                    if (len(block[li-1]) == 0 and hli != 0 and li&gt;hli+2): fli = li - 1 # triggered by blank line after data
                    #if &#34;&#39;&#34; in line or &#39;{&#39; in line:
                    #    fli = li-1
                    break

            data_header = block[:hli]
            data_table = block[hli:fli]
            data_footer = block[fli:]

            if bi == len(tally_blocks) - 1:
                ffli = len(data_footer)
                for li, line in enumerate(data_footer):
                    if line[:37] == &#39;# Information for Restart Calculation&#39;:
                        ffli = li
                        break
                data_footer = data_footer[:ffli]

            # print(data_header)
            #print(data_table)
            # print(data_footer)

            hash_line_already_evaluated = False

            # try to get relevant indices data from header and footer blocks
            for li, line in enumerate(data_header+data_footer):
                if len(line) == 0: continue

                if &#39;=&#39; in line and (line[0] == &#34;&#39;&#34; or (line[0] == &#34;#&#34; and (&#39;no.&#39; in line or &#39;i&#39; in line or &#39;reg&#39; in line or &#39;part&#39; in line))):
                    if line[0] == &#34;#&#34;:
                        hash_line_already_evaluated = True
                    elif line[0] == &#34;&#39;&#34; and hash_line_already_evaluated:
                        if meta[&#39;samepage&#39;] == &#39;part&#39;:
                            continue  # &#39;-starting lines tend to have more problematic formatting, best skipped if possible
                        elif meta[&#39;npart&#39;] == 1:
                            continue  # can still skip if only one particle group tallied
                        else:
                            pass  # but this needs to be parsed if not using samepage = part and npart &gt; 1
                    parts = split_str_of_equalities(line)
                    #print(line)
                    for part in parts:
                        mesh_char = part.split(&#39;=&#39;)[0].strip().replace(&#39;i&#39;,&#39;&#39;)
                        #print(mesh_char)
                        if mesh_char == &#39;no.&#39;:
                            if &#39;***&#39; in part:
                                break # this is a bugged line
                            continue
                        elif mesh_char == &#39;part.&#39; or mesh_char == &#39;partcle&#39; or mesh_char == &#39;part&#39;:
                            part_grp_name = part.split(&#39;=&#39;)[1].strip()
                            if part_grp_name in meta.part_groups:
                                ip = (meta.part_groups).index(part_grp_name)
                            elif part_grp_name in meta.part_serial_groups:
                                ip = (meta.part_serial_groups).index(part_grp_name)
                            else:
                                raise ValueError(&#39;ERROR! Particle &#34;&#39;+part_grp_name+&#39;&#34; could not be identified.&#39;)
                        elif mesh_char == &#39;reg&#39;:
                            regnum = part.split(&#39;=&#39;)[1].strip()
                            ir = (meta.reg_num).index(regnum)
                        elif mesh_char == &#39;pont&#39; or mesh_char == &#39;rng&#39;: # [T-Point]
                            value_str = part.split(&#39;=&#39;)[1].strip()
                            ir = int(value_str) - 1
                        elif mesh_char == &#39;e1&#39;: # [T-Deposit2]
                            value_str = part.split(&#39;=&#39;)[1].strip()
                            ie = int(value_str) - 1
                        elif mesh_char == &#39;e2&#39;: # [T-Deposit2]
                            value_str = part.split(&#39;=&#39;)[1].strip()
                            ic = int(value_str) - 1
                        elif mesh_char in mesh_kind_chars or mesh_char in replace_eq_strs_dict:
                            if mesh_char in replace_eq_strs_dict:
                                mesh_char = replace_eq_strs_dict[mesh_char]
                            if &#39;i&#39;+mesh_char not in part: continue # only looking for indices for meshes, not values
                            imesh = mesh_kind_chars.index(mesh_char)
                            itdata_axis = mesh_kind_iax[imesh]
                            tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                            value_str = part.split(&#39;=&#39;)[1].strip()
                            if &#39; - &#39; in value_str:
                                vals = value_str.split(&#39;-&#39;)
                                if int(vals[0]) == int(vals[1]):
                                    value_str = vals[0]
                                else:  # samepage axis
                                    value_str = vals[0]  # this will be overwritten later
                            value = str(int(value_str)-1)
                            exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                        elif mesh_char in ignored_eq_strs:
                            continue
                        elif meta[&#39;tally_type&#39;]==&#39;[T-Cross]&#39;:
                            if meta[&#39;mesh&#39;] == &#39;xyz&#39; and mesh_char==&#39;z surf&#39;:
                                #imesh = mesh_kind_chars.index(&#39;z&#39;)
                                itdata_axis = 2 #mesh_kind_iax[imesh]
                                tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                                value_str = part.split(&#39;=&#39;)[1].strip()
                                value = str(int(value_str) - 1)
                                exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                            elif meta[&#39;mesh&#39;] == &#39;r-z&#39;:
                                if mesh_char==&#39;r surf&#39;:
                                    itdata_axis = 0  # mesh_kind_iax[imesh]
                                    #itdata_axis = 1  # set to iy
                                    ierr_mod = int(ierr_max/2)
                                    #ir, ic = -1, -1
                                    # imesh = mesh_kind_chars.index(&#39;y&#39;)
                                elif mesh_char == &#39;z surf&#39;:
                                    itdata_axis = 2  # mesh_kind_iax[imesh]
                                    #itdata_axis = 8  # set to ic
                                    ierr_mod = 0
                                    #iy, iz = -1, -1
                                    # imesh = mesh_kind_chars.index(&#39;c&#39;)
                                else:
                                    raise ValueError(&#39;ERROR! Unregistered potential index [&#39;+ part.split(&#39;=&#39;)[0].strip()+&#39;] found&#39;)
                                tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                                value_str = part.split(&#39;=&#39;)[1].strip()
                                if &#39; - &#39; in value_str:
                                    vals = value_str.split(&#39;-&#39;)
                                    if int(vals[0]) == int(vals[1]):
                                        value_str = vals[0]
                                    else: # samepage axis
                                        value_str = vals[0] # this will be overwritten later
                                value = str(int(value_str) - 1)
                                exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                            else:
                                raise ValueError(&#39;ERROR! Unregistered potential index [&#39;+ part.split(&#39;=&#39;)[0].strip()+ &#39;] found&#39;)
                        elif meta[&#39;tally_type&#39;] == &#39;[T-Heat]&#39;:
                            banked_uninterpreted_lines.append(line)
                        else:
                            raise ValueError(&#39;ERROR! Unregistered potential index [&#39;+part.split(&#39;=&#39;)[0].strip()+&#39;] found&#39;)


            # extract data from table
            # determine meaning of table rows
            row_ivar = tdata_ivar_strs[meta.axis_index_of_tally_array]
            # determine meaning of table columns
            hcols = parse_group_string(data_table[0][3:])
            nhcols = len(hcols)
            col_names_line_str = data_table[1][1:]
            icol_mod = 0 # account for weirdness in column presence/absence
            if &#39;r surface position&#39; in col_names_line_str:
                icol_mod = -1
                ierr_mod = int(ierr_max / 2)
            # Test for error in hcols
            num_data_vals_in_first_row = len(data_row_to_num_list(data_table[2])) # first row of data
            if num_data_vals_in_first_row != nhcols:
                if num_data_vals_in_first_row == (nhcols+1):
                    # most likely issue is hcol string is missing the &#34;n&#34; for the ?-lower column
                    nhcols = nhcols + 1
                    icol_mod = 1
            is_col_data = np.full(nhcols,False)
            data_col_indices = []
            is_col_err = np.full(nhcols,False)
            err_col_indices = []
            for iii in range(len(hcols)):
                if hcols[iii][0] == &#39;y&#39;:
                    is_col_data[iii+icol_mod] = True
                    is_col_err[iii+1+icol_mod] = True
                    data_col_indices.append(iii+icol_mod)
                    err_col_indices.append(iii+1+icol_mod)
            #print(is_col_data)
            #print(is_col_err)
            cols = data_table[1][1:].strip().split()
            ncols = len(cols)
            ndata_cols = np.sum(is_col_data) # number of data values per row
            # determine what variable this corresponds to, should be val of samepage
            # by default, this is usually particles (samepage = part by default)
            if meta.samepage == &#39;part&#39;:
                if meta.npart != ndata_cols:
                    raise ValueError(&#39;ERROR! samepage number of particle types (&#39;+str(meta.npart)+&#39;) not equal to number of data columns y(part) = &#39;+str(ndata_cols))
                data_ivar = &#39;ip&#39;
                data_ivar_indices = [j for j in range(ndata_cols)]
            else: # figure out what axis samepage is on
                if meta.samepage not in axes_1D:
                    raise ValueError(&#39;ERROR! samepage parameter (&#39;+str(meta.samepage)+&#39;) must be &#34;part&#34; or one of valid options for &#34;axis&#34; parameter&#39;)
                data_ivar = tdata_ivar_strs[axes_ital_1D[axes_1D.index(meta.samepage)]]
                if ndata_cols != eval(data_ivar+&#39;_max&#39;):
                    if meta[&#39;tally_type&#39;]==&#39;[T-Cross]&#39; and ndata_cols+1 == eval(data_ivar+&#39;_max&#39;):
                        # This is fine; for T-Cross, ndata cols can be one less than max length...
                        pass
                    elif meta[&#39;tally_type&#39;]==&#39;[T-Cross]&#39; and data_ivar == &#39;ir&#39; and ndata_cols+2 == eval(data_ivar+&#39;_max&#39;):
                        # This is fine; for T-Cross, ndata cols for radius can be two less than max length if rmin=0...
                        pass
                    else:
                        raise ValueError(&#39;ERROR! number of data columns (&#39;+str(ndata_cols)+&#39;) not equal to tally array dimension for &#39;+str(data_ivar)+&#39;, &#39;+str(eval(data_ivar+&#39;_max&#39;)))
                data_ivar_indices = [j for j in range(ndata_cols)]
            #print(cols)
            #print(ndata_cols)
            for li, line in enumerate(data_table[2:]):
                if len(line)==0: continue
                #print(line)
                rowi = li
                exec(row_ivar + &#39;=&#39; + str(rowi),globals())
                #print(row_ivar + &#39;=&#39; + str(rowi))
                values = data_row_to_num_list(line)
                dcoli = 0
                ecoli = 0
                for vi, value in enumerate(values):
                    if is_col_data[vi]:
                        exec(data_ivar + &#39;=&#39; + str(dcoli),globals())
                        #print(data_ivar + &#39;=&#39; + str(dcoli))
                        tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 0+ierr_mod] = value
                        dcoli += 1
                    if is_col_err[vi]:
                        exec(data_ivar + &#39;=&#39; + str(ecoli),globals())
                        #print(data_ivar + &#39;=&#39; + str(ecoli))
                        tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 1+ierr_mod] = value
                        ecoli += 1





    elif meta.axis_dimensions==2:
        for bi, block in enumerate(tally_blocks):
            hli, bli = 0 , 0
            data_keyword_found = False
            for li, line in enumerate(block):
                if meta[&#39;2D-type&#39;] in [1, 2, 3, 6, 7]:
                    if len(line) == 0: continue
                    if line[:3].lower() in [&#39;hc:&#39;, &#39;h2:&#39;, &#39;hd:&#39;, &#39;hc2&#39;]:  # start of data is here
                        hli = li
                    if line[:12] == &#39;#-----------&#39;:
                        fli = li
                        #if bi != len(tally_blocks) - 1:
                        break
                elif meta[&#39;2D-type&#39;] == 4:
                    if line == &#39;&#39; and hli != 0:
                        fli = li
                        #if bi != len(tally_blocks) - 1:
                        break
                    elif line == &#39;&#39;:  # start of data is here
                        hli = li
                elif meta[&#39;2D-type&#39;] == 5:
                    if &#39;data&#39; in line:
                        hli = li + 3
                    if line == &#39;&#39; and hli != 0 and li&gt;hli+2:
                        fli = li
                        #if bi != len(tally_blocks) - 1:
                        break

            data_header = block[:hli]
            data_table = block[hli:fli]
            data_footer = block[fli:]

            #print(data_header)
            #print(data_table)
            #print(data_footer)

            hash_line_already_evaluated = False

            if bi == len(tally_blocks) - 1:
                for li, line in enumerate(data_footer):
                    if line[:37] == &#39;# Information for Restart Calculation&#39;:
                        ffli = li
                        break
                data_footer = data_footer[:ffli]

            # try to get relevant indices data from header block
            for li, line in enumerate(data_header+data_footer): # +data_footer
                if len(line) == 0: continue
                #if &#39;reg =&#39; in line:
                #    regnum = line.strip().split(&#39;reg =&#39;)[1].strip()
                #    ir = (meta.reg_num).index(regnum)
                #    # print(ir)
                if &#39;=&#39; in line and (line[0] == &#34;&#39;&#34; or (line[0] == &#34;#&#34; and (&#39;no.&#39; in line or &#39;i&#39; in line or &#39;reg&#39; in line or &#39;part&#39; in line))):
                    if line[0] == &#34;#&#34;:
                        hash_line_already_evaluated = True
                    elif line[0] == &#34;&#39;&#34; and hash_line_already_evaluated:
                        if meta[&#39;samepage&#39;] == &#39;part&#39;:
                            continue # &#39;-starting lines tend to have more problematic formatting, best skipped if possible
                        elif meta[&#39;npart&#39;] == 1:
                            continue # can still skip if only one particle group tallied
                        else:
                            pass # but this needs to be parsed if not using samepage = part and npart &gt; 1
                    parts = split_str_of_equalities(line)
                    for part in parts:
                        mesh_char = part.split(&#39;=&#39;)[0].strip().replace(&#39;i&#39;, &#39;&#39;)
                        #print(mesh_char)
                        if mesh_char == &#39;no.&#39;:
                            continue
                        elif mesh_char == &#39;part.&#39; or mesh_char == &#39;partcle&#39;:
                            part_grp_name = part.split(&#39;=&#39;)[1].strip()
                            try:
                                ip = (meta.part_groups).index(part_grp_name)
                            except:
                                ip = (meta.part_serial_groups).index(part_grp_name)
                        elif mesh_char == &#39;reg&#39;: # and meta[&#39;samepage&#39;] != &#39;reg&#39;:
                            regnum = part.split(&#39;=&#39;)[1].strip()
                            ir = (meta.reg_num).index(regnum)
                        elif mesh_char == &#39;e1&#39;: # [T-Deposit2]
                            value_str = part.split(&#39;=&#39;)[1].strip()
                            ie = int(value_str) - 1
                        elif mesh_char == &#39;e2&#39;: # [T-Deposit2]
                            value_str = part.split(&#39;=&#39;)[1].strip()
                            ic = int(value_str) - 1
                        elif mesh_char in mesh_kind_chars or mesh_char in replace_eq_strs_dict:
                            if mesh_char in replace_eq_strs_dict:
                                mesh_char = replace_eq_strs_dict[mesh_char]
                            if &#39;i&#39;+mesh_char not in part: continue # only looking for indices for meshes, not values
                            imesh = mesh_kind_chars.index(mesh_char)
                            itdata_axis = mesh_kind_iax[imesh]
                            tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                            value = str(int(part.split(&#39;=&#39;)[1].strip()) - 1)
                            if mesh_char == &#39;l&#39; and meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39; and meta[&#39;axis&#39;] == &#39;chart&#39;:
                                i_metastable = int(value) + 1
                                il = 0
                            else:
                                exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                        elif mesh_char in ignored_eq_strs:
                            continue
                        elif meta[&#39;tally_type&#39;]==&#39;[T-Cross]&#39;:
                            ierr_mod = 0
                            if meta[&#39;mesh&#39;] == &#39;xyz&#39; and mesh_char==&#39;z surf&#39;:
                                #imesh = mesh_kind_chars.index(&#39;z&#39;)
                                itdata_axis = 2 #mesh_kind_iax[imesh]
                                tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                                value = str(int(part.split(&#39;=&#39;)[1].strip()) - 1)
                                exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                            elif meta[&#39;mesh&#39;] == &#39;r-z&#39;:
                                if mesh_char==&#39;r surf&#39;:
                                    # imesh = mesh_kind_chars.index(&#39;y&#39;)
                                    itdata_axis = 0 #1  # mesh_kind_iax[imesh]
                                    tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                                    value = str(int(part.split(&#39;=&#39;)[1].strip()) - 1)
                                    exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                                    #ir, ic = -1, -1
                                    ierr_mod = int(ierr_max / 2)
                                elif mesh_char==&#39;z surf&#39;:
                                    # imesh = mesh_kind_chars.index(&#39;c&#39;)
                                    itdata_axis = 2 #8  # mesh_kind_iax[imesh]
                                    tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                                    value = str(int(part.split(&#39;=&#39;)[1].strip()) - 1)
                                    exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                                    iy, iz = -1, -1
                                    ierr_mod = 0
                                else:
                                    raise ValueError(&#39;ERROR! Unregistered potential index [&#39;+ part.split(&#39;=&#39;)[0].strip()+&#39;] found&#39;)
                            else:
                                raise ValueError(&#39;ERROR! Unregistered potential index [&#39;+ part.split(&#39;=&#39;)[0].strip()+ &#39;] found&#39;)
                        else:
                            raise ValueError(&#39;ERROR! Unregistered potential index [&#39;+part.split(&#39;=&#39;)[0].strip()+&#39;] found&#39;)


            # Now read data_table, with formatting dependent on 2D-type, and can be inferred from last line of header
            axis1_ivar = meta.axis_index_of_tally_array[0]
            axis2_ivar = meta.axis_index_of_tally_array[1]
            if meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39; and meta[&#39;axis&#39;] == &#39;chart&#39;: # this setting does not respect 2D-type and uses its own formatting
                data_write_format_str = data_table[0][3:]
                Z_y_segment = data_write_format_str.split(&#39;;&#39;)[0]
                N_x_segment = data_write_format_str.split(&#39;;&#39;)[1]
                Z_y_vals = Z_y_segment.replace(&#39;=&#39;,&#39;&#39;).replace(&#39;to&#39;,&#39;&#39;).replace(&#39;by&#39;,&#39;&#39;).replace(&#39;y&#39;,&#39;&#39;).strip().split()
                N_x_vals = N_x_segment.replace(&#39;=&#39;,&#39;&#39;).replace(&#39;to&#39;,&#39;&#39;).replace(&#39;by&#39;,&#39;&#39;).replace(&#39;x&#39;,&#39;&#39;).strip().split()
                Z_y_max, Z_y_min, Z_y_increment = int(Z_y_vals[0]), int(Z_y_vals[1]), int(Z_y_vals[2])
                N_x_max, N_x_min, N_x_increment = int(N_x_vals[1]), int(N_x_vals[0]), int(N_x_vals[2])
                #print(Z_y_max, Z_y_min, Z_y_increment, N_x_max, N_x_min, N_x_increment )
            elif meta[&#39;2D-type&#39;] != 4:
                data_write_format_str = data_header[-2][1:]
                if &#39;data&#39; not in data_write_format_str:
                    for line in data_header[::-1]:
                        if &#39;data&#39; in line:
                            data_write_format_str = line[1:]
                            break
                #print(data_write_format_str)
                if &#39;data&#39; not in data_write_format_str:
                    # failed to find a &#34;data&#34; line telling us how the values are ordered
                    # have to make guesses about output ordering...
                    # axis variable should give us a hint
                    axis = meta[&#39;axis&#39;]
                    if &#39;eng&#39; in axis or &#39;e1&#39; in axis or &#39;e2&#39; in axis:
                        if axis == &#39;e12&#39; or axis == &#39;e21&#39;:
                            ax1_ivar = &#39;ie&#39;
                            ax2_ivar = &#39;ie&#39;
                        else: # energy vs time
                            if axis[0] == &#39;t&#39;:
                                ax1_ivar = &#39;it&#39;
                                ax2_ivar = &#39;ie&#39;
                            else:
                                ax1_ivar = &#39;ie&#39;
                                ax2_ivar = &#39;it&#39;
                    else:
                        if &#39;axis1_label&#39; in meta and meta[&#39;axis1_label&#39;][0] in axis:
                            # we know horizontal axis variable
                            ax1_ivar = &#39;i&#39; + meta[&#39;axis1_label&#39;][0]
                            ax2_ivar = &#39;i&#39; + axis.replace(meta[&#39;axis1_label&#39;][0],&#39;&#39;)
                        else:
                            ax1_ivar = &#39;i&#39; + meta[&#39;axis&#39;][1]
                            ax2_ivar = &#39;i&#39; + meta[&#39;axis&#39;][0]
                else:
                    # We can, with confidence, determine output value ordering :)
                    for dsi in data_write_format_str.split():
                        if &#39;data&#39; in dsi:
                            data_index_str = dsi
                            ax_vars = data_index_str.replace(&#39;data&#39;,&#39;&#39;).replace(&#39;(&#39;,&#39;&#39;).replace(&#39;)&#39;,&#39;&#39;)
                            #print(data_index_str)
                            #print(ax_vars)
                            ax1_ivar, ax2_ivar = ax_vars.split(&#39;,&#39;)[:2]
                            ax1_ivar = &#39;i&#39; + ax1_ivar
                            ax2_ivar = &#39;i&#39; + ax2_ivar
                    #print(data_write_format_str)
            else:  # 2D-type = 4
                cols = data_table[1][1:].split()
                ax1_ivar, ax2_ivar = cols[0], cols[1]
                ax1_ivar = &#39;i&#39; + ax1_ivar
                ax2_ivar = &#39;i&#39; + ax2_ivar

            # manually fix [T-Deposit2] axes
            if meta[&#39;tally_type&#39;] == &#39;[T-Deposit2]&#39;:
                if meta[&#39;axis&#39;] == &#39;e12&#39;:
                    ax1_ivar, ax2_ivar = &#39;ie&#39;, &#39;ic&#39;
                elif meta[&#39;axis&#39;] == &#39;e21&#39;:
                    ax1_ivar, ax2_ivar = &#39;ic&#39;, &#39;ie&#39;
                elif meta[&#39;axis&#39;] == &#39;t-e1&#39;:
                    ax1_ivar, ax2_ivar = &#39;it&#39;, &#39;ie&#39;
                elif meta[&#39;axis&#39;] == &#39;t-e2&#39;:
                    ax1_ivar, ax2_ivar = &#39;it&#39;, &#39;ic&#39;
                elif meta[&#39;axis&#39;] == &#39;e1-t&#39;:
                    ax1_ivar, ax2_ivar = &#39;ie&#39;, &#39;it&#39;
                elif meta[&#39;axis&#39;] == &#39;e2-t&#39;:
                    ax1_ivar, ax2_ivar = &#39;ic&#39;, &#39;it&#39;

            if meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39; and meta[&#39;axis&#39;] == &#39;chart&#39;:
                remaining_ndata_to_read = (Z_y_max - Z_y_min + 1) * (N_x_max - N_x_min + 1)
            else:
                # check if this is one of the backwards instances
                expected_ax1_ivar = tdata_ivar_strs[axis1_ivar]
                expected_ax2_ivar = tdata_ivar_strs[axis2_ivar]
                if meta.mesh==&#39;xyz&#39;:
                    if expected_ax1_ivar == &#39;ir&#39;: expected_ax1_ivar = &#39;ix&#39;
                    if expected_ax2_ivar == &#39;ir&#39;: expected_ax1_ivar = &#39;ix&#39;
                if ax1_ivar==expected_ax1_ivar and ax2_ivar==expected_ax2_ivar:
                    pass # all is correct as is
                elif ax2_ivar == expected_ax1_ivar and ax1_ivar == expected_ax2_ivar:
                    axis1_ivar_temp = axis1_ivar
                    axis1_ivar = axis2_ivar
                    axis2_ivar = axis1_ivar_temp
                    #axis1_ivar = tdata_ivar_strs.index(ax1_ivar)
                    #axis2_ivar = tdata_ivar_strs.index(ax2_ivar)
                    #print(&#39;backwards!&#39;)
                else:
                    raise ValueError(&#39;ERROR! Unknown axes (&#39;+ax1_ivar+&#39; &#39;+ax2_ivar +
                                     &#39;) encountered that did not match expected axes (&#39; +
                                     tdata_ivar_strs[meta.axis_index_of_tally_array[0]]+&#39; &#39; +
                                     tdata_ivar_strs[meta.axis_index_of_tally_array[1]]+&#39;)&#39;)

                axis1_ivar_str = tdata_ivar_strs[axis1_ivar]
                axis2_ivar_str = tdata_ivar_strs[axis2_ivar]
                axis1_size = np.shape(tdata)[axis1_ivar]
                axis2_size = np.shape(tdata)[axis2_ivar]
                ndata_to_read = axis1_size*axis2_size
                #print(axis1_ivar_str,axis2_ivar_str)
                #print(axis1_size,axis2_size,ndata_to_read)
                remaining_ndata_to_read = ndata_to_read
                iax1 = 0
                iax2 = axis2_size - 1

            if meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39; and meta[&#39;axis&#39;] == &#39;chart&#39;:
                #Z_y_max, Z_y_min, Z_y_increment # big, 1, -1
                #N_x_max, N_x_min, N_x_increment # big, 1, 1
                current_Z = Z_y_max
                current_N = N_x_min - N_x_increment
                ic = 0
                for line in data_table[1:]:
                    values = data_row_to_num_list(line)
                    for value in values:
                        remaining_ndata_to_read += -1
                        current_N += N_x_increment
                        if current_N &gt; N_x_max:
                            current_N = N_x_min
                            current_Z += Z_y_increment
                        #print(&#39;Z=&#39;,current_Z,&#39;, N=&#39;,current_N)

                        if value != 0:
                            ZZZAAAM = 10000*current_Z + 10*(current_Z+current_N) + i_metastable
                            if ZZZAAAM not in ZZZAAAM_list:
                                ic = len(ZZZAAAM_list)
                                ZZZAAAM_list.append(ZZZAAAM)
                            else:
                                ic = ZZZAAAM_list.index(ZZZAAAM)
                            #print(ic, i_metastable)
                            #print(ic,value)
                            tdata[ir, iy, iz, ie, it, ia, il, ip, ic, ierr + ierr_mod] = value

                        if remaining_ndata_to_read &lt;= 0:
                            break







            elif meta[&#39;2D-type&#39;] in [1,2,3,6,7]:
                for line in data_table[1:]:
                    values = data_row_to_num_list(line)
                    #print(line)
                    for value in values:
                        exec(axis1_ivar_str + &#39; = &#39; + str(iax1), globals())
                        exec(axis2_ivar_str + &#39; = &#39; + str(iax2), globals())
                        #print(ir, iy, iz, ie, it, ia, il, ip, ic, ierr, &#39;\t&#39;, value)
                        tdata[ir, iy, iz, ie, it, ia, il, ip, ic, ierr + ierr_mod] = value
                        remaining_ndata_to_read += -1
                        #print(iax1, iax2)
                        iax1 += 1
                        if iax1 == axis1_size:
                            iax1 = 0
                            iax2 += -1
                    if remaining_ndata_to_read &lt;= 0:
                        break

            elif meta[&#39;2D-type&#39;] == 4:
                iax2 = 0
                for line in data_table[2:]:
                    values = data_row_to_num_list(line)
                    value = values[2]
                    value_err = values[3]
                    exec(axis1_ivar_str + &#39; = &#39; + str(iax1), globals())
                    exec(axis2_ivar_str + &#39; = &#39; + str(iax2), globals())
                    tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 0 + ierr_mod] = value
                    tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 1 + ierr_mod] = value_err
                    # print(ir, iy, iz, ie, it, ia, il, ip, ic, ierr,&#39;\t&#39;,value)
                    remaining_ndata_to_read += -1
                    # print(iax1, iax2)
                    iax1 += 1
                    if iax1 == axis1_size:
                        iax1 = 0
                        iax2 += 1

                    if remaining_ndata_to_read &lt;= 0:
                        break

            elif meta[&#39;2D-type&#39;] == 5:
                for line in data_table[2:]:
                    values = data_row_to_num_list(line)
                    #print(line)
                    for vi, value in enumerate(values):
                        if vi==0: continue # header column
                        exec(axis1_ivar_str + &#39; = &#39; + str(iax1), globals())
                        exec(axis2_ivar_str + &#39; = &#39; + str(iax2), globals())
                        #print(ir, iy, iz, ie, it, ia, il, ip, ic, ierr, &#39;\t&#39;, value)
                        tdata[ir, iy, iz, ie, it, ia, il, ip, ic, ierr + ierr_mod] = value
                        remaining_ndata_to_read += -1
                        # print(iax1, iax2)
                        iax1 += 1
                        if iax1 == axis1_size:
                            iax1 = 0
                            iax2 += -1
                    if remaining_ndata_to_read &lt;= 0:
                        break

            else:
                raise ValueError(&#39;ERROR! unsupported 2D-type of &#39;+str(meta[&#39;2D-type&#39;])+&#39; provided; legal values are [1,2,3,4,5,6,7]&#39;)

    else:
        raise ValueError(str(meta.axis_dimensions)+&#39;axis dimensions is unknown, ERROR!&#39;)

    if len(banked_uninterpreted_lines) != 0:
        print(&#39;The following potentially useful output lines were found but not stored anywhere:&#39;)
        for line in banked_uninterpreted_lines:
            print(&#39;\t&#39;+line)

    return_updated_metadata_too = False
    if meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39;:
        return_updated_metadata_too = True
        if meta[&#39;axis&#39;] == &#39;chart&#39;:
            meta[&#39;nuclide_ZZZAAAM_list&#39;] = ZZZAAAM_list
            meta[&#39;nuclide_isomer_list&#39;] = [ZZZAAAM_to_nuclide_plain_str(i) for i in ZZZAAAM_list]
            nc_max = len(ZZZAAAM_list) #+ 1
            meta[&#39;nc&#39;] = nc_max
            tdata = tdata[:,:,:,:,:,:,:,:,:nc_max,:]
        elif meta[&#39;axis&#39;] == &#39;charge&#39; or meta[&#39;axis&#39;] == &#39;mass&#39;:
            ic_axis_tdata_sum = tdata.sum(axis=(0,1,2,3,4,5,6,7,9))
            nc_max = np.max(np.nonzero(ic_axis_tdata_sum)) + 1
            meta[&#39;nc&#39;] = nc_max
            tdata = tdata[:, :, :, :, :, :, :, :, :nc_max, :]

    if return_updated_metadata_too:
        return tdata, meta
    else:
        return tdata</code></pre>
</details>
</dd>
<dt id="PHITS_tools.build_tally_Pandas_dataframe"><code class="name flex">
<span>def <span class="ident">build_tally_Pandas_dataframe</span></span>(<span>tdata, meta)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Calculates the absolute uncertainty for every value in the PHITS tally data array</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code>import pandas as pd</code></li>
</ul>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>tdata</code> = 10-dimensional NumPy array containing read/extracted tally results</li>
<li><code>meta</code> = Munch object / dictionary containing tally metadata</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>tally_df</code> = Pandas dataframe containing the entire contents of the <code>tdata</code> array;
note that tally_df.attrs returns values which are the same for all rows</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_tally_Pandas_dataframe(tdata,meta):
    &#39;&#39;&#39;
    Description:
        Calculates the absolute uncertainty for every value in the PHITS tally data array

    Dependencies:
        - `import pandas as pd`

    Inputs:
        - `tdata` = 10-dimensional NumPy array containing read/extracted tally results
        - `meta` = Munch object / dictionary containing tally metadata

    Outputs:
        - `tally_df` = Pandas dataframe containing the entire contents of the `tdata` array;
                note that tally_df.attrs returns values which are the same for all rows

    &#39;&#39;&#39;
    import pandas as pd
    ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max, ierr_max = np.shape(tdata)
    num_df_rows = ir_max * iy_max * iz_max * ie_max * it_max * ia_max * il_max * ip_max * ic_max
    # determine what columns to include, based on what info was specified vs left at default values
    col_names_list = []

    in_irregular_TCross_rz_mesh = False
    in_irregular_TCross_xyz_mesh = False
    ierr_mod = 0
    if meta[&#39;tally_type&#39;] == &#39;[T-Cross]&#39; and (meta.mesh == &#39;xyz&#39; or meta.mesh == &#39;r-z&#39;):
        if &#39;enclos&#39; in meta and meta[&#39;enclos&#39;] == 1:
            pass
        else:
            if meta.mesh == &#39;r-z&#39;:
                in_irregular_TCross_rz_mesh = True
                min_r_is_zero = False
                if meta[&#39;r-mesh_bin_edges&#39;][0]==0:
                    min_r_is_zero = True
                ierr_mod = int(ierr_max / 2)
            else:
                in_irregular_TCross_xyz_mesh = True


    # region columns
    if meta.mesh == &#39;reg&#39;:
        reg_cols = [&#39;ir&#39;,&#39;reg&#39;,&#39;reg#&#39;] # use meta.reg_groups and meta.reg_num
    elif meta.mesh == &#39;xyz&#39;:
        if in_irregular_TCross_xyz_mesh:
            reg_cols = [&#39;ix&#39;, &#39;iy&#39;, &#39;iz&#39;, &#39;x_mid&#39;, &#39;y_mid&#39;, &#39;z_surf&#39;]
        else:
            reg_cols = [&#39;ix&#39;,&#39;iy&#39;,&#39;iz&#39;,&#39;x_mid&#39;,&#39;y_mid&#39;,&#39;z_mid&#39;]
    elif meta.mesh == &#39;r-z&#39;:
        if in_irregular_TCross_rz_mesh:
            #reg_cols = [&#39;ir&#39;, &#39;ic&#39;, &#39;r_mid&#39;, &#39;z_surf&#39;, &#39;iy&#39;, &#39;iz&#39;, &#39;r_surf&#39;, &#39;z_mid&#39;]
            reg_cols = [&#39;ir&#39;, &#39;iz&#39;, &#39;r_mid&#39;, &#39;z_surf&#39;, &#39;r_surf&#39;, &#39;z_mid&#39;]
        else:
            reg_cols = [&#39;ir&#39;,&#39;iz&#39;,&#39;r_mid&#39;,&#39;z_mid&#39;]
    elif meta.mesh == &#39;tet&#39;:
        reg_cols = [&#39;ir&#39;,&#39;tet&#39;] #,&#39;tet#&#39;]
    elif meta.mesh == &#39;point&#39;:
        reg_cols = [&#39;ir&#39;,&#39;point#&#39;]
    elif meta.mesh == &#39;ring&#39;:
        reg_cols = [&#39;ir&#39;,&#39;ring#&#39;]
    col_names_list += reg_cols



    # Determine what other columns will be present
    ecols, tcols, acols, lcols, pcols, ccols = False, False, False, False, False, False
    single_specified_bin_axes = [] # log axes which are provided by user but only contain 1 bin
    single_bin_ranges_or_values = []
    if meta.ne != None:
        if meta.ne==1:
            single_specified_bin_axes.append(&#39;e&#39;)
            single_bin_ranges_or_values.append([&#39;Energy&#39;,meta[&#39;e-mesh_bin_edges&#39;]])
        else:
            ecols = True
            ecol_names_list = [&#39;ie&#39;,&#39;e_mid&#39;]
            col_names_list += ecol_names_list
    else:
        single_bin_ranges_or_values.append([&#39;Energy&#39;,&#39;default/all&#39;])
    if meta.nt != None:
        if meta.nt==1:
            single_specified_bin_axes.append(&#39;t&#39;)
            single_bin_ranges_or_values.append([&#39;Time&#39;,meta[&#39;t-mesh_bin_edges&#39;]])
        else:
            tcols = True
            tcol_names_list = [&#39;it&#39;, &#39;t_mid&#39;]
            col_names_list += tcol_names_list
    else:
        single_bin_ranges_or_values.append([&#39;Time&#39;,&#39;default/all&#39;])
    if meta.na != None:
        if meta.na==1:
            single_specified_bin_axes.append(&#39;a&#39;)
            single_bin_ranges_or_values.append([&#39;Angle&#39;,meta[&#39;a-mesh_bin_edges&#39;]])
        else:
            acols = True
            acol_names_list = [&#39;ia&#39;, &#39;a_mid&#39;]
            col_names_list += acol_names_list
    else:
        single_bin_ranges_or_values.append([&#39;Angle&#39;,&#39;default/all&#39;])
    if meta.nl != None:
        if meta.nl==1:
            single_specified_bin_axes.append(&#39;l&#39;)
            single_bin_ranges_or_values.append([&#39;LET&#39;,meta[&#39;l-mesh_bin_edges&#39;]])
        else:
            lcols = True
            lcol_names_list = [&#39;il&#39;, &#39;LET_mid&#39;]
            col_names_list += lcol_names_list
    else:
        single_bin_ranges_or_values.append([&#39;LET&#39;,&#39;default/all&#39;])

    if meta.nc != None:
        if meta.nc == 1:
            pass
        else:
            ccols = True
            if meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39;:
                if meta[&#39;axis&#39;] == &#39;chart&#39;:
                    ccol_names_list = [&#39;ic&#39;, &#39;nuclide&#39;, &#39;ZZZAAAM&#39;]
                    col_names_list += ccol_names_list
                elif meta[&#39;axis&#39;] == &#39;charge&#39;:
                    ccol_names_list = [&#39;ic/Z/charge&#39;]
                    col_names_list += ccol_names_list
                elif meta[&#39;axis&#39;] == &#39;mass&#39;:
                    ccol_names_list = [&#39;ic/A/mass&#39;]
                    col_names_list += ccol_names_list
            elif meta[&#39;tally_type&#39;] == &#39;[T-Deposit2]&#39;:
                pass

    if meta.npart != None: # and meta.part_groups[0]==&#39;all&#39;:
        if meta.npart==1:
            single_specified_bin_axes.append(&#39;p&#39;)
            single_bin_ranges_or_values.append([&#39;Particle&#39;,meta.part_groups[0]])
        else:
            pcols = True
            pcol_names_list = [&#39;ip&#39;, &#39;particle&#39;, &#39;kf-code&#39;]
            col_names_list += pcol_names_list
    else:
        single_bin_ranges_or_values.append([&#39;Particle&#39;,&#39;default/all&#39;])

    # HANDLE SPECIAL COLUMNS HERE (ic / ccols)


    # value columns come last
    val_names_list = [&#39;value&#39;, &#39;rel.err.&#39;]
    if ierr_max == 3 or ierr_max == 6: val_names_list += [&#39;abs.err.&#39;]
    if ierr_max &gt;= 4: val_names_list += [&#39;value2&#39;, &#39;rel.err.2&#39;]
    if ierr_max == 6: val_names_list += [&#39;abs.err.2&#39;]
    col_names_list += val_names_list

    # Initialize dictionary
    df_dict = {}
    for col in col_names_list:
        df_dict[col] = []


    # Populate dictionary
    for ir in range(ir_max):
        for iy in range(iy_max):
            for iz in range(iz_max):
                for ie in range(ie_max):
                    for it in range(it_max):
                        for ia in range(ia_max):
                            for il in range(il_max):
                                for ip in range(ip_max):
                                    for ic in range(ic_max):
                                        # Region columns
                                        if in_irregular_TCross_rz_mesh:
                                            if (ir == ir_max - 1 and iz == iz_max - 1): # only index that should be empty
                                                continue
                                            # [&#39;ir&#39;, &#39;iz&#39;, &#39;r_mid&#39;, &#39;z_surf&#39;, &#39;r_surf&#39;, &#39;z_mid&#39;]
                                            df_dict[reg_cols[0]].append(ir)
                                            df_dict[reg_cols[1]].append(iz)
                                            if ir==ir_max-1:
                                                df_dict[reg_cols[2]].append(None)
                                            else:
                                                df_dict[reg_cols[2]].append(meta[&#39;r-mesh_bin_mids&#39;][ir])
                                            df_dict[reg_cols[3]].append(meta[&#39;z-mesh_bin_edges&#39;][iz])
                                            df_dict[reg_cols[4]].append(meta[&#39;r-mesh_bin_edges&#39;][ir])
                                            if iz == iz_max - 1:
                                                df_dict[reg_cols[5]].append(None)
                                            else:
                                                df_dict[reg_cols[5]].append(meta[&#39;z-mesh_bin_mids&#39;][iz])
                                            # OLD IMPLEMENTATION IS BELOW:
                                            &#39;&#39;&#39;
                                            # skip unwritten indices
                                            # reg_cols = [&#39;ir&#39;, &#39;ic&#39;, &#39;r_mid&#39;, &#39;z_surf&#39;, &#39;iy&#39;, &#39;iz&#39;, &#39;r_surf&#39;, &#39;z_mid&#39;]
                                            if (ir==ir_max-1 and ic==ic_max-1):
                                                if (iy == iy_max - 1 or iz == iz_max - 1): continue
                                                if min_r_is_zero and iy==0: continue # surface vals not written for r=0.0
                                                df_dict[reg_cols[0]].append(None)
                                                df_dict[reg_cols[1]].append(None)
                                                df_dict[reg_cols[2]].append(None)
                                                df_dict[reg_cols[3]].append(None)
                                                df_dict[reg_cols[4]].append(iy)
                                                df_dict[reg_cols[5]].append(iz)
                                                df_dict[reg_cols[6]].append(meta[&#39;r-mesh_bin_edges&#39;][iy])
                                                df_dict[reg_cols[7]].append(meta[&#39;z-mesh_bin_mids&#39;][iz])
                                            elif (iy==iy_max-1 and iz==iz_max-1):
                                                if (ir == ir_max - 1 or ic == ic_max - 1): continue
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(ic)
                                                df_dict[reg_cols[2]].append(meta[&#39;r-mesh_bin_mids&#39;][ir])
                                                df_dict[reg_cols[3]].append(meta[&#39;z-mesh_bin_edges&#39;][ic])
                                                df_dict[reg_cols[4]].append(None)
                                                df_dict[reg_cols[5]].append(None)
                                                df_dict[reg_cols[6]].append(None)
                                                df_dict[reg_cols[7]].append(None)
                                            else: # all other indices should not have any content written into them
                                                continue
                                            &#39;&#39;&#39;
                                        else:
                                            if meta.mesh == &#39;reg&#39;: #reg_cols = [&#39;ir&#39;,&#39;reg&#39;, &#39;reg#&#39;]  # use meta.reg_groups and meta.reg_num
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(meta.reg_groups[ir])
                                                df_dict[reg_cols[2]].append(meta.reg_num[ir])
                                            elif meta.mesh == &#39;xyz&#39;:
                                                #reg_cols = [&#39;ix&#39;, &#39;iy&#39;, &#39;iz&#39;, &#39;xmid&#39;, &#39;ymid&#39;, &#39;zmid&#39;]
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(iy)
                                                df_dict[reg_cols[2]].append(iz)
                                                df_dict[reg_cols[3]].append(meta[&#39;x-mesh_bin_mids&#39;][ir])
                                                df_dict[reg_cols[4]].append(meta[&#39;y-mesh_bin_mids&#39;][iy])
                                                if in_irregular_TCross_xyz_mesh:
                                                    df_dict[reg_cols[5]].append(meta[&#39;z-mesh_bin_edges&#39;][iz])
                                                else:
                                                    df_dict[reg_cols[5]].append(meta[&#39;z-mesh_bin_mids&#39;][iz])
                                            elif meta.mesh == &#39;r-z&#39;:
                                                #reg_cols = [&#39;ir&#39;, &#39;iz&#39;, &#39;rmid&#39;, &#39;zmid&#39;]
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(iz)
                                                df_dict[reg_cols[2]].append(meta[&#39;r-mesh_bin_mids&#39;][ir])
                                                df_dict[reg_cols[3]].append(meta[&#39;z-mesh_bin_mids&#39;][iz])
                                            elif meta.mesh == &#39;tet&#39;:
                                                #reg_cols = [&#39;ir&#39;,&#39;tet&#39;]
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(meta.tet_num[ir])
                                            elif meta.mesh == &#39;point&#39;:
                                                #reg_cols = [&#39;ir&#39;,&#39;point#&#39;]
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(str(ir+1))
                                            elif meta.mesh == &#39;ring&#39;:
                                                #reg_cols = [&#39;ir&#39;,&#39;ring#&#39;]
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(str(ir+1))

                                        #ecols, tcols, acols, lcols, pcols, ccols
                                        if pcols: # pcol_names_list = [&#39;ip&#39;, &#39;particle&#39;, &#39;kf-code&#39;]
                                            df_dict[pcol_names_list[0]].append(ip)
                                            df_dict[pcol_names_list[1]].append(meta.part_groups[ip])
                                            df_dict[pcol_names_list[2]].append(meta.kf_groups[ip])

                                        if ecols: # ecol_names_list = [&#39;ie&#39;,&#39;e_mid&#39;]
                                            df_dict[ecol_names_list[0]].append(ie)
                                            df_dict[ecol_names_list[1]].append(meta[&#39;e-mesh_bin_mids&#39;][ie])
                                        if tcols: # tcol_names_list = [&#39;it&#39;,&#39;t_mid&#39;]
                                            df_dict[tcol_names_list[0]].append(it)
                                            df_dict[tcol_names_list[1]].append(meta[&#39;t-mesh_bin_mids&#39;][it])
                                        if acols: # acol_names_list = [&#39;ia&#39;,&#39;a_mid&#39;]
                                            df_dict[acol_names_list[0]].append(ia)
                                            df_dict[acol_names_list[1]].append(meta[&#39;a-mesh_bin_mids&#39;][ia])
                                        if lcols: # lcol_names_list = [&#39;il&#39;,&#39;LET_mid&#39;]
                                            df_dict[lcol_names_list[0]].append(il)
                                            df_dict[lcol_names_list[1]].append(meta[&#39;l-mesh_bin_mids&#39;][il])

                                        if ccols:
                                            if meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39;:
                                                if meta[&#39;axis&#39;] == &#39;chart&#39;:
                                                    #ccol_names_list = [&#39;ic&#39;, &#39;nuclide&#39;, &#39;ZZZAAAM&#39;]
                                                    df_dict[ccol_names_list[0]].append(ic)
                                                    df_dict[ccol_names_list[1]].append(meta[&#39;nuclide_isomer_list&#39;][ic])
                                                    df_dict[ccol_names_list[2]].append(meta[&#39;nuclide_ZZZAAAM_list&#39;][ic])
                                                elif meta[&#39;axis&#39;] == &#39;charge&#39;:
                                                    #ccol_names_list = [&#39;ic/Z/charge&#39;]
                                                    df_dict[ccol_names_list[0]].append(ic)
                                                elif meta[&#39;axis&#39;] == &#39;mass&#39;:
                                                    #ccol_names_list = [&#39;ic/A/mass&#39;]
                                                    df_dict[ccol_names_list[0]].append(ic)

                                        # Value columns
                                        #val_names_list = [&#39;value&#39;, &#39;rel.err.&#39;,&#39;abs.err.&#39;]
                                        df_dict[val_names_list[0]].append(tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 0])
                                        df_dict[val_names_list[1]].append(tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 1])
                                        if ierr_max == 3 or ierr_max == 6:
                                            df_dict[val_names_list[2]].append(tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 2])
                                        if in_irregular_TCross_rz_mesh:
                                            df_dict[val_names_list[0+ierr_mod]].append(tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 0+ierr_mod])
                                            df_dict[val_names_list[1+ierr_mod]].append(tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 1+ierr_mod])
                                            if ierr_max == 6:
                                                df_dict[val_names_list[2+ierr_mod]].append(tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 2 + ierr_mod])


    # Convert dictionary to Pandas dataframe
    #for key in df_dict.keys():
    #    print(key,len(df_dict[key]))
    #sys.exit()
    tally_df = pd.DataFrame(df_dict)

    # store information on settings provided by user that are different from default but same for all rows
    if len(single_bin_ranges_or_values) &gt; 0:
        for i in single_bin_ranges_or_values:
            col, val = i
            tally_df.attrs[col] = val

    #with pd.option_context(&#39;display.max_rows&#39;, None, &#39;display.max_columns&#39;, None): print(tally_df)
    if in_debug_mode:
        #print(tally_df.to_string())
        print(tally_df.attrs)
    return tally_df</code></pre>
</details>
</dd>
<dt id="PHITS_tools.search_for_dump_parameters"><code class="name flex">
<span>def <span class="ident">search_for_dump_parameters</span></span>(<span>output_file)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Try to determine the dump settings used for a dump file by searching for the same file without "_dmp" and parsing
its header for the "dump = " line and subsequent line specifying the column ordering.</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code>from pathlib import Path</code></li>
</ul>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>output_file</code> = a file/filepath (string or Path object) to be judged</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>dump_data_number</code> = value following "dump = " in the PHITS tally (integer from -20 to 20, excluding 0) (D=<code>None</code>)</li>
<li><code>dump_data_sequence</code> = list of integers specifying the order and meaning of the dump file columns (D=<code>None</code>)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_for_dump_parameters(output_file):
    &#39;&#39;&#39;
    Description:
        Try to determine the dump settings used for a dump file by searching for the same file without &#34;_dmp&#34; and parsing
        its header for the &#34;dump = &#34; line and subsequent line specifying the column ordering.

    Dependencies:
        - `from pathlib import Path`

    Inputs:
        - `output_file` = a file/filepath (string or Path object) to be judged

    Outputs:
        - `dump_data_number` = value following &#34;dump = &#34; in the PHITS tally (integer from -20 to 20, excluding 0) (D=`None`)
        - `dump_data_sequence` = list of integers specifying the order and meaning of the dump file columns (D=`None`)
    &#39;&#39;&#39;
    dump_data_number, dump_data_sequence = None, None
    output_file = Path(output_file)
    origin_tally_file = Path(output_file.parent, output_file.stem.replace(&#39;_dmp&#39;,&#39;&#39;) + output_file.suffix)
    PHITS_file_type = determine_PHITS_output_file_type(origin_tally_file)
    if PHITS_file_type[&#39;file_does_not_exist&#39;]:
        print(&#34;Could not find this dump file&#39;s companion original standard tally output file&#34;,origin_tally_file)
        return dump_data_number, dump_data_sequence
    elif not PHITS_file_type[&#39;is_standard_tally_output&#39;]:
        print(&#34;Found dump file&#39;s suspected companion original standard tally output file, but it does not seem to actually be formatted as a standard tally output file&#34;,origin_tally_file)
        return dump_data_number, dump_data_sequence
    tally_header, tally_content = split_into_header_and_content(origin_tally_file)
    for li, line in enumerate(tally_header):
        if &#34;dump =&#34; in line:
            if line[0] == &#39;#&#39;:  # commented line
                key, value = extract_data_from_header_line(line[1:])
            else:
                key, value = extract_data_from_header_line(line)
            dump_data_number = int(value)
            dump_data_sequence_str_list = tally_header[li+1].strip().split()
            dump_data_sequence = [int(i) for i in dump_data_sequence_str_list]
            break
    if dump_data_number == None and dump_data_sequence == None:
        print(&#39;Was unable to locate dump specification information in tally output file&#39;,origin_tally_file)
    return dump_data_number, dump_data_sequence</code></pre>
</details>
</dd>
<dt id="PHITS_tools.determine_PHITS_output_file_type"><code class="name flex">
<span>def <span class="ident">determine_PHITS_output_file_type</span></span>(<span>output_file)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Determine what kind of PHITS file is being hanlded (tally standard output, binary tally dump, ASCII tally dump, etc.)</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code>from pathlib import Path</code></li>
</ul>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>output_file</code> = a file/filepath (string or Path object) to be judged</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>PHITS_file_type</code> = a dictionary of Booleans detailing what kind of file <code>output_file</code> is (and isn't) with
the following keys (each with a value set to <code>True</code> or <code>False</code>):
<code>'is_standard_tally_output'</code>, <code>'is_binary_tally_dump'</code>, <code>'is_ASCII_tally_dump'</code>,
<code>'is_unknown_file_type'</code>, and <code>'file_does_not_exist'</code>.
By default, all are set to <code>False</code> except for
<code>'is_unknown_file_type'</code> which is <code>True</code> by default.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def determine_PHITS_output_file_type(output_file):
    &#39;&#39;&#39;
    Description:
        Determine what kind of PHITS file is being hanlded (tally standard output, binary tally dump, ASCII tally dump, etc.)

    Dependencies:
        - `from pathlib import Path`

    Inputs:
        - `output_file` = a file/filepath (string or Path object) to be judged

    Outputs:
        - `PHITS_file_type` = a dictionary of Booleans detailing what kind of file `output_file` is (and isn&#39;t) with
            the following keys (each with a value set to `True` or `False`):
            `&#39;is_standard_tally_output&#39;`, `&#39;is_binary_tally_dump&#39;`, `&#39;is_ASCII_tally_dump&#39;`,
            `&#39;is_unknown_file_type&#39;`, and `&#39;file_does_not_exist&#39;`.  By default, all are set to `False` except for
            `&#39;is_unknown_file_type&#39;` which is `True` by default.
    &#39;&#39;&#39;
    PHITS_file_type = {&#39;is_standard_tally_output&#39;: False,
                       &#39;is_binary_tally_dump&#39;: False,
                       &#39;is_ASCII_tally_dump&#39;: False,
                       &#39;is_unknown_file_type&#39;: True,
                       &#39;file_does_not_exist&#39;: False
                       }
    output_file = Path(output_file)
    if not output_file.is_file():
        print(&#39;Provided output file&#39;,output_file,&#39;was determined to not be a file!&#39;)
        PHITS_file_type[&#39;is_unknown_file_type&#39;] = False
        PHITS_file_type[&#39;file_does_not_exist&#39;] = True
        return PHITS_file_type
    with open(output_file) as f:
        try:
            first_line = f.readline().strip()
        except:  # triggered if encountering binary / non ASCII or UTF-8 file
            if &#39;_dmp&#39; in output_file.stem:
                PHITS_file_type[&#39;is_binary_tally_dump&#39;] = True
                PHITS_file_type[&#39;is_unknown_file_type&#39;] = False
                return PHITS_file_type
        if first_line[0] == &#39;[&#39;:
            PHITS_file_type[&#39;is_standard_tally_output&#39;] = True
            PHITS_file_type[&#39;is_unknown_file_type&#39;] = False
        elif &#39;_dmp&#39; in output_file.stem:
            PHITS_file_type[&#39;is_ASCII_tally_dump&#39;] = True
            PHITS_file_type[&#39;is_unknown_file_type&#39;] = False
    return PHITS_file_type</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#how-to-use-the-phits_toolspy-module">How to use the PHITS_tools.py module</a></li>
<li><a href="#main-phits-output-parsing-functions">Main PHITS Output Parsing Functions</a></li>
<li><a href="#general-purpose-functions">General Purpose Functions</a></li>
<li><a href="#subfunctions-for-phits-output-parsing">Subfunctions for PHITS output parsing</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="PHITS_tools.parse_tally_output_file" href="#PHITS_tools.parse_tally_output_file">parse_tally_output_file</a></code></li>
<li><code><a title="PHITS_tools.parse_tally_dump_file" href="#PHITS_tools.parse_tally_dump_file">parse_tally_dump_file</a></code></li>
<li><code><a title="PHITS_tools.parse_all_tally_output_in_dir" href="#PHITS_tools.parse_all_tally_output_in_dir">parse_all_tally_output_in_dir</a></code></li>
<li><code><a title="PHITS_tools.fetch_MC_material" href="#PHITS_tools.fetch_MC_material">fetch_MC_material</a></code></li>
<li><code><a title="PHITS_tools.tally" href="#PHITS_tools.tally">tally</a></code></li>
<li><code><a title="PHITS_tools.rebinner" href="#PHITS_tools.rebinner">rebinner</a></code></li>
<li><code><a title="PHITS_tools.is_number" href="#PHITS_tools.is_number">is_number</a></code></li>
<li><code><a title="PHITS_tools.ZZZAAAM_to_nuclide_plain_str" href="#PHITS_tools.ZZZAAAM_to_nuclide_plain_str">ZZZAAAM_to_nuclide_plain_str</a></code></li>
<li><code><a title="PHITS_tools.nuclide_plain_str_to_latex_str" href="#PHITS_tools.nuclide_plain_str_to_latex_str">nuclide_plain_str_to_latex_str</a></code></li>
<li><code><a title="PHITS_tools.Element_Z_to_Sym" href="#PHITS_tools.Element_Z_to_Sym">Element_Z_to_Sym</a></code></li>
<li><code><a title="PHITS_tools.Element_Sym_to_Z" href="#PHITS_tools.Element_Sym_to_Z">Element_Sym_to_Z</a></code></li>
<li><code><a title="PHITS_tools.find" href="#PHITS_tools.find">find</a></code></li>
<li><code><a title="PHITS_tools.ICRP116_effective_dose_coeff" href="#PHITS_tools.ICRP116_effective_dose_coeff">ICRP116_effective_dose_coeff</a></code></li>
<li><code><a title="PHITS_tools.split_into_header_and_content" href="#PHITS_tools.split_into_header_and_content">split_into_header_and_content</a></code></li>
<li><code><a title="PHITS_tools.extract_data_from_header_line" href="#PHITS_tools.extract_data_from_header_line">extract_data_from_header_line</a></code></li>
<li><code><a title="PHITS_tools.data_row_to_num_list" href="#PHITS_tools.data_row_to_num_list">data_row_to_num_list</a></code></li>
<li><code><a title="PHITS_tools.parse_group_string" href="#PHITS_tools.parse_group_string">parse_group_string</a></code></li>
<li><code><a title="PHITS_tools.parse_tally_header" href="#PHITS_tools.parse_tally_header">parse_tally_header</a></code></li>
<li><code><a title="PHITS_tools.initialize_tally_array" href="#PHITS_tools.initialize_tally_array">initialize_tally_array</a></code></li>
<li><code><a title="PHITS_tools.calculate_tally_absolute_errors" href="#PHITS_tools.calculate_tally_absolute_errors">calculate_tally_absolute_errors</a></code></li>
<li><code><a title="PHITS_tools.split_str_of_equalities" href="#PHITS_tools.split_str_of_equalities">split_str_of_equalities</a></code></li>
<li><code><a title="PHITS_tools.parse_tally_content" href="#PHITS_tools.parse_tally_content">parse_tally_content</a></code></li>
<li><code><a title="PHITS_tools.build_tally_Pandas_dataframe" href="#PHITS_tools.build_tally_Pandas_dataframe">build_tally_Pandas_dataframe</a></code></li>
<li><code><a title="PHITS_tools.search_for_dump_parameters" href="#PHITS_tools.search_for_dump_parameters">search_for_dump_parameters</a></code></li>
<li><code><a title="PHITS_tools.determine_PHITS_output_file_type" href="#PHITS_tools.determine_PHITS_output_file_type">determine_PHITS_output_file_type</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>