<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>PHITS_tools API documentation</title>
<meta name="description" content="This module contains a variety of tools used for parsing PHITS output files â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:120ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>PHITS_tools</code></h1>
</header>
<section id="section-intro">
<p>This module contains a variety of tools used for parsing PHITS output files.</p>
<p>Specifically, it seeks to be a (nearly) universal PHITS output parser, supporting output from
all tallies, both normal output as well as dump file outputs (in ASCII and binary).</p>
<p>The functions contained in this module and brief descriptions of their functions are included below.
However, provided first is a description of the three different ways one can use this module.</p>
<h3 id="how-to-use-the-phits_toolspy-module"><strong>How to use the PHITS_tools.py module</strong></h3>
<p>There are three main ways one can use this Python module:</p>
<ol>
<li>As an <strong>imported Python module</strong><ul>
<li>In your own Python scripts, you can import this module as <code>from PHITS_tools import *</code> and call its main functions,
which are listed in the next section below, or any of its other functions documented here.</li>
</ul>
</li>
<li>As a <strong>command line interface (CLI)</strong><ul>
<li>This module can be ran on the command line with the individual PHITS output file to be parsed (or a directory
containing multiple files to be parsed) as the required argument.
Execute <code>python PHITS_tools.py --help</code> to see all of the different options that can be used with this module
to parse standard or dump PHITS output files (individually and directories containing them) via the CLI.</li>
</ul>
</li>
<li>As a <strong>graphical user interface (GUI)</strong><ul>
<li>[NOT YET DEVELOPED] When the module is executed without any additional arguments, <code>python PHITS_tools.py</code>, a GUI
will be launched to step you through selecting a file to be parsed and the various options for it.</li>
</ul>
</li>
</ol>
<p>The CLI and GUI options result in the parsed file's contents being saved to a pickle (or dill) file, which can be reopened
and used later in a Python script.
When using the main functions below within a Python script which has imported the PHITS_tools
module, you can optionally choose not to save the pickle files (if desired) and only have the tally output/dump parsing
functions return the data objects they produce for your own further analyses.</p>
<h3 id="main-phits-output-parsing-functions"><strong>Main PHITS Output Parsing Functions</strong></h3>
<ul>
<li><code><a title="PHITS_tools.parse_tally_output_file" href="#PHITS_tools.parse_tally_output_file">parse_tally_output_file()</a></code>
: general parser for standard output files for all PHITS tallies</li>
<li><code><a title="PHITS_tools.parse_tally_dump_file" href="#PHITS_tools.parse_tally_dump_file">parse_tally_dump_file()</a></code>
: parser for dump files from "dump" flag in PHITS [T-Cross], [T-Time], and [T-Track] tallies</li>
<li><code><a title="PHITS_tools.parse_all_tally_output_in_dir" href="#PHITS_tools.parse_all_tally_output_in_dir">parse_all_tally_output_in_dir()</a></code>
: run <code><a title="PHITS_tools.parse_tally_output_file" href="#PHITS_tools.parse_tally_output_file">parse_tally_output_file()</a></code> over all standard output files in a directory (and, optionally, <code><a title="PHITS_tools.parse_tally_dump_file" href="#PHITS_tools.parse_tally_dump_file">parse_tally_dump_file()</a></code> over all dump files too)</li>
</ul>
<h3 id="general-purpose-functions">General Purpose Functions</h3>
<ul>
<li><code><a title="PHITS_tools.is_number" href="#PHITS_tools.is_number">is_number()</a></code>
: returns Boolean denoting whether provided string is that of a number</li>
<li><code><a title="PHITS_tools.ZZZAAAM_to_nuclide_plain_str" href="#PHITS_tools.ZZZAAAM_to_nuclide_plain_str">ZZZAAAM_to_nuclide_plain_str()</a></code>
: returns a nuclide plaintext string for a given "ZZZAAAM" number (1000Z+10A+M)</li>
<li><code><a title="PHITS_tools.Element_Z_to_Sym" href="#PHITS_tools.Element_Z_to_Sym">Element_Z_to_Sym()</a></code>
: return an elemental symbol string given its proton number Z</li>
</ul>
<h3 id="subfunctions-for-phits-output-parsing">Subfunctions for PHITS output parsing</h3>
<p>(These are meant as dependencies more so than for standalone usage.)</p>
<ul>
<li><code><a title="PHITS_tools.split_into_header_and_content" href="#PHITS_tools.split_into_header_and_content">split_into_header_and_content()</a></code>
: initial reading of PHITS tally output, dividing it into header and "content" sections</li>
<li><code><a title="PHITS_tools.extract_data_from_header_line" href="#PHITS_tools.extract_data_from_header_line">extract_data_from_header_line()</a></code>
: extract metadata key/value pairs from tally output header lines</li>
<li><code><a title="PHITS_tools.data_row_to_num_list" href="#PHITS_tools.data_row_to_num_list">data_row_to_num_list()</a></code>
: extract numeric values from a line in the tally content section</li>
<li><code><a title="PHITS_tools.parse_group_string" href="#PHITS_tools.parse_group_string">parse_group_string()</a></code>
: split a string containing "groups" (e.g., regions) into a list of them</li>
<li><code><a title="PHITS_tools.parse_tally_header" href="#PHITS_tools.parse_tally_header">parse_tally_header()</a></code>
: extract metadata from tally output header section</li>
<li><code><a title="PHITS_tools.initialize_tally_array" href="#PHITS_tools.initialize_tally_array">initialize_tally_array()</a></code>
: initialize NumPy array for storing tally results</li>
<li><code><a title="PHITS_tools.calculate_tally_absolute_errors" href="#PHITS_tools.calculate_tally_absolute_errors">calculate_tally_absolute_errors()</a></code> : calculate absolute uncertainties from read values and relative errors</li>
<li><code><a title="PHITS_tools.split_str_of_equalities" href="#PHITS_tools.split_str_of_equalities">split_str_of_equalities()</a></code>
: split a string containing equalities (e.g., <code>reg = 100</code>) into a list of them</li>
<li><code><a title="PHITS_tools.parse_tally_content" href="#PHITS_tools.parse_tally_content">parse_tally_content()</a></code>
: extract tally results/values from tally content section</li>
<li><code><a title="PHITS_tools.build_tally_Pandas_dataframe" href="#PHITS_tools.build_tally_Pandas_dataframe">build_tally_Pandas_dataframe()</a></code>
: make Pandas dataframe from the main results NumPy array and the metadata</li>
<li><code><a title="PHITS_tools.search_for_dump_parameters" href="#PHITS_tools.search_for_dump_parameters">search_for_dump_parameters()</a></code>
: attempt to auto find "dump" parameters via possible standard tally output file</li>
<li><code><a title="PHITS_tools.determine_PHITS_output_file_type" href="#PHITS_tools.determine_PHITS_output_file_type">determine_PHITS_output_file_type()</a></code> : determine if a file is standard tally output or ASCII/binary dump file</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;

This module contains a variety of tools used for parsing PHITS output files.

Specifically, it seeks to be a (nearly) universal PHITS output parser, supporting output from
all tallies, both normal output as well as dump file outputs (in ASCII and binary).

The functions contained in this module and brief descriptions of their functions are included below.
However, provided first is a description of the three different ways one can use this module.

### **How to use the PHITS_tools.py module**

There are three main ways one can use this Python module:

 1. As an **imported Python module**
      - In your own Python scripts, you can import this module as `from PHITS_tools import *` and call its main functions,
         which are listed in the next section below, or any of its other functions documented here.
 2. As a **command line interface (CLI)**
      - This module can be ran on the command line with the individual PHITS output file to be parsed (or a directory
          containing multiple files to be parsed) as the required argument.
          Execute `python PHITS_tools.py --help` to see all of the different options that can be used with this module
          to parse standard or dump PHITS output files (individually and directories containing them) via the CLI.
 3. As a **graphical user interface (GUI)**
      - [NOT YET DEVELOPED] When the module is executed without any additional arguments, `python PHITS_tools.py`, a GUI
          will be launched to step you through selecting a file to be parsed and the various options for it.

The CLI and GUI options result in the parsed file&#39;s contents being saved to a pickle (or dill) file, which can be reopened
and used later in a Python script.  When using the main functions below within a Python script which has imported the PHITS_tools
module, you can optionally choose not to save the pickle files (if desired) and only have the tally output/dump parsing
functions return the data objects they produce for your own further analyses.

### **Main PHITS Output Parsing Functions**

- `parse_tally_output_file`         : general parser for standard output files for all PHITS tallies
- `parse_tally_dump_file`           : parser for dump files from &#34;dump&#34; flag in PHITS [T-Cross], [T-Time], and [T-Track] tallies
- `parse_all_tally_output_in_dir`   : run `parse_tally_output_file()` over all standard output files in a directory (and, optionally, `parse_tally_dump_file()` over all dump files too)

### General Purpose Functions

- `is_number`                       : returns Boolean denoting whether provided string is that of a number
- `ZZZAAAM_to_nuclide_plain_str`    : returns a nuclide plaintext string for a given &#34;ZZZAAAM&#34; number (1000Z+10A+M)
- `Element_Z_to_Sym`                : return an elemental symbol string given its proton number Z

### Subfunctions for PHITS output parsing
(These are meant as dependencies more so than for standalone usage.)

- `split_into_header_and_content`   : initial reading of PHITS tally output, dividing it into header and &#34;content&#34; sections
- `extract_data_from_header_line`   : extract metadata key/value pairs from tally output header lines
- `data_row_to_num_list`            : extract numeric values from a line in the tally content section
- `parse_group_string`              : split a string containing &#34;groups&#34; (e.g., regions) into a list of them
- `parse_tally_header`              : extract metadata from tally output header section
- `initialize_tally_array`          : initialize NumPy array for storing tally results
- `calculate_tally_absolute_errors` : calculate absolute uncertainties from read values and relative errors
- `split_str_of_equalities`         : split a string containing equalities (e.g., `reg = 100`) into a list of them
- `parse_tally_content`             : extract tally results/values from tally content section
- `build_tally_Pandas_dataframe`    : make Pandas dataframe from the main results NumPy array and the metadata
- `search_for_dump_parameters`      : attempt to auto find &#34;dump&#34; parameters via possible standard tally output file
- `determine_PHITS_output_file_type` : determine if a file is standard tally output or ASCII/binary dump file

&#39;&#39;&#39;
&#39;&#39;&#39;
Each function beings with a comment block containing the following sections:

    Description:


    Dependencies:


    Inputs:


    Outputs:

(&#34;Dependencies:&#34; is omitted when there are none.)        
&#39;&#39;&#39;

import sys
import os
import numpy as np
from munch import *
from pathlib import Path

# default program settings
launch_GUI = False
run_with_CLI_inputs = False
in_debug_mode = False

if __name__ == &#34;__main__&#34;:
    #in_debug_mode = True

    if in_debug_mode:
        pass
    elif len(sys.argv) == 1:
        launch_GUI = True
    else:
        run_with_CLI_inputs = True
        # CLI for PHITS Tools
        import argparse


if in_debug_mode:
    import pprint
    import time
    # Timer start
    start = time.time()



# use Path, get extension, check for existence of filename_err.extension


def parse_tally_output_file(tally_output_filepath, make_PandasDF = True, calculate_absolute_errors = True,
                            save_output_pickle = True, prefer_reading_existing_pickle = False):
    &#39;&#39;&#39;
    Description:
        Parse any PHITS tally output file, returning tally metadata and an array of its values (and optionally
        this data inside of a Pandas dataframe too).  Note the separate `parse_tally_dump_file` function for
        parsing PHITS dump files.

    Dependencies:
        - `import numpy as np`
        - `import pandas as pd` (if `make_PandasDF = True`)
        - `import pickle` (if `save_output_pickle = True`)
        - `from munch import *`
        - `from pathlib import Path`

    Inputs:
       (required)

        - `tally_output_filepath` = file or filepath to the tally output file to be parsed

    Inputs:
       (optional)

       - `make_PandasDF` = A Boolean determining whether a Pandas dataframe of the tally data array will be made (D=`True`)
       - `calculate_absolute_errors` = A Boolean determining whether the absolute uncertainty of each tally output value
                      is to be calculated (simply as the product of the value and relative error); if `False`, the final
                      dimension of `tally_data`, `ierr`, will be of length-2 rather than length-3 (D=`True`)
       - `save_output_pickle` = A Boolean determining whether the `tally_output` dictionary object is saved as a pickle file;
                      if `True`, the file will be saved with the same path and name as the provided PHITS tally output file
                      but with the .pickle extension. (D=`True`)
       - `prefer_reading_existing_pickle` = A Boolean determining what this function does if the pickle file this function
                      seeks to generate already exists.  If `False` (default behavior), this function will parse the PHITS
                      output files as usual and overwrite the existing pickle file.  If `True`, this function will instead
                      simply just read the existing found pickle file and return its stored `tally_output` contents. (D=`False`)

    Output:
        - `tally_output` = a dictionary object with the below keys and values:
            - `&#39;tally_data&#39;` = a 10-dimensional NumPy array containing all tally results, explained in more detail below
            - `&#39;tally_metadata&#39;` = a dictionary/Munch object with various data extracted from the tally output file, such as axis binning and units
            - `&#39;tally_dataframe&#39;` = (optionally included if setting `make_PandasDF = True`) a Pandas dataframe version of `tally_data`


    Notes:

       Many quantities can be scored across the various tallies in the PHITS code.  This function outputs a &#34;universal&#34;
       array `tally_data` that can accomodate all of the different scoring geometry meshes, physical quantities with
       assigned meshes, and output axes provided within PHITS.  This is achieved with a 10-dimensional array accessible as

       `tally_data[ ir, iy, iz, ie, it, ia, il, ip, ic, ierr ]`, with indices explained below:

       Tally data indices and corresponding mesh/axis:

        - `0` | `ir`, Geometry mesh: `reg` / `x` / `r` / `tet` ([T-Cross] `ir surf` if `mesh=r-z` with `enclos=0`)
        - `1` | `iy`, Geometry mesh:  `1` / `y` / `1`
        - `2` | `iz`, Geometry mesh:  `1` / `z` / `z` ([T-Cross] `iz surf` if `mesh=xyz` or `mesh=r-z` with `enclos=0`)
        - `3` | `ie`, Energy mesh: `eng` ([T-Deposit2] `eng1`)
        - `4` | `it`, Time mesh
        - `5` | `ia`, Angle mesh
        - `6` | `il`, LET mesh
        - `7` | `ip`, Particle type (`part = `)
        - `8` | `ic`, Special: [T-Deposit2] `eng2`; [T-Yield] `mass`, `charge`, `chart`
        - `9` | `ierr = 0/1/2`, Value / relative uncertainty / absolute uncertainty (expanded to `3/4/5`, or `2/3` if
        `calculate_absolute_errors = False`, for [T-Cross] `mesh=r-z` with `enclos=0` case; see notes further below)

       -----

       By default, all array dimensions are length-1 (except `ierr`, which is length-3).  These dimensions are set/corrected
       automatically when parsing the tally output file.  Thus, for very simple tallies, most of these indices will be
       set to 0 when accessing tally results, e.g. `tally_data[2,0,0,:,0,0,0,:,0,:]` to access the full energy spectrum
       in the third region for all scored particles / particle groups with the values and uncertainties.

       The output `tally_metadata` dictionary contains all information needed to identify every bin along every
       dimension: region numbers/groups, particle names/groups, bin edges and midpoints for all mesh types
       (x, y, z, r, energy, angle, time, and LET) used in the tally.

       The `tally_dataframe` Pandas dataframe output functions as normal.  Note that a dictionary containing supplemental
       information that is common to all rows of the dataframe can be accessed with `tally_dataframe.attrs`.

       -----

       At present, the following tallies are NOT supported by this function: [T-WWG], [T-WWBG], [T-Volume],
       [T-Userdefined], [T-Gshow], [T-Rshow], [T-3Dshow], [T-4Dtrack], and [T-Dchain].

       For [T-Dchain] or [T-Yield] with `axis = dchain`, please use the separate suite of parsing functions included in
       the [DCHAIN Tools](https://github.com/Lindt8/DCHAIN-Tools) module.

       -----

       The [T-Cross] tally is unique (scoring across region boundaries rather than within regions), creating some
       additional challenges.
       In the `mesh = reg` case, much is the same except each region number is composed of the `r-from` and `r-to` values, e.g. `&#39;100 - 101&#39;`.

       For `xyz` and `r-z` meshes, an additional parameter is at play: `enclos`.
       By default, `enclos=0`.
       In the event `enclos=1` is set, the total number of geometric regions is still either `nx*ny*nz` or `nr*nz` for
       `xyz` and `r-z` meshes, respectively.
       For `enclos=0` in the `mesh = xyz` case, the length of the z dimension (`iz` index) is instead equal to `nzsurf`,
       which is simply one greater than `nz` (# regions = `nx*ny*(nz+1)`).

       For `enclos=0` in the `mesh = r-z` case, this is much more complicated as PHITS will output every combination of
       `nr*nzsurf` AND `nrsurf*nz`, noting `nzsurf=nz+1` and `nrsurf=nr+1` (or `nrsurf=nr` if the first radius bin edge
       is `r=0.0`).
       The solution implemented here is to, for only this circumstance (in only the `enclos=0 mesh=r-z` case),
       set the length of the `ir` and `iz` dimensions to `nrsurf` and `nzsurf`, respectively, and also
       to expand the length of the final dimension of `tally_data` from 3 to 6 (or from 2 to 4 if `calculate_absolute_errors=False`), where:

        - `ierr = 0/1/2` refer to the combinations of `nr` and `nzsurf` (or `0/1` if `calculate_absolute_errors=False`)
        - `ierr = 3/4/5` refer to the combinations of `nrsurf` and `nz` (or `2/3` if `calculate_absolute_errors=False`)

       In this case, the Pandas dataframe, if enabled, will contain 3 (or 2) extra columns `value2` and `rel.err.2` [and `abs.err.2`],
       which correspond to the combinations of `nrsurf` and `nz` (while the original columns without the &#34;2&#34; refer to
       values for combinations of and `nr` and `nzsurf`).

       -----

       [T-Yield] is also a bit exceptional.  When setting the `axis` parameter equal to `charge`, `mass`, or `chart`,
       the `ic` dimension of `tally_data` is used for each entry of charge (proton number, Z), mass (A), or
       isotope/isomer, respectively.

       In the case of `axis = charge` or `axis = mass`, the value of `ic` refers to the actual charge/proton number Z
       or mass number A when accessing `tally_data`; for instance, `tally_data[:,:,:,:,:,:,:,:,28,:]`
       references results from nuclei with Z=28 if `axis = charge` or A=28 if `axis = mass`.  The length of the `ic`
       dimension is initialized as 130 or 320 but is later reduced to only just include the highest charge or mass value.

       In the case of `axis = chart`, the length of the `ic` dimension is initially set equal to the `mxnuclei` parameter
       in the [T-Yield] tally.  If `mxnuclei = 0` is set, then the length of the `ic` dimension is initially set to 10,000.
       This `ic` dimension length is later reduced to the total number of unique nuclides found in the output.
       Owing to the huge number of possible nuclides, a list of found nuclides with nonzero yield is assembled and
       added to `tally_metadata` under the keys `nuclide_ZZZAAAM_list` and `nuclide_isomer_list`, i.e.
       `tally_metadata[&#39;nuclide_ZZZAAAM_list&#39;]` and `tally_metadata[&#39;nuclide_isomer_list&#39;]`.
       These lists should be referenced to see what nuclide each of index `ic` refers to.
       The entries of the ZZZAAAM list are intergers calculated with the formula 10000\*Z + 10\*A + M, where M is the
       metastable state of the isomer (0 = ground state, 1 = 1st metastable/isomeric state, etc.).  The entries
       of the isomer list are these same nuclides in the same order but written as plaintext strings, e.g. `&#39;Al-28&#39;` and `&#39;Xe-133m1&#39;`.
       The lists are ordered in the same order nuclides are encountered while parsing the output file.
       Thus, to sensibly access the yield of a specific nuclide, one must first find its index `ic` in one of the two
       metadata lists of ZZZAAAM values or isomer names and then use that to access `tally_data`.  For example, to get
       the yield results of production of carbon-14 (C-14), one would use the following code:

       `ic = tally_metadata[&#39;nuclide_ZZZAAAM_list&#39;].index(60140)`

       OR

       `ic = tally_metadata[&#39;nuclide_isomer_list&#39;].index(&#39;C-14&#39;)`

       then

       `my_yield_values = tally_data[:,:,:,:,:,:,:,:,ic,:]`


    &#39;&#39;&#39;

    &#39;&#39;&#39;
    The old [T-Cross] mesh=r-z enclos=0 solution is written below:
        The solution implemented here uses `ir` to iterate `nr`, `iy` to iterate `nrsurf`, `iz` to
        iterate `nz`, and `ic` to iterate `nzsurf`.  Since only `rsurf*z [iy,iz]` and `r*zsurf [ir,ic]` pairs exist,
        when one pair is being written, the other will be `[-1,-1]`, thus the lengths of these dimensions for the array
        are increased by an extra 1 to prevent an overlap in the data written.
    &#39;&#39;&#39;
    pickle_filepath = Path(tally_output_filepath.parent, tally_output_filepath.stem + &#39;.pickle&#39;)
    if prefer_reading_existing_pickle and os.path.isfile(pickle_filepath):
        import pickle
        print(&#39;Reading found pickle file: &#39;, pickle_filepath)
        with open(pickle_filepath, &#39;rb&#39;) as handle:
            tally_output = pickle.load(handle)
        return tally_output

    # main toggled settings
    #calculate_absolute_errors = True
    construct_Pandas_frame_from_array = make_PandasDF
    #process_all_tally_out_files_in_directory = False
    save_pickle_files_of_output = save_output_pickle  # save metadata, array, and Pandas frame in a pickled dictionary object

    if construct_Pandas_frame_from_array: import pandas as pd

    # Check if is _err or _dmp file (or normal value file)
    is_val_file = False
    is_err_file = False
    is_dmp_file = False
    if tally_output_filepath.stem[-4:] == &#39;_err&#39;:
        is_err_file = True
    elif tally_output_filepath.stem[-4:] == &#39;_dmp&#39;:
        is_dmp_file = True
    else:
        is_val_file = True

    if is_dmp_file:
        print(&#39;ERROR: The provided file is a &#34;dump&#34; output file. Use the function titled &#34;parse_tally_dump_file&#34; to process it instead.&#39;)
        return None

    if is_err_file:
        print(&#39;WARNING: Provided file contains just relative uncertainties.&#39;,str(tally_output_filepath))
        potential_val_file = Path(tally_output_filepath.parent, tally_output_filepath.stem.replace(&#39;_err&#39;,&#39;&#39;) + tally_output_filepath.suffix)
        if potential_val_file.is_file():
            print(&#39;\t Instead, both it and the file with tally values will be parsed.&#39;)
            potential_err_file = tally_output_filepath
            tally_output_filepath = potential_val_file
            is_val_file = True
            is_err_file = False
        else:
            print(&#39;\t The corresponding file with tally values could not be found, so only these uncertainties will be parsed.&#39;)

    # Split content of output file into header and content
    if in_debug_mode: print(&#34;\nSplitting output into header and content...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    tally_header, tally_content = split_into_header_and_content(tally_output_filepath)
    if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    # print(len(tally_content))

    # Check if *_err file exists
    potential_err_file = Path(tally_output_filepath.parent, tally_output_filepath.stem + &#39;_err&#39; + tally_output_filepath.suffix)
    is_err_in_separate_file = potential_err_file.is_file()  # for some tallies/meshes, uncertainties are stored in a separate identically-formatted file

    # Extract tally metadata
    if in_debug_mode: print(&#34;\nExtracting tally metadata...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    tally_metadata = parse_tally_header(tally_header, tally_content)
    if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    if in_debug_mode: pprint.pp(dict(tally_metadata))
    # Check if tally_type is among those supported.
    unsupported_tally_types = [&#39;[T-WWG]&#39;, &#39;[T-WWBG]&#39;, &#39;[T-Volume]&#39;, &#39;[T-Userdefined]&#39;, &#39;[T-Gshow]&#39;, &#39;[T-Rshow]&#39;,
                               &#39;[T-3Dshow]&#39;, &#39;[T-4Dtrack]&#39;, &#39;[T-Dchain]&#39;]
    if tally_metadata[&#39;tally_type&#39;] in unsupported_tally_types:
        print(&#39;ERROR! tally type&#39;,tally_metadata[&#39;tally_type&#39;],&#39;is not supported by this function!&#39;)
        if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Dchain]&#39;:
            dchain_tools_url = &#39;github.com/Lindt8/DCHAIN-Tools&#39;
            print(&#39;However, the DCHAIN Tools module (&#39;,dchain_tools_url,&#39;) is capable of parsing all DCHAIN-related output.&#39;)
        return None
    if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Yield]&#39; and tally_metadata[&#39;axis&#39;] == &#39;dchain&#39;:
        dchain_tools_url = &#39;github.com/Lindt8/DCHAIN-Tools&#39;
        print(&#39;This function does not support [T-Yield] with setting &#34;axis = dchain&#34;.&#39;)
        print(&#39;However, the DCHAIN Tools module (&#39;, dchain_tools_url, &#39;) is capable of parsing all DCHAIN-related output.&#39;)
        return None

    # Initialize tally data array with zeros
    tally_data = initialize_tally_array(tally_metadata, include_abs_err=calculate_absolute_errors)

    # Parse tally data
    if is_val_file:
        err_mode = False
    else: # if is_err_file
        err_mode = True
    if in_debug_mode: print(&#34;\nParsing tally data...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    if tally_metadata[&#39;tally_type&#39;]==&#39;[T-Yield]&#39; and tally_metadata[&#39;axis&#39;] in [&#39;chart&#39;,&#39;charge&#39;,&#39;mass&#39;]: # need to update metadata too
        tally_data, tally_metadata = parse_tally_content(tally_data, tally_metadata, tally_content, is_err_in_separate_file, err_mode=err_mode)
    else:
        tally_data = parse_tally_content(tally_data, tally_metadata, tally_content, is_err_in_separate_file, err_mode=err_mode)
    if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    err_data_found = True
    if tally_metadata[&#39;axis_dimensions&#39;] == 2 and tally_metadata[&#39;2D-type&#39;] != 4:
        if is_err_file:
            err_data_found = False
        elif is_err_in_separate_file:
            err_tally_header, err_tally_content = split_into_header_and_content(potential_err_file)
            if in_debug_mode: print(&#34;\nParsing tally error...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
            if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Yield]&#39; and tally_metadata[&#39;axis&#39;] in [&#39;chart&#39;,&#39;charge&#39;,&#39;mass&#39;]:  # need to update metadata too
                tally_data, tally_metadata = parse_tally_content(tally_data, tally_metadata, err_tally_content, is_err_in_separate_file,err_mode=True)
            else:
                tally_data = parse_tally_content(tally_data, tally_metadata, err_tally_content, is_err_in_separate_file, err_mode=True)
            if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
        else:
            print(&#39;WARNING: A separate file ending in &#34;_err&#34; containing uncertainties should exist but was not found.&#39;)
            err_data_found = False
    if calculate_absolute_errors:
        if err_data_found:
            if in_debug_mode: print(&#34;\nCalculating absolute errors...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
            tally_data = calculate_tally_absolute_errors(tally_data)
            if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
        elif is_err_file:
            print(&#39;WARNING: Absolute errors not calculated since the main tally values file was not found.&#39;)
        else:
            print(&#39;WARNING: Absolute errors not calculated since the _err file was not found.&#39;)
    # Generate Pandas dataframe of tally results
    if construct_Pandas_frame_from_array:
        if in_debug_mode: print(&#34;\nConstructing Pandas dataframe...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
        tally_Pandas_df = build_tally_Pandas_dataframe(tally_data, tally_metadata)
        if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    else:
        tally_Pandas_df = None

    tally_output = {
        &#39;tally_data&#39;: tally_data,
        &#39;tally_metadata&#39;: tally_metadata,
        &#39;tally_dataframe&#39;: tally_Pandas_df,
    }

    if save_output_pickle:
        import pickle
        path_to_pickle_file = Path(tally_output_filepath.parent, tally_output_filepath.stem + &#39;.pickle&#39;)
        if in_debug_mode: print(&#34;\nWriting output to pickle file...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
        with open(path_to_pickle_file, &#39;wb&#39;) as handle:
            pickle.dump(tally_output, handle, protocol=pickle.HIGHEST_PROTOCOL)
            print(&#39;Pickle file written:&#39;, path_to_pickle_file, &#39;\n&#39;)
        if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))

    return tally_output



def parse_tally_dump_file(path_to_dump_file, dump_data_number=None , dump_data_sequence=None, return_directional_info=False,
                          use_degrees=False,max_entries_read=None,return_namedtuple_list=True,
                          return_Pandas_dataframe=True, save_namedtuple_list=False, save_Pandas_dataframe=False):
    &#39;&#39;&#39;
    Description:
        Parses the dump file of a [T-Cross], [T-Product], or [T-Time] tally generated by PHITS, in ASCII or binary format.

    Dependencies:
        - `from collections import namedtuple`
        - `from scipy.io import FortranFile`
        - `import pandas as pd` (if `return_Pandas_dataframe = True`)
        - `import dill` (if `save_namedtuple_list = True`)

    Inputs:
       (required)

        - `path_to_dump_file` = string or Path object denoting the path to the dump tally output file to be parsed
        - `dump_data_number` = integer number of data per row in dump file, binary if &gt;0 and ASCII if &lt;0.
                 This should match the value following `dump=` in the tally creating the dump file. (D=`None`)
                 If not specified, the search_for_dump_parameters() function will attempt to find it automatically.
        - `dump_data_sequence` = string or list of integers with the same number of entries as `dump_data_number`,
                 mapping each column in the dump file to their physical quantities.  (D=`None`)
                 This should match the line following the `dump=` line in the tally creating the dump file.
                 See PHITS manual section &#34;6.7.22 dump parameter&#34; for further explanations of these values.
                 If not specified, the search_for_dump_parameters() function will attempt to find it automatically.

    Inputs:
       (optional)

        - `return_directional_info` = (optional, D=`False`) Boolean designating whether extra directional information
                 should be calculated and returned; these include: radial distance `r` from the origin in cm,
                 radial distance `rho` from the z-axis in cm,
                 polar angle `theta` between the direction vector and z-axis in radians [0,pi] (or degrees), and
                 azimuthal angle `phi` of the direction vector in radians [-pi,pi] (or degrees).
                 Note: This option requires all position and direction values [x,y,z,u,v,w] to be included in the dump file.
        - `use_degrees` = (optional, D=`False`) Boolean designating whether angles `theta` and `phi` are returned
                 in units of degrees. Default setting is to return angles in radians.
        - `max_entries_read` = (optional, D=`None`) integer number specifying the maximum number of entries/records
                 of the dump file to be read.  By default, all records in the dump file are read.
        - `return_namedtuple_list` = (optional, D=`True`) Boolean designating whether `dump_data_list` is returned.
        - `return_Pandas_dataframe` = (optional, D=`True`) Boolean designating whether `dump_data_frame` is returned.
        - `save_namedtuple_list` = (optional, D=`False`) Boolean designating whether `dump_data_list` is saved to a dill file
                (for complicated reasons, objects containing namedtuples cannot be easily saved with pickle but can with dill).
        - `save_Pandas_dataframe` = (optional, D=`False`) Boolean designating whether `dump_data_frame` is saved to a pickle
                file (via Pandas .to_pickle()).

    Outputs:
        - `dump_data_list` = List of length equal to the number of records contained in the file. Each entry in the list
                 is a namedtuple containing all of the physical information in the dump file for a given particle event,
                 in the same order as specified in `dump_data_sequence` and using the same naming conventions for keys as
                 described in the PHITS manual section &#34;6.7.22 dump parameter&#34;. If `return_directional_info = True`,
                 `r`, `rho`, `theta`, and `phi` are appended to the end of this namedtuple, in that order.
        - `dump_data_frame` = A Pandas dataframe created from `dump_data_list` with columns for each physical quantity
                 and rows for each record included in the dump file.
    &#39;&#39;&#39;

    from collections import namedtuple
    from typing import NamedTuple
    from scipy.io import FortranFile
    if return_Pandas_dataframe:
        import pandas as pd
    if save_Pandas_dataframe or save_namedtuple_list:
        #import pickle
        import dill

    if not return_namedtuple_list and not return_Pandas_dataframe and not save_namedtuple_list and not save_Pandas_dataframe:
        print(&#39;ERROR: All &#34;return_namedtuple_list&#34;, &#34;return_Pandas_dataframe&#34;, &#34;save_namedtuple_list&#34;, and &#34;save_Pandas_dataframe&#34; are False. Enable at least one to use this function.&#39;)
        sys.exit()

    if dump_data_number == None or dump_data_sequence == None:
        dump_data_number, dump_data_sequence = search_for_dump_parameters(path_to_dump_file)
    if dump_data_number == None or dump_data_sequence == None:
        print(&#34;Please manually specify &#39;dump_data_number&#39; and &#39;dump_data_sequence&#39;; these were not inputted and could not be automatically found from an origin tally standard output file.&#34;)
        return None

    if isinstance(dump_data_sequence, str):
        dump_data_sequence = dump_data_sequence.split()
        dump_data_sequence = [int(i) for i in dump_data_sequence]
    dump_file_is_binary = True if (dump_data_number &gt; 0) else False  # if not binary, file will be ASCII
    data_values_per_line = abs(dump_data_number)
    if data_values_per_line != len(dump_data_sequence):
        print(&#39;ERROR: Number of values in &#34;dump_data_sequence&#34; is not equal to &#34;dump_data_number&#34;&#39;)
        sys.exit()

    # Generate NamedTuple for storing record information
    # See PHITS manual section &#34;6.7.22 dump parameter&#34; for descriptions of these values
    dump_quantities = [&#39;kf&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;e&#39;, &#39;wt&#39;, &#39;time&#39;, &#39;c1&#39;, &#39;c2&#39;, &#39;c3&#39;, &#39;sx&#39;, &#39;sy&#39;, &#39;sz&#39;,
                       &#39;name&#39;, &#39;nocas&#39;, &#39;nobch&#39;, &#39;no&#39;]
    ordered_record_entries_list = [dump_quantities[i - 1] for i in dump_data_sequence]
    rawRecord = namedtuple(&#39;rawRecord&#39;, ordered_record_entries_list)
    if return_directional_info:
        ordered_record_entries_list += [&#39;r&#39;, &#39;rho&#39;, &#39;theta&#39;, &#39;phi&#39;]
        angle_units_mult = 1
        if use_degrees: angle_units_mult = 180 / np.pi
    Record = namedtuple(&#39;Record&#39;, ordered_record_entries_list)

    records_list = []
    if dump_file_is_binary:
        # Read binary dump file; extract each record (particle)
        file_size_bytes = os.path.getsize(path_to_dump_file)
        record_size_bytes = (data_values_per_line + 1) * 8  # each record has 8 bytes per data value plus an 8-byte record end
        num_records = int(file_size_bytes / record_size_bytes)
        if max_entries_read != None:
            if max_entries_read &lt; num_records:
                num_records = max_entries_read
        # print(num_records)
        current_record_count = 0
        if return_directional_info:
            with FortranFile(path_to_dump_file, &#39;r&#39;) as f:
                while current_record_count &lt; num_records:
                    current_record_count += 1
                    raw_values = f.read_reals(float)
                    rawrecord = rawRecord(*raw_values)
                    # calculate r, rho, theta (w.r.t. z-axis), and phi (w.r.t. x axis)
                    r = np.sqrt(rawrecord.x ** 2 + rawrecord.y ** 2 + rawrecord.z ** 2)
                    rho = np.sqrt(rawrecord.x ** 2 + rawrecord.y ** 2)
                    dir_vector = [rawrecord.u, rawrecord.v, rawrecord.w]
                    theta = np.arccos(np.clip(np.dot(dir_vector, [0, 0, 1]), -1.0, 1.0)) * angle_units_mult
                    phi = np.arctan2(rawrecord.y, rawrecord.x) * angle_units_mult
                    record = Record(*raw_values, r, rho, theta, phi)
                    records_list.append(record)
        else: # just return data in dump file
            with FortranFile(path_to_dump_file, &#39;r&#39;) as f:
                while current_record_count &lt; num_records:
                    current_record_count += 1
                    raw_values = f.read_reals(float)
                    record = Record(*raw_values)
                    records_list.append(record)
    else: # file is ASCII
        if max_entries_read == None:
            max_entries_read = np.inf
        if return_directional_info:
            with open(path_to_dump_file, &#39;r&#39;) as f:
                current_record_count = 0
                for line in f:
                    current_record_count += 1
                    if current_record_count &gt; max_entries_read: break
                    line_str_values = line.replace(&#39;D&#39;, &#39;E&#39;).split()
                    raw_values = [float(i) for i in line_str_values]
                    rawrecord = rawRecord(*raw_values)
                    # calculate r, rho, theta (w.r.t. z-axis), and phi (w.r.t. x axis)
                    r = np.sqrt(rawrecord.x ** 2 + rawrecord.y ** 2 + rawrecord.z ** 2)
                    rho = np.sqrt(rawrecord.x ** 2 + rawrecord.y ** 2)
                    dir_vector = [rawrecord.u, rawrecord.v, rawrecord.w]
                    theta = np.arccos(np.clip(np.dot(dir_vector, [0, 0, 1]), -1.0, 1.0)) * angle_units_mult
                    phi = np.arctan2(rawrecord.y, rawrecord.x) * angle_units_mult
                    record = Record(*raw_values, r, theta, phi)
                    records_list.append(record)
        else: # just return data in dump file
            with open(path_to_dump_file, &#39;r&#39;) as f:
                current_record_count = 0
                for line in f:
                    current_record_count += 1
                    if current_record_count &gt; max_entries_read: break
                    line_str_values = line.replace(&#39;D&#39;, &#39;E&#39;).split()
                    raw_values = [float(i) for i in line_str_values]
                    record = Record(*raw_values)
                    records_list.append(record)
    #print(record)

    if save_namedtuple_list:
        path_to_dump_file = Path(path_to_dump_file)
        pickle_path = Path(path_to_dump_file.parent, path_to_dump_file.stem + &#39;_namedtuple_list.dill&#39;)
        with open(pickle_path, &#39;wb&#39;) as handle:
            dill.dump(records_list, handle, protocol=dill.HIGHEST_PROTOCOL)
            print(&#39;Pickle file written:&#39;, pickle_path, &#39;\n&#39;)

    if return_Pandas_dataframe or save_Pandas_dataframe:
        # Make Pandas dataframe from list of records
        records_df = pd.DataFrame(records_list, columns=Record._fields)
        if save_Pandas_dataframe:
            path_to_dump_file= Path(path_to_dump_file)
            pickle_path = Path(path_to_dump_file.parent, path_to_dump_file.stem + &#39;_Pandas_df.pickle&#39;)
            records_df.to_pickle(pickle_path)
            #with open(pickle_path, &#39;wb&#39;) as handle:
            #    pickle.dump(records_df, handle, protocol=pickle.HIGHEST_PROTOCOL)
            #    print(&#39;Pickle file written:&#39;, pickle_path, &#39;\n&#39;)

    if return_namedtuple_list and return_Pandas_dataframe:
        return records_list, records_df
    elif return_namedtuple_list:
        return records_list
    elif return_Pandas_dataframe:
        return records_df
    else:
        return None




def parse_all_tally_output_in_dir(tally_output_dirpath, output_file_suffix = &#39;.out&#39;, output_file_prefix = &#39;&#39;,
                                  output_file_required_string=&#39;&#39;, include_subdirectories=False,  return_tally_output=False,
                                  make_PandasDF=True, calculate_absolute_errors=True,
                                  save_output_pickle=True, prefer_reading_existing_pickle=False,
                                  include_dump_files=False,
                                  dump_data_number=None , dump_data_sequence=None,
                                  dump_return_directional_info=False, dump_use_degrees=False,
                                  dump_max_entries_read=None,
                                  dump_save_namedtuple_list=True, dump_save_Pandas_dataframe=True
                                  ):
    &#39;&#39;&#39;
    Description:
        Parse all standard PHITS tally output files in a directory, returning either a list of dictionaries containing
        tally metadata and an array of values from each tally output (and optionally this data inside of a Pandas dataframe too)
        or a list of filepaths to pickle files containing these dictionaries, as created with the `parse_tally_output_file()` function.
        This function allows selective processing of files in the directory by specification of strings which must
        appear at the start, end, and/or anywhere within each filename.
        Even if a file satisfies all of these naming criteria, the function will also check the first line of the file
        to determine if it is a valid tally output file (meaning, it will skip files such as phits.out and batch.out).
        It will also skip over &#34;_err&#34; uncertainty files as these are automatically found by the `parse_tally_output_file()`
        function after it processes that tally&#39;s main output file.
        This function will mainly process standard tally output files, but it can optionally process tally &#34;dump&#34; files too,
        though it can only save the dump outputs to its dill/pickle files and not return the (quite large) dump data objects.
        The filenames of saved dump data will not be included in the returned list.

    Dependencies:
        - `import os`
        - `import numpy as np`
        - `import pandas as pd` (if `make_PandasDF = True`)
        - `import pickle` (if `save_output_pickle = True`)
        - `from munch import *`
        - `from pathlib import Path`

    Inputs:
       (required)

        - `tally_output_dirpath` = Path (string or path object) to the tally output directory to be searched and parsed

    Inputs:
       (optional)

       - `output_file_suffix` = A string specifying what characters processed filenames (including the file extension)
                      must end in to be included.  This condition is not enforced if set to an empty string `&#39;&#39;`. (D=`&#39;.out&#39;`)
       - `output_file_prefix` = A string specifying what characters processed filenames (including the file extension)
                      must begin with to be included.  This condition is not enforced if set to an empty string `&#39;&#39;`. (D=`&#39;&#39;`)
       - `output_file_required_string` = A string which must be present anywhere within processed filenames (including the
                      file extension) to be included.  This condition is not enforced if set to an empty string `&#39;&#39;`. (D=`&#39;&#39;`)
       - `include_subdirectories` = A Boolean determining whether this function searches and processes all included
                      tally output files in this directory AND deeper subdirectories if set to `True`
                      or only the files directly within the provided directory `tally_output_dirpath` if set to `False` (D=`False`)
       - `return_tally_output` = A Boolean determining whether this function returns a list of `tally_output` dictionaries
                      if set to `True` or just a list of filepaths to the pickle files containing these dictionaries
                      if set to `False` (D=`False`)
       - `include_dump_files` = A Boolean determining whether dump files will be processed too or skipped. (D=`False`)
                      Settings to be applied to all encountered dump files can be specified per the optional inputs
                      detailed below which are simply passed to the `parse_tally_dump_file()` function.  Note that parameters
                      `return_namedtuple_list` and `return_Pandas_dataframe` will always be `False` when dump files are
                      processed in a directory with this function; instead, `save_namedtuple_list` and `save_Pandas_dataframe`
                      are by default set to `True` when parsing dump files in a directory with this function.  (Be warned,
                      if the dump file is large, the produced files from parsing them will be too.)

    Inputs:
       (optional, the same as in and directly passed to the `parse_tally_output_file()` function)

       - `make_PandasDF` = A Boolean determining whether a Pandas dataframe of the tally data array will be made (D=`True`)
       - `calculate_absolute_errors` = A Boolean determining whether the absolute uncertainty of each tally output value
                      is to be calculated (simply as the product of the value and relative error); if `False`, the final
                      dimension of `tally_data`, `ierr`, will be of length-2 rather than length-3 (D=`True`)
       - `save_output_pickle` = A Boolean determining whether the `tally_output` dictionary object is saved as a pickle file;
                      if `True`, the file will be saved with the same path and name as the provided PHITS tally output file
                      but with the .pickle extension. (D=`True`)
       - `prefer_reading_existing_pickle` = A Boolean determining what this function does if the pickle file this function
                      seeks to generate already exists.  If `False` (default behavior), this function will parse the PHITS
                      output files as usual and overwrite the existing pickle file.  If `True`, this function will instead
                      simply just read the existing found pickle file and return its stored `tally_output` contents. (D=`False`)

    Inputs:
       (optional, the same as in and directly passed to the `parse_tally_dump_file()` function)

       - `dump_data_number` = integer number of data per row in dump file, binary if &gt;0 and ASCII if &lt;0.
                This should match the value following `dump=` in the tally creating the dump file. (D=`None`)
                If not specified, the search_for_dump_parameters() function will attempt to find it automatically.
       - `dump_data_sequence` = string or list of integers with the same number of entries as `dump_data_number`,
                mapping each column in the dump file to their physical quantities.  (D=`None`)
                This should match the line following the `dump=` line in the tally creating the dump file.
                See PHITS manual section &#34;6.7.22 dump parameter&#34; for further explanations of these values.
                If not specified, the search_for_dump_parameters() function will attempt to find it automatically.
       - `dump_return_directional_info` = (optional, D=`False`) Boolean designating whether extra directional information
                should be calculated and returned; these include: radial distance `r` from the origin in cm,
                radial distance `rho` from the z-axis in cm,
                polar angle `theta` between the direction vector and z-axis in radians [0,pi] (or degrees), and
                azimuthal angle `phi` of the direction vector in radians [-pi,pi] (or degrees).
                Note: This option requires all position and direction values [x,y,z,u,v,w] to be included in the dump file.
       - `dump_use_degrees` = (optional, D=`False`) Boolean designating whether angles `theta` and `phi` are returned
                in units of degrees. Default setting is to return angles in radians.
       - `dump_max_entries_read` = (optional, D=`None`) integer number specifying the maximum number of entries/records
                of the dump file to be read.  By default, all records in the dump file are read.
       - `dump_save_namedtuple_list` = (optional, D=`True`) Boolean designating whether `dump_data_list` is saved to a dill file
               (for complicated reasons, objects containing namedtuples cannot be easily saved with pickle but can with dill).
       - `dump_save_Pandas_dataframe` = (optional, D=`True`) Boolean designating whether `dump_data_frame` is saved to a pickle
               file (via Pandas .to_pickle()).

    Output:
        - `tally_output_list` = a list of `tally_output` dictionary objects with the below keys and values / a list of
             file paths to pickle files containing `tally_output` dictionary objects:
            - `&#39;tally_data&#39;` = a 10-dimensional NumPy array containing all tally results, explained in more detail below
            - `&#39;tally_metadata&#39;` = a dictionary/Munch object with various data extracted from the tally output file, such as axis binning and units
            - `&#39;tally_dataframe&#39;` = (optionally included if setting `make_PandasDF = True`) a Pandas dataframe version of `tally_data`

    &#39;&#39;&#39;
    import os

    if not os.path.isdir(tally_output_dirpath):
        print(&#39;The provided path to &#34;tally_output_dir&#34; is not a directory:&#39;,tally_output_dirpath)
        if os.path.isfile(tally_output_dirpath):
            head, tail = os.path.split(tally_output_dirpath)
            tally_output_dirpath = head
            print(&#39;However, it is a valid path to a file; thus, its parent directory will be used:&#39;,tally_output_dirpath)
        else:
            print(&#39;Nor is it a valid path to a file. ERROR! Aborting...&#39;)
            return None

    if include_subdirectories:
        # Get paths to all files in this dir and subdirs
        files_in_dir = []
        for path, subdirs, files in os.walk(tally_output_dirpath):
            for name in files:
                files_in_dir.append(os.path.join(path, name))
    else:
        # Just get paths to files in this dir
        files_in_dir = [os.path.join(tally_output_dirpath, f) for f in os.listdir(tally_output_dirpath) if os.path.isfile(os.path.join(tally_output_dirpath, f))]

    # Determine which files should be parsed
    filepaths_to_process = []
    dump_filepaths_to_process = []
    len_suffix = len(output_file_suffix)
    len_prefix = len(output_file_prefix)
    len_reqstr = len(output_file_required_string)
    for f in files_in_dir:
        head, tail = os.path.split(f)
        if len_suffix &gt; 0 and tail[-len_suffix:] != output_file_suffix: continue
        if len_prefix &gt; 0 and tail[:len_prefix] != output_file_prefix: continue
        if len_reqstr &gt; 0 and output_file_required_string not in tail: continue
        if tail[(-4-len_suffix):] == &#39;_err&#39; + output_file_suffix: continue
        with open(f) as ff:
            try:
                first_line = ff.readline().strip()
            except: # triggered if encountering binary / non ASCII or UTF-8 file
                if include_dump_files and tail[(-4-len_suffix):] == &#39;_dmp&#39; + output_file_suffix:
                    dump_filepaths_to_process.append(f)
                continue
            if len(first_line) == 0: continue
            if first_line[0] != &#39;[&#39; :
                if include_dump_files and tail[(-4-len_suffix):] == &#39;_dmp&#39; + output_file_suffix:
                    dump_filepaths_to_process.append(f)
                continue
        filepaths_to_process.append(f)

    tally_output_pickle_path_list = []
    tally_output_list = []
    for f in filepaths_to_process:
        f = Path(f)
        path_to_pickle_file = Path(f.parent, f.stem + &#39;.pickle&#39;)
        tally_output_pickle_path_list.append(path_to_pickle_file)
        tally_output = parse_tally_output_file(f, make_PandasDF=make_PandasDF,
                                               calculate_absolute_errors=calculate_absolute_errors,
                                               save_output_pickle=save_output_pickle,
                                               prefer_reading_existing_pickle=prefer_reading_existing_pickle)
        if return_tally_output: tally_output_list.append(tally_output)

    if include_dump_files:
        for f in dump_filepaths_to_process:
            f = Path(f)
            parse_tally_dump_file(f, dump_data_number=dump_data_number, dump_data_sequence=dump_data_number,
                                  return_directional_info=dump_return_directional_info, use_degrees=dump_use_degrees,
                                  max_entries_read=dump_max_entries_read,
                                  return_namedtuple_list=False, return_Pandas_dataframe=False,
                                  save_namedtuple_list=dump_save_namedtuple_list,
                                  save_Pandas_dataframe=dump_save_Pandas_dataframe)

    if return_tally_output:
        return tally_output_list
    else:
        return tally_output_pickle_path_list


def is_number(n):
    &#39;&#39;&#39;
    Description:
        Determine if a string is that of a number or not.

    Inputs:
        - `n` = string to be tested

    Outputs:
        - `True` if value is a number (can be converted to float() without an error)
        - `False` otherwise
    &#39;&#39;&#39;
    try:
        float(n)
    except ValueError:
        return False
    return True


def ZZZAAAM_to_nuclide_plain_str(ZZZAAAM,include_Z=False,ZZZAAA=False,delimiter=&#39;-&#39;):
    &#39;&#39;&#39;
    Description:
        Converts a plaintext string of a nuclide to an integer ZZZAAAM = 10000\*Z + 10\*A + M

    Dependencies:
        `Element_Z_to_Sym` (function within the &#34;Hunter&#39;s tools&#34; package)

    Input:
       - `ZZZAAAM` = integer equal to 10000*Z + 10*A + M, where M designates the metastable state (0=ground)
       - `include_Z` = Boolean denoting whether the Z number should be included in the output string (D=`False`)
       - `ZZZAAA` = Boolean denoting whether the input should be interpreted as a ZZZAAA value (1000Z+A) instead (D=`False`)
       - `delimiter` = string which will be used to separate elements of the output string (D=`-`)

    Output:
       - `nuc_str` = string describing the input nuclide formatted as [Z]-[Symbol]-[A][m]
    &#39;&#39;&#39;
    ZZZAAAM = int(ZZZAAAM)
    if ZZZAAA:
        ZZZAAAM = ZZZAAAM*10
    m = ZZZAAAM % 10
    A = (ZZZAAAM % 10000) // 10
    Z = ZZZAAAM // 10000
    symbol = Element_Z_to_Sym(Z)

    m_str = &#39;&#39;
    if m&gt;0:
        m_str = &#39;m&#39; + str(m)

    nuc_str = &#39;&#39;
    if include_Z:
        nuc_str += str(Z) + delimiter
    nuc_str += symbol + delimiter + str(A) + m_str

    return nuc_str

def Element_Z_to_Sym(Z):
    &#39;&#39;&#39;
    Description:
        Returns elemental symbol for a provided atomic number Z

    Inputs:
        - `Z` = atomic number

    Outputs:
        - `sym` = string of elemental symbol for element of atomic number Z
    &#39;&#39;&#39;
    elms = [&#34;n &#34;,\
            &#34;H &#34;,&#34;He&#34;,&#34;Li&#34;,&#34;Be&#34;,&#34;B &#34;,&#34;C &#34;,&#34;N &#34;,&#34;O &#34;,&#34;F &#34;,&#34;Ne&#34;,\
            &#34;Na&#34;,&#34;Mg&#34;,&#34;Al&#34;,&#34;Si&#34;,&#34;P &#34;,&#34;S &#34;,&#34;Cl&#34;,&#34;Ar&#34;,&#34;K &#34;,&#34;Ca&#34;,\
            &#34;Sc&#34;,&#34;Ti&#34;,&#34;V &#34;,&#34;Cr&#34;,&#34;Mn&#34;,&#34;Fe&#34;,&#34;Co&#34;,&#34;Ni&#34;,&#34;Cu&#34;,&#34;Zn&#34;,\
            &#34;Ga&#34;,&#34;Ge&#34;,&#34;As&#34;,&#34;Se&#34;,&#34;Br&#34;,&#34;Kr&#34;,&#34;Rb&#34;,&#34;Sr&#34;,&#34;Y &#34;,&#34;Zr&#34;,\
            &#34;Nb&#34;,&#34;Mo&#34;,&#34;Tc&#34;,&#34;Ru&#34;,&#34;Rh&#34;,&#34;Pd&#34;,&#34;Ag&#34;,&#34;Cd&#34;,&#34;In&#34;,&#34;Sn&#34;,\
            &#34;Sb&#34;,&#34;Te&#34;,&#34;I &#34;,&#34;Xe&#34;,&#34;Cs&#34;,&#34;Ba&#34;,&#34;La&#34;,&#34;Ce&#34;,&#34;Pr&#34;,&#34;Nd&#34;,\
            &#34;Pm&#34;,&#34;Sm&#34;,&#34;Eu&#34;,&#34;Gd&#34;,&#34;Tb&#34;,&#34;Dy&#34;,&#34;Ho&#34;,&#34;Er&#34;,&#34;Tm&#34;,&#34;Yb&#34;,\
            &#34;Lu&#34;,&#34;Hf&#34;,&#34;Ta&#34;,&#34;W &#34;,&#34;Re&#34;,&#34;Os&#34;,&#34;Ir&#34;,&#34;Pt&#34;,&#34;Au&#34;,&#34;Hg&#34;,\
            &#34;Tl&#34;,&#34;Pb&#34;,&#34;Bi&#34;,&#34;Po&#34;,&#34;At&#34;,&#34;Rn&#34;,&#34;Fr&#34;,&#34;Ra&#34;,&#34;Ac&#34;,&#34;Th&#34;,\
            &#34;Pa&#34;,&#34;U &#34;,&#34;Np&#34;,&#34;Pu&#34;,&#34;Am&#34;,&#34;Cm&#34;,&#34;Bk&#34;,&#34;Cf&#34;,&#34;Es&#34;,&#34;Fm&#34;,\
            &#34;Md&#34;,&#34;No&#34;,&#34;Lr&#34;,&#34;Rf&#34;,&#34;Db&#34;,&#34;Sg&#34;,&#34;Bh&#34;,&#34;Hs&#34;,&#34;Mt&#34;,&#34;Ds&#34;,\
            &#34;Rg&#34;,&#34;Cn&#34;,&#34;Nh&#34;,&#34;Fl&#34;,&#34;Mc&#34;,&#34;Lv&#34;,&#34;Ts&#34;,&#34;Og&#34;]
    i = int(Z)
    if i &lt; 0 or i &gt; len(elms):
        print(&#39;Z={} is not valid, please select a number from 0 to 118 (inclusive).&#39;.format(str(Z)))
        return None
    return elms[i].strip()



def split_into_header_and_content(output_file_path):
    &#39;&#39;&#39;
    Description:
        Initial parsing of a PHITS tally output file to isolate its header section (containing metadata) and main
        tally results &#34;content&#34; section for later processing.

    Inputs:
        - `output_file_path` = path to a PHITS tally output file

    Outputs:
        - `header` = list of lines belonging to the tally output&#39;s header section
        - `content` = list of lists of remaining lines after the tally output&#39;s header section; the top level list is
                broken into &#34;blocks&#34; (&#34;newpage:&#34;-separated) which are lists of lines belonging to each block/page.

    &#39;&#39;&#39;
    in_content = False
    header, content = [], [[]]
    with open(output_file_path, mode=&#39;rb&#39;) as f:
        for line in f:
            if b&#39;\x00&#39; in line:
                line = line.replace(b&#34;\x00&#34;, b&#34;&#34;)
            line = line.decode()
            #if &#34;\x00&#34; in line: line = line.replace(&#34;\x00&#34;, &#34;&#34;)
            if &#39;#newpage:&#39; in line:
                in_content = True
                continue
            if in_content:
                if &#39;newpage:&#39; in line:
                    content.append([])
                    continue
                content[-1].append(line.strip())
            else:
                header.append(line.strip())
    # add &#34;footer&#34; to peel off last bit of &#34;content&#34; section?
    return header, content




def extract_data_from_header_line(line):
    &#39;&#39;&#39;
    Description:
        Extract a &#34;key&#34; and its corresponding value from a PHITS tally output header line

    Dependencies:
        - `is_number` (function within the &#34;PHITS tools&#34; package)

    Inputs:
        - `line` = string to be processed

    Outputs:
        - `key` = a string &#34;key&#34; to become a key in the metadata dictionary
        - `value` = corresponding value they &#34;key&#34; is equal to; dtype is string, int, or float
    &#39;&#39;&#39;
    if &#39;#&#39; in line:
        info, trash = line.split(&#39;#&#39;,1)
    else:
        info = line
    key, value = info.split(&#39;=&#39;)
    key = key.strip()
    value = value.strip()
    if is_number(value):
        if &#39;.&#39; in value:
            value = float(value)
        else:
            value = int(value)
    return key, value

def data_row_to_num_list(line):
    &#39;&#39;&#39;
    Description:
        Extract numeric values from line of text from PHITS tally output content section

    Dependencies:
        - `is_number` (function within the &#34;PHITS tools&#34; package)

    Inputs:
        - `line` = string to be processed

    Outputs:
        - `values` = a list of ints and/or floats of numeric values in `line`
    &#39;&#39;&#39;
    value_strs = line.strip().split()
    values = []
    for value in value_strs:
        if is_number(value):
            if &#39;.&#39; in value:
                value = float(value)
            else:
                value = int(value)
        values.append(value)
    return values



def parse_group_string(text):
    &#39;&#39;&#39;
    Description:
        Separate &#34;groups&#34; in a string, wherein a group is a standalone value or a series of values inside parentheses.

    Inputs:
        - `text` = string to be processed

    Outputs:
        - `groups` = a list of strings extracted from `text`
    &#39;&#39;&#39;
    # returns list of items from PHITS-formatted string, e.g. w/ ()
    parts = text.strip().split()
    #print(parts)
    groups = []
    curly_vals = []
    in_brackets_group = False
    in_curly_brace_group = False
    num_group_members = 0
    for i in parts:
        if &#39;(&#39; in i and &#39;)&#39; in i:
            in_brackets_group = False
            groups.append(i)
        elif &#39;(&#39; in i:
            in_brackets_group = True
            groups.append(i)
        elif &#39;)&#39; in i:
            in_brackets_group = False
            num_group_members = 0
            groups[-1] += i
        elif &#39;{&#39; in i:
            in_curly_brace_group = True
            curly_vals = []
        elif &#39;}&#39; in i:
            in_curly_brace_group = False
            curly_int_strs = [str(j) for j in range(int(curly_vals[0]), int(curly_vals[-1])+1)]
            curly_vals = []
            groups += curly_int_strs
        else:
            if in_brackets_group:
                if num_group_members&gt;0: groups[-1] += &#39; &#39;
                groups[-1] += i
                num_group_members += 1
            elif in_curly_brace_group:
                if i != &#39;-&#39;:
                    curly_vals.append(i)
            else:
                groups.append(i)
    #print(groups)
    return groups

def parse_tally_header(tally_header,tally_content):
    &#39;&#39;&#39;
    Description:
        Extracts metadata from PHITS tally output header (and some extra info from its contents section)

    Dependencies:
        - `extract_data_from_header_line` (function within the &#34;PHITS tools&#34; package)
        - `parse_group_string` (function within the &#34;PHITS tools&#34; package)

    Inputs:
        - `tally_header` = list of lines belonging to the tally output&#39;s header section
        - `tally_content` = list of lists of remaining lines after the tally output&#39;s header section; the top level list is
                broken into &#34;blocks&#34; (&#34;newpage:&#34;-separated) which are lists of lines belonging to each block/page.

    Outputs:
        - `meta` = Munch object / dictionary containing tally metadata

    &#39;&#39;&#39;
    nlines = len(tally_header)
    tally_type = tally_header[0].replace(&#39; &#39;,&#39;&#39;)
    meta = Munch({})
    meta.tally_type = tally_type
    # Initialize variables for possible array
    mesh_types = [&#39;e&#39;,&#39;t&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;,&#39;r&#39;,&#39;a&#39;,&#39;l&#39;]
    for m in mesh_types: meta[&#39;n&#39;+m] = None
    meta[&#39;reg&#39;] = None
    meta[&#39;part&#39;] = None
    meta[&#39;npart&#39;] = None
    meta[&#39;nc&#39;] = None
    meta[&#39;samepage&#39;] = &#39;part&#39;
    found_mesh_kinds = []

    reading_axis_data = False
    reading_regions = False
    in_exceptional_mesh_kind = False
    for li, line in enumerate(tally_header):
        #if line[0]==&#39;#&#39;: # commented line
        if &#39;data =&#39; in line: # data section to parse
            reading_axis_data = True
            n_values_to_read = meta[&#39;n&#39;+current_data_mesh_kind] + 1
            remaining_n_values_to_read = n_values_to_read
            data_values = []
            in_exceptional_mesh_kind = False
            #print(&#39;read &#39;,n_values_to_read,current_data_mesh_kind,&#39; values&#39;)
            continue
        elif &#39;=&#39; in line:
            if line[0] == &#39;#&#39;:  # commented line
                key, value = extract_data_from_header_line(line[1:])
            else:
                key, value = extract_data_from_header_line(line)
            if in_exceptional_mesh_kind:
                if key[0]==&#39;e&#39;:
                    key = current_data_mesh_kind + key[1:]
                elif key==&#39;ne&#39;:
                    key = &#39;n&#39; + current_data_mesh_kind
            meta[key] = value

            if &#39;type&#39; in key:
                current_data_mesh_kind = key.replace(&#39;-type&#39;,&#39;&#39;)
                if current_data_mesh_kind == &#39;se&#39;: current_data_mesh_kind = &#39;e&#39;
                current_data_mesh_type = value
                found_mesh_kinds.append(current_data_mesh_kind)
                if current_data_mesh_kind in [&#39;e1&#39;,&#39;e2&#39;]:
                    in_exceptional_mesh_kind = True
                #print(current_data_mesh_kind,current_data_mesh_type)
            if key==&#39;part&#39;:
                part_groups = parse_group_string(str(value))
                kf_groups = parse_group_string(tally_header[li + 1].split(&#39;:&#39;)[1])
                meta[&#39;part_groups&#39;] = part_groups
                meta[&#39;kf_groups&#39;] = kf_groups
                meta[&#39;npart&#39;] = len(part_groups)
                meta[&#39;part_serial_groups&#39;] = [&#39;p&#39;+str(gi+1)+&#39;-group&#39; for gi in range(len(part_groups))]
            if key==&#39;reg&#39;:
                if meta[&#39;tally_type&#39;]==&#39;[T-Cross]&#39;:
                    num_regs = value
                    meta[&#39;num_reg_groups&#39;] = num_regs
                    meta[&#39;reg_groups&#39;] = []
                    # manually read in reg groups
                    li_start = li+2
                    li_stop = li_start + num_regs
                    for lii in range(li_start,li_stop):
                        non, rfrom, rto, area = tally_header[lii].split()
                        meta[&#39;reg_groups&#39;].append(rfrom+&#39; - &#39;+rto)
                else:
                    reg_groups = parse_group_string(str(value))
                    meta[&#39;reg_groups&#39;] = reg_groups
                    meta[&#39;num_reg_groups&#39;] = len(reg_groups)
            if key == &#39;point&#39;:
                num_regs = value
                meta[&#39;point_detectors&#39;] = {&#39;non&#39;:[], &#39;x&#39;:[], &#39;y&#39;:[], &#39;z&#39;:[], &#39;r0&#39;:[]} # [T-Point] points
                li_start = li + 2
                li_stop = li_start + num_regs
                for lii in range(li_start, li_stop):
                    non, tppx, tppy, tppz, tppr0 = tally_header[lii].split()
                    meta[&#39;point_detectors&#39;][&#39;non&#39;].append(non)
                    meta[&#39;point_detectors&#39;][&#39;x&#39;].append(tppx)
                    meta[&#39;point_detectors&#39;][&#39;y&#39;].append(tppy)
                    meta[&#39;point_detectors&#39;][&#39;z&#39;].append(tppz)
                    meta[&#39;point_detectors&#39;][&#39;r0&#39;].append(tppr0)
            if key == &#39;ring&#39;:
                num_regs = value
                meta[&#39;point_detectors&#39;] = {&#39;non&#39;:[], &#39;axis&#39;:[], &#39;ar&#39;:[], &#39;rr&#39;:[], &#39;r0&#39;:[]} # [T-Point] points
                li_start = li + 2
                li_stop = li_start + num_regs
                for lii in range(li_start, li_stop):
                    non, tppx, tppy, tppz, tppr0 = tally_header[lii].split()
                    meta[&#39;point_detectors&#39;][&#39;non&#39;].append(non)
                    meta[&#39;point_detectors&#39;][&#39;axis&#39;].append(tppx)
                    meta[&#39;point_detectors&#39;][&#39;ar&#39;].append(tppy)
                    meta[&#39;point_detectors&#39;][&#39;rr&#39;].append(tppz)
                    meta[&#39;point_detectors&#39;][&#39;r0&#39;].append(tppr0)
        elif reading_axis_data:
            values = line.replace(&#39;#&#39;,&#39;&#39;).strip().split()
            for val in values:
                data_values.append(float(val))
                remaining_n_values_to_read += -1
            if remaining_n_values_to_read &lt;= 0:
                reading_axis_data = False
                data_values = np.array(data_values)
                meta[current_data_mesh_kind+&#39;-mesh_bin_edges&#39;] = data_values
                meta[current_data_mesh_kind+&#39;-mesh_bin_mids&#39;] = 0.5*(data_values[1:]+data_values[:-1])
                #meta[current_data_mesh_kind+&#39;-mesh_bin_mids_log&#39;] = np.sqrt(data_values[1:]*data_values[:-1])
                # generate log-centered bin mids
                bin_mids_log = []
                for i in range(len(data_values)-1):
                    if data_values[i+1]&lt;=0 or data_values[i]&lt;=0: # if one or both edges &lt;= 0
                        if data_values[i+1]&lt;0 and data_values[i]&lt;0: # both values are negative
                            bin_mids_log.append(-1*np.sqrt(data_values[i]*data_values[i+1]))
                        elif data_values[i+1]==0 or data_values[i]==0: # one value is zero
                            # use linear center instead...
                            bin_mids_log.append(0.5*(data_values[i]+data_values[i+1]))
                        elif data_values[i+1]&lt;0 or data_values[i]&lt;0: # bin straddles zero
                            # use linear center instead...
                            bin_mids_log.append(0.5*(data_values[i]+data_values[i+1]))
                        else:
                            print(&#39;unknown binning encountered, skipping generation of log-scale bin mids for &#39;+current_data_mesh_kind+&#39;-mesh&#39;)
                            break
                    else:
                        bin_mids_log.append(np.sqrt(data_values[i]*data_values[i+1]))
                meta[current_data_mesh_kind+&#39;-mesh_bin_mids_log&#39;] = np.array(bin_mids_log)
            continue
        else:
            continue

    meta[&#39;found_mesh_kinds&#39;] = found_mesh_kinds

    if meta[&#39;tally_type&#39;]==&#39;[T-Cross]&#39;:
        if meta[&#39;mesh&#39;]==&#39;xyz&#39;:
            if &#39;enclos&#39; in meta and meta[&#39;enclos&#39;]==1:
                pass # total items remains nx*ny*nz
            else:
                meta[&#39;nz_original&#39;] = meta[&#39;nz&#39;]
                meta[&#39;nz&#39;] += 1 # zmesh surfaces are scored, making array nx*ny*(nz+1)
        elif meta[&#39;mesh&#39;]==&#39;r-z&#39;:
            if &#39;enclos&#39; in meta and meta[&#39;enclos&#39;]==1:
                pass # total items remains nr*nz
            else:
                # Current solution addresses this by expanding the ierr axis
                meta[&#39;nr_original&#39;] = meta[&#39;nr&#39;]
                meta[&#39;nz_original&#39;] = meta[&#39;nz&#39;]
                meta[&#39;nr&#39;] = meta[&#39;nr&#39;] + 1
                meta[&#39;nz&#39;] = meta[&#39;nz&#39;] + 1
                # OLD SOLUTION IMPLEMENTED IS BELOW
                # max total num of pages = nrsurf*nz + nzsurf*nr = (nr+1)*nz + nr*(nz+1) = 2*nr*nz + nr + nz
                # if one radius is 0, this becomes = nr*nz + nr*(nz+1) = 2*nr*nz + nr
                # Solution used here:
                # use ir to iterate nr, use iy to iterate nrsurf, use iz to iterate nz, use ic to iterate nzsurf
                # since only rsurf*z [iy,iz] and r*zsurf [ir,ic] pairs exist, when one pair is being written
                # the other will be [-1,-1], hence the dimensions for the array are increased by an extra 1 to prevent overlap
                #meta[&#39;nr_original&#39;] = meta[&#39;nr&#39;]
                #meta[&#39;nz_original&#39;] = meta[&#39;nz&#39;]
                #meta[&#39;ny_original&#39;] = meta[&#39;ny&#39;]
                ##meta[&#39;nc_original&#39;] = meta[&#39;nc&#39;]
                #meta[&#39;ny&#39;] = meta[&#39;nr&#39;] + 1 + 1
                #meta[&#39;nc&#39;] = meta[&#39;nz&#39;] + 1 + 1
                #meta[&#39;nr&#39;] = meta[&#39;nr&#39;] + 1
                #meta[&#39;nz&#39;] = meta[&#39;nz&#39;] + 1

    if meta[&#39;tally_type&#39;] == &#39;[T-Point]&#39;:
        if &#39;mesh&#39; not in meta:
            if &#39;point&#39; in meta:
                meta[&#39;mesh&#39;] = &#39;point&#39;
                meta[&#39;nreg&#39;] = meta[&#39;point&#39;]
            elif &#39;ring&#39; in meta:
                meta[&#39;mesh&#39;] = &#39;ring&#39;
                meta[&#39;nreg&#39;] = meta[&#39;ring&#39;]


    axes_1D = [&#39;eng&#39;,&#39;reg&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;,&#39;r&#39;,&#39;t&#39;,&#39;cos&#39;,&#39;the&#39;,&#39;mass&#39;,&#39;charge&#39;,&#39;let&#39;,&#39;tet&#39;,&#39;eng1&#39;,&#39;eng2&#39;,&#39;sed&#39;,&#39;rad&#39;,&#39;deg&#39;]
    axes_2D = [&#39;xy&#39;,&#39;yz&#39;,&#39;zx&#39;,&#39;rz&#39;,&#39;chart&#39;,&#39;dchain&#39;,&#39;t-eng&#39;,&#39;eng-t&#39;,&#39;t-e1&#39;,&#39;e1-t&#39;,&#39;t-e2&#39;,&#39;e2-t&#39;,&#39;e12&#39;,&#39;e21&#39;,&#39;xz&#39;,&#39;yx&#39;,&#39;zy&#39;,&#39;zr&#39;]

    axes_ital_1D = [3,   0,  0,  1,  2,  0,  4,    5,    5,     8,       8,    6,    0,     3,     8,    3,    5,    5]
    axes_ital_2D = [ [0,1],[1,2],[2,0],[0,2],[None,None],[None,None],[4,3],[3,4],[4,3],[3,4],[4,8],[8,4],[3,8],[8,3],[0,2],[1,0],[2,1],[2,0]]


    if meta[&#39;axis&#39;] in axes_1D:
        meta[&#39;axis_dimensions&#39;] = 1
        meta[&#39;axis_index_of_tally_array&#39;] = axes_ital_1D[axes_1D.index(meta[&#39;axis&#39;])]
    elif meta[&#39;axis&#39;] in axes_2D:
        meta[&#39;axis_dimensions&#39;] = 2
        meta[&#39;axis_index_of_tally_array&#39;] = axes_ital_2D[axes_2D.index(meta[&#39;axis&#39;])]
    else:
        print(&#34;WARNING: axis value of &#34;,meta[&#39;axis&#39;],&#34; is not in list of known/registered values&#34;)
        meta[&#39;axis_dimensions&#39;] = None
        meta[&#39;axis_index_of_tally_array&#39;] = None




    # Now extract portion of metadata only available from tally content

    if meta[&#39;mesh&#39;] == &#39;reg&#39; or meta[&#39;mesh&#39;] == &#39;tet&#39;:
        num, reg, vol = [], [], []
        if meta[&#39;axis&#39;]==&#39;reg&#39; or meta[&#39;axis&#39;]==&#39;tet&#39;:  # get number of regions and region data from first block of tally content
            outblock = tally_content[0]
            in_reg_list = False
            for line in outblock:
                if &#39;#&#39; in line and &#39; num &#39; in line:
                    cols = line[1:].split()
                    #print(cols)
                    in_reg_list = True
                    continue
                if len(line.split()) == 0 or &#39;{&#39; in line:
                    in_reg_list = False
                if in_reg_list:
                    vals = line.split()
                    if meta[&#39;tally_type&#39;] == &#39;[T-Cross]&#39;:
                        num.append(vals[0])
                        reg.append(vals[0])
                        vol.append(vals[1])
                    else:
                        num.append(vals[0])
                        reg.append(vals[1])
                        vol.append(vals[2])
        else: # scan output for region numbers:
            regcount = 0
            for outblock in tally_content:
                for line in outblock:
                    if &#39;reg =&#39; in line or &#39;reg  =&#39; in line:
                        eq_strs = split_str_of_equalities(line[1:])
                        reg_eq_str = &#39;&#39;
                        for eqsi in eq_strs:
                            if &#39;reg&#39; in eqsi:
                                reg_eq_str = eqsi
                                break
                        regnum = reg_eq_str.split(&#39;=&#39;)[1].strip()
                        #regnum = line.strip().split(&#39;reg =&#39;)[1].strip().replace(&#34;&#39;&#34;,&#39;&#39;)
                        if regnum not in reg:
                            regcount += 1
                            num.append(regcount)
                            reg.append(regnum)
                            vol.append(None)
                        continue
        if meta[&#39;mesh&#39;] == &#39;reg&#39;:
            meta.reg_serial_num = num
            meta.reg_num = reg
            if meta[&#39;tally_type&#39;] == &#39;[T-Cross]&#39;:
                meta.reg_area = vol
            else:
                meta.reg_volume = vol
            meta.nreg = len(reg)
        elif meta[&#39;mesh&#39;] == &#39;tet&#39;:
            meta.tet_serial_num = num
            meta.tet_num = reg
            meta.reg_num = reg
            #meta.tet_volume = vol
            if meta[&#39;tally_type&#39;] == &#39;[T-Cross]&#39;:
                meta.tet_area = vol
            else:
                meta.tet_volume = vol
            meta.ntet = len(reg)

        #if meta[&#39;tally_type&#39;] == &#39;[T-Cross]&#39;:
        #    meta[&#39;reg_groups&#39;] = reg



    elif meta[&#39;mesh&#39;] == &#39;tet&#39;:
        num, reg, vol = [], [], []
        if meta[&#39;axis&#39;] == &#39;tet&#39;:
            pass
        else:
            pass
        print(&#39;mesh=tet has not been tested!&#39;)
        meta.ntet = 0

    axis1_label = &#39;&#39;
    axis2_label = &#39;&#39;
    value_label = &#39;&#39;
    hc_passed = False # passed colorbar definition line
    outblock = tally_content[0]
    for line in outblock:
        if len(line) == 0: continue
        if line[:2] == &#39;x:&#39;:
            axis1_label = line[2:].strip()
        if line[:2] == &#39;y:&#39;:
            if meta.axis_dimensions == 1:
                value_label = line[2:].strip()
                #break
            elif meta.axis_dimensions == 2:
                if hc_passed: # second instance of y:
                    value_label = line[2:].strip()
                    #break
                else: # first instance of y:
                    axis2_label = line[2:].strip()
                    hc_passed = True
        #if line[:3] == &#39;hc:&#39;:
        #    hc_passed = True
        h_line_str = &#39;&#39;
        if line[0] == &#39;h&#39; and (line[1] == &#39;:&#39; or line[2] == &#39;:&#39;):
            if meta[&#39;axis_dimensions&#39;] == 1:
                ndatacol = line.count(&#39;y&#39;)
                if ndatacol != 1:  # multiple columns are present &#34;samepage&#34;
                    # get first string with y
                    col_groups = parse_group_string(line)
                    first_data_col_header = col_groups[3][2:]
                    for m in mesh_types:
                        if first_data_col_header[0] == m:
                            if m == &#39;e&#39;:
                                meta[&#39;samepage&#39;] = &#39;eng&#39;
                            elif m == &#39;r&#39;:
                                if first_data_col_header[:3] == &#39;reg&#39;:
                                    meta[&#39;samepage&#39;] = &#39;reg&#39;
                                else:
                                    meta[&#39;samepage&#39;] = m
                            elif m == &#39;l&#39;:
                                meta[&#39;samepage&#39;] = &#39;let&#39;
                            elif m == &#39;a&#39;:
                                meta[&#39;samepage&#39;] = &#39;the&#39; # or cos
                            else:
                                meta[&#39;samepage&#39;] = m
                    if meta[&#39;samepage&#39;] == &#39;part&#39;:  # still is default value
                        # double check to see if it could be region numbers vs particle names
                        if ndatacol != meta[&#39;npart&#39;]:
                            if ndatacol == meta[&#39;num_reg_groups&#39;]:
                                meta[&#39;samepage&#39;] = &#39;reg&#39;
                            else:
                                print(&#39;&#34;samepage&#34; was not correctly identified; needs to be implemented&#39;)
                    if meta[&#39;samepage&#39;] == &#39;reg&#39;:
                        hcols = parse_group_string(line[3:])
                        num, reg, vol = [], [], []
                        reg_ser_num = 1
                        for hcol in hcols:
                            if hcol[0] == &#39;y&#39;:
                                num.append(reg_ser_num)
                                reg_ser_num += 1
                                reg.append(hcol.split(&#39;)&#39;)[0].replace(&#39;y(reg&#39;,&#39;&#39;))
                                vol.append(None)
                        meta.reg_serial_num = num
                        meta.reg_num = reg
                        meta.reg_volume = vol
                        meta.nreg = len(reg)

            break
    meta.axis1_label = axis1_label
    meta.axis2_label = axis2_label
    meta.value_label = value_label

    # Now do any final overrides for specific tallies / circumstances

    if meta[&#39;tally_type&#39;] == &#39;[T-Deposit2]&#39;:
        meta[&#39;nreg&#39;] = 1
        meta[&#39;reg_serial_num&#39;] = [1]
        meta[&#39;reg_num&#39;] = [&#39;1&#39;]
        meta[&#39;reg_volume&#39;] = [None]
        if meta[&#39;num_reg_groups&#39;] &gt; 1:
            meta[&#39;num_reg_groups&#39;] = 1
            meta[&#39;reg_groups&#39;] = [meta[&#39;reg_groups&#39;][0] + &#39; &#39; + meta[&#39;reg_groups&#39;][1]]

    if meta[&#39;tally_type&#39;] == &#39;[T-Heat]&#39;:
        if &#39;npart&#39; not in meta or meta[&#39;npart&#39;] == None: meta[&#39;npart&#39;] = 1
        if &#39;part_groups&#39; not in meta: meta[&#39;part_groups&#39;] = [&#39;all&#39;]

    return meta

def initialize_tally_array(tally_metadata,include_abs_err=True):
    &#39;&#39;&#39;
    Description:
        Initializes main tally data array in which tally results will be stored when read

    Dependencies:
        - `import numpy as np`

    Inputs:
        - `tally_metadata` = Munch object / dictionary containing tally metadata
        - `include_abs_err` = a Boolean (D=`True`) on whether absolute error will be calculated; the final dimension of `tdata` is
                `3/2` if this value is `True/False`

    Outputs:
        - `tdata` = 10-dimensional NumPy array of zeros of correct size for holding tally results

    &#39;&#39;&#39;
    ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max = 1, 1, 1, 1, 1, 1, 1, 1, 1
    if include_abs_err:
        ierr_max = 3
    else:
        ierr_max = 2
    if tally_metadata[&#39;mesh&#39;] == &#39;reg&#39;:
        ir_max = tally_metadata.nreg
    elif tally_metadata[&#39;mesh&#39;] == &#39;xyz&#39;:
        ir_max = tally_metadata.nx
        iy_max = tally_metadata.ny
        iz_max = tally_metadata.nz
    elif tally_metadata[&#39;mesh&#39;] == &#39;r-z&#39;:
        ir_max = tally_metadata.nr
        iz_max = tally_metadata.nz
        if &#39;ny&#39; in tally_metadata and tally_metadata.ny != None: iy_max = tally_metadata.ny
        if &#39;nc&#39; in tally_metadata and tally_metadata.nc != None: ic_max = tally_metadata.nc
    elif tally_metadata[&#39;mesh&#39;] == &#39;tet&#39;:
        ir_max = tally_metadata.ntet
    elif tally_metadata[&#39;mesh&#39;] == &#39;point&#39; or tally_metadata[&#39;mesh&#39;] == &#39;ring&#39;:
        ir_max = tally_metadata.nreg
    else:
        print(&#39;ERROR! Unknown geometry mesh:&#39;, tally_metadata[&#39;mesh&#39;])
        sys.exit()

    if tally_metadata.na != None: ia_max = tally_metadata.na
    if tally_metadata.nt != None: it_max = tally_metadata.nt
    if tally_metadata.nl != None: il_max = tally_metadata.nl
    if &#39;nc&#39; in tally_metadata and tally_metadata.nc != None: ic_max = tally_metadata.nc
    #if &#39;npart&#39; in tally_metadata and tally_metadata.npart != None: ip_max = tally_metadata.np

    if tally_metadata.ne == None:
        if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Deposit2]&#39;:
            if &#39;ne1&#39; in tally_metadata:
                ie_max = tally_metadata.ne1
            if &#39;ne2&#39; in tally_metadata:
                ic_max = tally_metadata.ne2
        elif &#39;e1&#39; in tally_metadata.axis or &#39;e2&#39; in tally_metadata.axis:  # This should now be redundant?
            if tally_metadata.axis == &#39;e12&#39;:
                ie_max = tally_metadata.ne1
                ic_max = tally_metadata.ne2
            elif tally_metadata.axis == &#39;e21&#39;:
                ie_max = tally_metadata.ne1
                ic_max = tally_metadata.ne2
            elif &#39;e1&#39; in tally_metadata.axis or &#39;eng1&#39; in tally_metadata.axis:
                ie_max = tally_metadata.ne1
                if &#39;ne2&#39; in tally_metadata:
                    ic_max = tally_metadata.ne2
            elif &#39;e2&#39; in tally_metadata.axis or &#39;eng2&#39; in tally_metadata.axis:
                ic_max = tally_metadata.ne2
                if &#39;ne1&#39; in tally_metadata:
                    ie_max = tally_metadata.ne1
            else:
                if &#39;ne1&#39; in tally_metadata:
                    ie_max = tally_metadata.ne1
                if &#39;ne2&#39; in tally_metadata:
                    ic_max = tally_metadata.ne2

    else:
        ie_max = tally_metadata.ne

    ip_max = tally_metadata.npart

    if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Cross]&#39; and tally_metadata.mesh == &#39;r-z&#39;:
        if &#39;enclos&#39; in tally_metadata and tally_metadata[&#39;enclos&#39;] == 1:
            pass
        else: # enclos = 0 case
            ierr_max = 2*ierr_max

    if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Yield]&#39;:
        if tally_metadata.axis == &#39;charge&#39;:
            ic_max = 130
        elif tally_metadata.axis == &#39;mass&#39;:
            ic_max = 320
        elif tally_metadata.axis == &#39;chart&#39;:
            if int(tally_metadata.mxnuclei) == 0:
                ic_max = 10000
            else:
                ic_max = int(tally_metadata.mxnuclei)

    if in_debug_mode:
        dims_str = &#39;tally dims: nr={:g}, ny={:g}, nz={:g}, ne={:g}, nt={:g}, na={:g}, nl={:g}, np={:g}, nc={:g}, nerr={:g}&#39;
        print(dims_str.format(ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max, ierr_max))
    tally_data = np.zeros((ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max, ierr_max))
    return tally_data

def calculate_tally_absolute_errors(tdata):
    &#39;&#39;&#39;
    Description:
        Calculates the absolute uncertainty for every value in the PHITS tally data array

    Inputs:
        - `tdata` = 10-dimensional NumPy array containing read/extracted tally results

    Outputs:
        - `tdata` = updated `tdata` array now with absolute uncertainties in `ierr = 2` index

    &#39;&#39;&#39;

    ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max, ierr_max = np.shape(tdata)
    for ir in range(ir_max):
        for iy in range(iy_max):
            for iz in range(iz_max):
                for ie in range(ie_max):
                    for it in range(it_max):
                        for ia in range(ia_max):
                            for il in range(il_max):
                                for ip in range(ip_max):
                                    for ic in range(ic_max):
                                        tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 2] = \
                                            tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 0] * \
                                            tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 1]
    if ierr_max==6:
        for ir in range(ir_max):
            for iy in range(iy_max):
                for iz in range(iz_max):
                    for ie in range(ie_max):
                        for it in range(it_max):
                            for ia in range(ia_max):
                                for il in range(il_max):
                                    for ip in range(ip_max):
                                        for ic in range(ic_max):
                                            tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 5] = \
                                                tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 3] * \
                                                tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 4]

    return tdata

def split_str_of_equalities(text):
    &#39;&#39;&#39;
    Description:
        Extract relevant regions, indices, etc. from somewhat inconsistently formatted lines in PHITS tally output content section.

    Dependencies:
        - `is_number` (function within the &#34;PHITS tools&#34; package)

    Inputs:
        - `text` = string to be processed

    Outputs:
        - `equalities_str_list` = list of strings of equalities each of the format &#34;key = value&#34;

    &#39;&#39;&#39;
    equalities_str_list = []
    original_text = text
    #if text[0] == &#34;&#39;&#34;: # more loosely formatted text
    #    problem_strs = [&#39;tot DPA&#39;]
    text = text.replace(&#34;&#39;&#34;,&#39;&#39;).replace(&#39;,&#39;,&#39; &#39;).replace(&#39;#&#39;,&#39;&#39;).replace(&#39;=&#39;,&#39; = &#39;)
    text_pieces = text.split()
    #i_equal_sign = [i for i, x in enumerate(text_pieces) if x == &#34;=&#34;]
    is_i_equal_sign = [x==&#39;=&#39; for x in text_pieces]
    #i_is_number = [i for i, x in enumerate(text_pieces) if is_number(x)]
    is_i_number = [is_number(x) for x in text_pieces]
    #num_equalities = len(i_equal_sign)
    #remaining_equalities = num_equalities
    equality_str = &#39;&#39;
    # the only condition enforced is that the last item in each value be numeric or )
    current_equality_contains_equalsign = False
    for i in reversed(range(len(text_pieces))): # easiest to build from right to left
        equality_str = text_pieces[i] + &#39; &#39; + equality_str
        if is_i_equal_sign[i]:
            current_equality_contains_equalsign = True
        elif current_equality_contains_equalsign: # looking to terminate if next item is numeric
            if i==0 or (is_i_number[i-1] or text_pieces[i-1][-1]==&#39;)&#39;): # either final equality completed or next item belongs to next equality
                equalities_str_list.insert(0,equality_str.strip())
                equality_str = &#39;&#39;
                current_equality_contains_equalsign = False
    if &#39;(&#39; in text: # need to break up potential (ia,ib) pairs
        new_eq_str_list = []
        for x in equalities_str_list:
            if &#39;(&#39; in x:
                keys, values = x.split(&#39;=&#39;)
                keys = keys.strip().replace(&#39;(&#39;,&#39;&#39;).replace(&#39;)&#39;,&#39;&#39;).split()
                values = values.strip().replace(&#39;(&#39;,&#39;&#39;).replace(&#39;)&#39;,&#39;&#39;).split()
                for i in range(len(keys)):
                    new_eq_str = keys[i].strip() + &#39; = &#39; + values[i].strip()
                    new_eq_str_list.append(new_eq_str)
            else:
                new_eq_str_list.append(x)
        equalities_str_list = new_eq_str_list
    #print(equalities_str_list)
    return equalities_str_list


def parse_tally_content(tdata,meta,tally_blocks,is_err_in_separate_file,err_mode=False):
    &#39;&#39;&#39;
    Description:
        Parses the PHITS tally output content section and extract its results

    Dependencies:
        - `split_str_of_equalities` (function within the &#34;PHITS tools&#34; package)
        - `parse_group_string` (function within the &#34;PHITS tools&#34; package)
        - `data_row_to_num_list` (function within the &#34;PHITS tools&#34; package)

    Inputs:
        - `tdata` = 10-dimensional NumPy array of zeros of correct size to hold tally output/results
        - `meta` = Munch object / dictionary containing tally metadata
        - `tally_blocks` = blocks of tally output as outputted by the `split_into_header_and_content` function
        - `is_err_in_separate_file` = Boolean denoting whether the tally&#39;s relative errors are located in a separate file
        - `err_mode` = Boolean (D=`False`) used for manually forcing all read values to be regarded as relative uncertainties
                as is necessary when processing dedicated *_err files.

    Outputs:
        - `tdata` = updated `tdata` array containing read/extracted tally results

    &#39;&#39;&#39;
    global ir, iy, iz, ie, it, ia, il, ip, ic, ierr
    global ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max, ierr_max
    ierr = 0
    if is_err_in_separate_file and err_mode:
        ierr = 1

    mesh_kind_chars = [&#39;e&#39;, &#39;t&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;r&#39;, &#39;a&#39;, &#39;l&#39;]
    mesh_kind_iax = [3, 4, 0, 1, 2, 0, 5, 6]
    tdata_ivar_strs = [&#39;ir&#39;, &#39;iy&#39;, &#39;iz&#39;, &#39;ie&#39;, &#39;it&#39;, &#39;ia&#39;, &#39;il&#39;, &#39;ip&#39;, &#39;ic&#39;]
    ir, iy, iz, ie, it, ia, il, ip, ic = 0, 0, 0, 0, 0, 0, 0, 0, 0

    ignored_eq_strs = [&#39;axis&#39;,&#39;axs&#39;,&#39;ar&#39;,&#39;rr&#39;,&#39;m jm&#39;,&#39;Z&#39;,&#39;cmax nmax&#39;]
    replace_eq_strs_dict = {&#39;ang&#39;:&#39;a&#39;}

    ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max, ierr_max = np.shape(tdata)

    axes_1D = [&#39;eng&#39;, &#39;reg&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;r&#39;, &#39;t&#39;, &#39;cos&#39;, &#39;the&#39;, &#39;mass&#39;, &#39;charge&#39;, &#39;let&#39;, &#39;tet&#39;, &#39;eng1&#39;, &#39;eng2&#39;,
               &#39;sed&#39;, &#39;rad&#39;, &#39;deg&#39;]
    axes_2D = [&#39;xy&#39;, &#39;yz&#39;, &#39;zx&#39;, &#39;rz&#39;, &#39;chart&#39;, &#39;dchain&#39;,
               &#39;t-eng&#39;, &#39;eng-t&#39;, &#39;t-e1&#39;, &#39;e1-t&#39;, &#39;t-e2&#39;, &#39;e2-t&#39;,
               &#39;e12&#39;, &#39;e21&#39;, &#39;xz&#39;, &#39;yx&#39;, &#39;zy&#39;, &#39;zr&#39;]

    axes_ital_1D = [3, 0, 0, 1, 2, 0, 4, 5, 5, 8, 8, 6, 0, 3, 8,
                    3, 5, 5]
    axes_ital_2D = [[0, 1], [1, 2], [2, 0], [0, 2], [None, None], [None, None],
                    [4, 3], [3, 4], [4, 3], [3, 4], [4, 8], [8, 4],
                    [3, 8], [8, 3], [0, 2], [1, 0], [2, 1], [2, 0]]

    ierr_mod = 0 # add to ierr for weird [T-Cross], mesh=r-z, enclos=0 case

    banked_uninterpreted_lines = [] # store lines with equalities that may be useful but are skipped owing to being a bit exceptional
    i_metastable = 0
    ZZZAAAM_list = []

    if meta.axis_dimensions==1:
        for bi, block in enumerate(tally_blocks):
            hli, fli = 0,0
            ierr_mod = 0
            hli_found = False
            for li, line in enumerate(block):
                if len(line) == 0: continue
                if line[:2].lower() == &#39;h:&#39;:  # start of data is here
                    hli = li
                    hli_found = True
                    continue
                if hli_found and (line[:12] == &#39;#   sum over&#39; or line[:7] == &#39;#   sum&#39; or line[:5] == &#39;#----&#39; or (len(block[li-1]) == 0 and hli != 0 and li&gt;hli+2) or &#34;&#39;&#34; in line or &#39;{&#39; in line):
                    fli = li
                    if (len(block[li-1]) == 0 and hli != 0 and li&gt;hli+2): fli = li - 1 # triggered by blank line after data
                    #if &#34;&#39;&#34; in line or &#39;{&#39; in line:
                    #    fli = li-1
                    break

            data_header = block[:hli]
            data_table = block[hli:fli]
            data_footer = block[fli:]

            if bi == len(tally_blocks) - 1:
                for li, line in enumerate(data_footer):
                    if line[:37] == &#39;# Information for Restart Calculation&#39;:
                        ffli = li
                        break
                data_footer = data_footer[:ffli]

            # print(data_header)
            #print(data_table)
            # print(data_footer)

            hash_line_already_evaluated = False

            # try to get relevant indices data from header and footer blocks
            for li, line in enumerate(data_header+data_footer):
                if len(line) == 0: continue

                if &#39;=&#39; in line and (line[0] == &#34;&#39;&#34; or (line[0] == &#34;#&#34; and (&#39;no.&#39; in line or &#39;i&#39; in line or &#39;reg&#39; in line or &#39;part&#39; in line))):
                    if line[0] == &#34;#&#34;:
                        hash_line_already_evaluated = True
                    elif line[0] == &#34;&#39;&#34; and hash_line_already_evaluated:
                        if meta[&#39;samepage&#39;] == &#39;part&#39;:
                            continue  # &#39;-starting lines tend to have more problematic formatting, best skipped if possible
                        elif meta[&#39;npart&#39;] == 1:
                            continue  # can still skip if only one particle group tallied
                        else:
                            pass  # but this needs to be parsed if not using samepage = part and npart &gt; 1
                    parts = split_str_of_equalities(line)
                    #print(line)
                    for part in parts:
                        mesh_char = part.split(&#39;=&#39;)[0].strip().replace(&#39;i&#39;,&#39;&#39;)
                        #print(mesh_char)
                        if mesh_char == &#39;no.&#39;:
                            if &#39;***&#39; in part:
                                break # this is a bugged line
                            continue
                        elif mesh_char == &#39;part.&#39; or mesh_char == &#39;partcle&#39; or mesh_char == &#39;part&#39;:
                            part_grp_name = part.split(&#39;=&#39;)[1].strip()
                            if part_grp_name in meta.part_groups:
                                ip = (meta.part_groups).index(part_grp_name)
                            elif part_grp_name in meta.part_serial_groups:
                                ip = (meta.part_serial_groups).index(part_grp_name)
                            else:
                                print(&#39;ERROR! Particle &#34;&#39;,part_grp_name,&#39;&#34; could not be identified.&#39;)
                                sys.exit()
                        elif mesh_char == &#39;reg&#39;:
                            regnum = part.split(&#39;=&#39;)[1].strip()
                            ir = (meta.reg_num).index(regnum)
                        elif mesh_char == &#39;pont&#39; or mesh_char == &#39;rng&#39;: # [T-Point]
                            value_str = part.split(&#39;=&#39;)[1].strip()
                            ir = int(value_str) - 1
                        elif mesh_char == &#39;e1&#39;: # [T-Deposit2]
                            value_str = part.split(&#39;=&#39;)[1].strip()
                            ie = int(value_str) - 1
                        elif mesh_char == &#39;e2&#39;: # [T-Deposit2]
                            value_str = part.split(&#39;=&#39;)[1].strip()
                            ic = int(value_str) - 1
                        elif mesh_char in mesh_kind_chars or mesh_char in replace_eq_strs_dict:
                            if mesh_char in replace_eq_strs_dict:
                                mesh_char = replace_eq_strs_dict[mesh_char]
                            if &#39;i&#39;+mesh_char not in part: continue # only looking for indices for meshes, not values
                            imesh = mesh_kind_chars.index(mesh_char)
                            itdata_axis = mesh_kind_iax[imesh]
                            tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                            value_str = part.split(&#39;=&#39;)[1].strip()
                            if &#39; - &#39; in value_str:
                                vals = value_str.split(&#39;-&#39;)
                                if int(vals[0]) == int(vals[1]):
                                    value_str = vals[0]
                                else:  # samepage axis
                                    value_str = vals[0]  # this will be overwritten later
                            value = str(int(value_str)-1)
                            exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                        elif mesh_char in ignored_eq_strs:
                            continue
                        elif meta[&#39;tally_type&#39;]==&#39;[T-Cross]&#39;:
                            if meta[&#39;mesh&#39;] == &#39;xyz&#39; and mesh_char==&#39;z surf&#39;:
                                #imesh = mesh_kind_chars.index(&#39;z&#39;)
                                itdata_axis = 2 #mesh_kind_iax[imesh]
                                tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                                value_str = part.split(&#39;=&#39;)[1].strip()
                                value = str(int(value_str) - 1)
                                exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                            elif meta[&#39;mesh&#39;] == &#39;r-z&#39;:
                                if mesh_char==&#39;r surf&#39;:
                                    itdata_axis = 0  # mesh_kind_iax[imesh]
                                    #itdata_axis = 1  # set to iy
                                    ierr_mod = int(ierr_max/2)
                                    #ir, ic = -1, -1
                                    # imesh = mesh_kind_chars.index(&#39;y&#39;)
                                elif mesh_char == &#39;z surf&#39;:
                                    itdata_axis = 2  # mesh_kind_iax[imesh]
                                    #itdata_axis = 8  # set to ic
                                    ierr_mod = 0
                                    #iy, iz = -1, -1
                                    # imesh = mesh_kind_chars.index(&#39;c&#39;)
                                else:
                                    print(&#39;ERROR! Unregistered potential index [&#39;, part.split(&#39;=&#39;)[0].strip(),&#39;] found&#39;)
                                    sys.exit()
                                tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                                value_str = part.split(&#39;=&#39;)[1].strip()
                                if &#39; - &#39; in value_str:
                                    vals = value_str.split(&#39;-&#39;)
                                    if int(vals[0]) == int(vals[1]):
                                        value_str = vals[0]
                                    else: # samepage axis
                                        value_str = vals[0] # this will be overwritten later
                                value = str(int(value_str) - 1)
                                exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                            else:
                                print(&#39;ERROR! Unregistered potential index [&#39;, part.split(&#39;=&#39;)[0].strip(), &#39;] found&#39;)
                                sys.exit()
                        elif meta[&#39;tally_type&#39;] == &#39;[T-Heat]&#39;:
                            banked_uninterpreted_lines.append(line)
                        else:
                            print(&#39;ERROR! Unregistered potential index [&#39;,part.split(&#39;=&#39;)[0].strip(),&#39;] found&#39;)
                            sys.exit()


            # extract data from table
            # determine meaning of table rows
            row_ivar = tdata_ivar_strs[meta.axis_index_of_tally_array]
            # determine meaning of table columns
            hcols = parse_group_string(data_table[0][3:])
            col_names_line_str = data_table[1][1:]
            icol_mod = 0 # account for weirdness in column presence/absence
            if &#39;r surface position&#39; in col_names_line_str:
                icol_mod = -1
                ierr_mod = int(ierr_max / 2)
            is_col_data = np.full(len(hcols),False)
            data_col_indices = []
            is_col_err = np.full(len(hcols),False)
            err_col_indices = []
            for iii in range(len(hcols)):
                if hcols[iii][0] == &#39;y&#39;:
                    is_col_data[iii+icol_mod] = True
                    is_col_err[iii+1+icol_mod] = True
                    data_col_indices.append(iii+icol_mod)
                    err_col_indices.append(iii+1+icol_mod)
            #print(is_col_data)
            #print(is_col_err)
            cols = data_table[1][1:].strip().split()
            ncols = len(cols)
            ndata_cols = np.sum(is_col_data) # number of data values per row
            # determine what variable this corresponds to, should be val of samepage
            # by default, this is usually particles (samepage = part by default)
            if meta.samepage == &#39;part&#39;:
                if meta.npart != ndata_cols:
                    print(&#39;ERROR! samepage number of particle types (&#39;,meta.npart,&#39;) not equal to number of data columns y(part) = &#39;,ndata_cols)
                    sys.exit()
                data_ivar = &#39;ip&#39;
                data_ivar_indices = [j for j in range(ndata_cols)]
            else: # figure out what axis samepage is on
                if meta.samepage not in axes_1D:
                    print(&#39;ERROR! samepage parameter (&#39;,meta.samepage,&#39;) must be &#34;part&#34; or one of valid options for &#34;axis&#34; parameter&#39;)
                    sys.exit()
                data_ivar = tdata_ivar_strs[axes_ital_1D[axes_1D.index(meta.samepage)]]
                if ndata_cols != eval(data_ivar+&#39;_max&#39;):
                    if meta[&#39;tally_type&#39;]==&#39;[T-Cross]&#39; and ndata_cols+1 == eval(data_ivar+&#39;_max&#39;):
                        # This is fine; for T-Cross, ndata cols can be one less than max length...
                        pass
                    elif meta[&#39;tally_type&#39;]==&#39;[T-Cross]&#39; and data_ivar == &#39;ir&#39; and ndata_cols+2 == eval(data_ivar+&#39;_max&#39;):
                        # This is fine; for T-Cross, ndata cols for radius can be two less than max length if rmin=0...
                        pass
                    else:
                        print(&#39;ERROR! number of data columns (&#39;,ndata_cols,&#39;) not equal to tally array dimension for &#39;,data_ivar,&#39;, &#39;,str(eval(data_ivar+&#39;_max&#39;)))
                        sys.exit()
                data_ivar_indices = [j for j in range(ndata_cols)]
            #print(cols)
            #print(ndata_cols)
            for li, line in enumerate(data_table[2:]):
                if len(line)==0: continue
                #print(line)
                rowi = li
                exec(row_ivar + &#39;=&#39; + str(rowi),globals())
                #print(row_ivar + &#39;=&#39; + str(rowi))
                values = data_row_to_num_list(line)
                dcoli = 0
                ecoli = 0
                for vi, value in enumerate(values):
                    if is_col_data[vi]:
                        exec(data_ivar + &#39;=&#39; + str(dcoli),globals())
                        #print(data_ivar + &#39;=&#39; + str(dcoli))
                        tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 0+ierr_mod] = value
                        dcoli += 1
                    if is_col_err[vi]:
                        exec(data_ivar + &#39;=&#39; + str(ecoli),globals())
                        #print(data_ivar + &#39;=&#39; + str(ecoli))
                        tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 1+ierr_mod] = value
                        ecoli += 1





    elif meta.axis_dimensions==2:
        for bi, block in enumerate(tally_blocks):
            hli, bli = 0 , 0
            data_keyword_found = False
            for li, line in enumerate(block):
                if meta[&#39;2D-type&#39;] in [1, 2, 3, 6, 7]:
                    if len(line) == 0: continue
                    if line[:3].lower() in [&#39;hc:&#39;, &#39;h2:&#39;, &#39;hd:&#39;]:  # start of data is here
                        hli = li
                    if line[:12] == &#39;#-----------&#39;:
                        fli = li
                        #if bi != len(tally_blocks) - 1:
                        break
                elif meta[&#39;2D-type&#39;] == 4:
                    if line == &#39;&#39; and hli != 0:
                        fli = li
                        #if bi != len(tally_blocks) - 1:
                        break
                    elif line == &#39;&#39;:  # start of data is here
                        hli = li
                elif meta[&#39;2D-type&#39;] == 5:
                    if &#39;data&#39; in line:
                        hli = li + 3
                    if line == &#39;&#39; and hli != 0 and li&gt;hli+2:
                        fli = li
                        #if bi != len(tally_blocks) - 1:
                        break

            data_header = block[:hli]
            data_table = block[hli:fli]
            data_footer = block[fli:]

            #print(data_header)
            #print(data_table)
            #print(data_footer)

            hash_line_already_evaluated = False

            if bi == len(tally_blocks) - 1:
                for li, line in enumerate(data_footer):
                    if line[:37] == &#39;# Information for Restart Calculation&#39;:
                        ffli = li
                        break
                data_footer = data_footer[:ffli]

            # try to get relevant indices data from header block
            for li, line in enumerate(data_header+data_footer): # +data_footer
                if len(line) == 0: continue
                #if &#39;reg =&#39; in line:
                #    regnum = line.strip().split(&#39;reg =&#39;)[1].strip()
                #    ir = (meta.reg_num).index(regnum)
                #    # print(ir)
                if &#39;=&#39; in line and (line[0] == &#34;&#39;&#34; or (line[0] == &#34;#&#34; and (&#39;no.&#39; in line or &#39;i&#39; in line or &#39;reg&#39; in line or &#39;part&#39; in line))):
                    if line[0] == &#34;#&#34;:
                        hash_line_already_evaluated = True
                    elif line[0] == &#34;&#39;&#34; and hash_line_already_evaluated:
                        if meta[&#39;samepage&#39;] == &#39;part&#39;:
                            continue # &#39;-starting lines tend to have more problematic formatting, best skipped if possible
                        elif meta[&#39;npart&#39;] == 1:
                            continue # can still skip if only one particle group tallied
                        else:
                            pass # but this needs to be parsed if not using samepage = part and npart &gt; 1
                    parts = split_str_of_equalities(line)
                    for part in parts:
                        mesh_char = part.split(&#39;=&#39;)[0].strip().replace(&#39;i&#39;, &#39;&#39;)
                        #print(mesh_char)
                        if mesh_char == &#39;no.&#39;:
                            continue
                        elif mesh_char == &#39;part.&#39; or mesh_char == &#39;partcle&#39;:
                            part_grp_name = part.split(&#39;=&#39;)[1].strip()
                            ip = (meta.part_groups).index(part_grp_name)
                        elif mesh_char == &#39;reg&#39;: # and meta[&#39;samepage&#39;] != &#39;reg&#39;:
                            regnum = part.split(&#39;=&#39;)[1].strip()
                            ir = (meta.reg_num).index(regnum)
                        elif mesh_char == &#39;e1&#39;: # [T-Deposit2]
                            value_str = part.split(&#39;=&#39;)[1].strip()
                            ie = int(value_str) - 1
                        elif mesh_char == &#39;e2&#39;: # [T-Deposit2]
                            value_str = part.split(&#39;=&#39;)[1].strip()
                            ic = int(value_str) - 1
                        elif mesh_char in mesh_kind_chars or mesh_char in replace_eq_strs_dict:
                            if mesh_char in replace_eq_strs_dict:
                                mesh_char = replace_eq_strs_dict[mesh_char]
                            if &#39;i&#39;+mesh_char not in part: continue # only looking for indices for meshes, not values
                            imesh = mesh_kind_chars.index(mesh_char)
                            itdata_axis = mesh_kind_iax[imesh]
                            tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                            value = str(int(part.split(&#39;=&#39;)[1].strip()) - 1)
                            if mesh_char == &#39;l&#39; and meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39; and meta[&#39;axis&#39;] == &#39;chart&#39;:
                                i_metastable = int(value) + 1
                                il = 0
                            else:
                                exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                        elif mesh_char in ignored_eq_strs:
                            continue
                        elif meta[&#39;tally_type&#39;]==&#39;[T-Cross]&#39;:
                            ierr_mod = 0
                            if meta[&#39;mesh&#39;] == &#39;xyz&#39; and mesh_char==&#39;z surf&#39;:
                                #imesh = mesh_kind_chars.index(&#39;z&#39;)
                                itdata_axis = 2 #mesh_kind_iax[imesh]
                                tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                                value = str(int(part.split(&#39;=&#39;)[1].strip()) - 1)
                                exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                            elif meta[&#39;mesh&#39;] == &#39;r-z&#39;:
                                if mesh_char==&#39;r surf&#39;:
                                    # imesh = mesh_kind_chars.index(&#39;y&#39;)
                                    itdata_axis = 0 #1  # mesh_kind_iax[imesh]
                                    tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                                    value = str(int(part.split(&#39;=&#39;)[1].strip()) - 1)
                                    exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                                    #ir, ic = -1, -1
                                    ierr_mod = int(ierr_max / 2)
                                elif mesh_char==&#39;z surf&#39;:
                                    # imesh = mesh_kind_chars.index(&#39;c&#39;)
                                    itdata_axis = 2 #8  # mesh_kind_iax[imesh]
                                    tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                                    value = str(int(part.split(&#39;=&#39;)[1].strip()) - 1)
                                    exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                                    iy, iz = -1, -1
                                    ierr_mod = 0
                                else:
                                    print(&#39;ERROR! Unregistered potential index [&#39;, part.split(&#39;=&#39;)[0].strip(),&#39;] found&#39;)
                                    sys.exit()
                            else:
                                print(&#39;ERROR! Unregistered potential index [&#39;, part.split(&#39;=&#39;)[0].strip(), &#39;] found&#39;)
                                sys.exit()
                        else:
                            print(&#39;ERROR! Unregistered potential index [&#39;,part.split(&#39;=&#39;)[0].strip(),&#39;] found&#39;)
                            sys.exit()


            # Now read data_table, with formatting dependent on 2D-type, and can be inferred from last line of header
            axis1_ivar = meta.axis_index_of_tally_array[0]
            axis2_ivar = meta.axis_index_of_tally_array[1]
            if meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39; and meta[&#39;axis&#39;] == &#39;chart&#39;: # this setting does not respect 2D-type and uses its own formatting
                data_write_format_str = data_table[0][3:]
                Z_y_segment = data_write_format_str.split(&#39;;&#39;)[0]
                N_x_segment = data_write_format_str.split(&#39;;&#39;)[1]
                Z_y_vals = Z_y_segment.replace(&#39;=&#39;,&#39;&#39;).replace(&#39;to&#39;,&#39;&#39;).replace(&#39;by&#39;,&#39;&#39;).replace(&#39;y&#39;,&#39;&#39;).strip().split()
                N_x_vals = N_x_segment.replace(&#39;=&#39;,&#39;&#39;).replace(&#39;to&#39;,&#39;&#39;).replace(&#39;by&#39;,&#39;&#39;).replace(&#39;x&#39;,&#39;&#39;).strip().split()
                Z_y_max, Z_y_min, Z_y_increment = int(Z_y_vals[0]), int(Z_y_vals[1]), int(Z_y_vals[2])
                N_x_max, N_x_min, N_x_increment = int(N_x_vals[1]), int(N_x_vals[0]), int(N_x_vals[2])
                #print(Z_y_max, Z_y_min, Z_y_increment, N_x_max, N_x_min, N_x_increment )
            elif meta[&#39;2D-type&#39;] != 4:
                data_write_format_str = data_header[-2][1:]
                if &#39;data&#39; not in data_write_format_str:
                    for line in data_header[::-1]:
                        if &#39;data&#39; in line:
                            data_write_format_str = line[1:]
                            break
                #print(data_write_format_str)
                for dsi in data_write_format_str.split():
                    if &#39;data&#39; in dsi:
                        data_index_str = dsi
                        ax_vars = data_index_str.replace(&#39;data&#39;,&#39;&#39;).replace(&#39;(&#39;,&#39;&#39;).replace(&#39;)&#39;,&#39;&#39;)
                        #print(data_index_str)
                        #print(ax_vars)
                        ax1_ivar, ax2_ivar = ax_vars.split(&#39;,&#39;)[:2]
                        ax1_ivar = &#39;i&#39; + ax1_ivar
                        ax2_ivar = &#39;i&#39; + ax2_ivar
                #print(data_write_format_str)
            else:  # 2D-type = 4
                cols = data_table[1][1:].split()
                ax1_ivar, ax2_ivar = cols[0], cols[1]
                ax1_ivar = &#39;i&#39; + ax1_ivar
                ax2_ivar = &#39;i&#39; + ax2_ivar

            # manually fix [T-Deposit2] axes
            if meta[&#39;tally_type&#39;] == &#39;[T-Deposit2]&#39;:
                if meta[&#39;axis&#39;] == &#39;e12&#39;:
                    ax1_ivar, ax2_ivar = &#39;ie&#39;, &#39;ic&#39;
                elif meta[&#39;axis&#39;] == &#39;e21&#39;:
                    ax1_ivar, ax2_ivar = &#39;ic&#39;, &#39;ie&#39;
                elif meta[&#39;axis&#39;] == &#39;t-e1&#39;:
                    ax1_ivar, ax2_ivar = &#39;it&#39;, &#39;ie&#39;
                elif meta[&#39;axis&#39;] == &#39;t-e2&#39;:
                    ax1_ivar, ax2_ivar = &#39;it&#39;, &#39;ic&#39;
                elif meta[&#39;axis&#39;] == &#39;e1-t&#39;:
                    ax1_ivar, ax2_ivar = &#39;ie&#39;, &#39;it&#39;
                elif meta[&#39;axis&#39;] == &#39;e2-t&#39;:
                    ax1_ivar, ax2_ivar = &#39;ic&#39;, &#39;it&#39;

            if meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39; and meta[&#39;axis&#39;] == &#39;chart&#39;:
                remaining_ndata_to_read = (Z_y_max - Z_y_min + 1) * (N_x_max - N_x_min + 1)
            else:
                # check if this is one of the backwards instances
                expected_ax1_ivar = tdata_ivar_strs[axis1_ivar]
                expected_ax2_ivar = tdata_ivar_strs[axis2_ivar]
                if meta.mesh==&#39;xyz&#39;:
                    if expected_ax1_ivar == &#39;ir&#39;: expected_ax1_ivar = &#39;ix&#39;
                    if expected_ax2_ivar == &#39;ir&#39;: expected_ax1_ivar = &#39;ix&#39;
                if ax1_ivar==expected_ax1_ivar and ax2_ivar==expected_ax2_ivar:
                    pass # all is correct as is
                elif ax2_ivar == expected_ax1_ivar and ax1_ivar == expected_ax2_ivar:
                    axis1_ivar_temp = axis1_ivar
                    axis1_ivar = axis2_ivar
                    axis2_ivar = axis1_ivar_temp
                    #axis1_ivar = tdata_ivar_strs.index(ax1_ivar)
                    #axis2_ivar = tdata_ivar_strs.index(ax2_ivar)
                    #print(&#39;backwards!&#39;)
                else:
                    print(&#39;ERROR! Unknown axes (&#39;,ax1_ivar,ax2_ivar,&#39;) encountered that did not match expected axes (&#39;,
                          tdata_ivar_strs[meta.axis_index_of_tally_array[0]],tdata_ivar_strs[meta.axis_index_of_tally_array[1]],&#39;)&#39;)
                    sys.exit()

                axis1_ivar_str = tdata_ivar_strs[axis1_ivar]
                axis2_ivar_str = tdata_ivar_strs[axis2_ivar]
                axis1_size = np.shape(tdata)[axis1_ivar]
                axis2_size = np.shape(tdata)[axis2_ivar]
                ndata_to_read = axis1_size*axis2_size
                #print(axis1_ivar_str,axis2_ivar_str)
                #print(axis1_size,axis2_size,ndata_to_read)
                remaining_ndata_to_read = ndata_to_read
                iax1 = 0
                iax2 = axis2_size - 1

            if meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39; and meta[&#39;axis&#39;] == &#39;chart&#39;:
                #Z_y_max, Z_y_min, Z_y_increment # big, 1, -1
                #N_x_max, N_x_min, N_x_increment # big, 1, 1
                current_Z = Z_y_max
                current_N = N_x_min - N_x_increment
                ic = 0
                for line in data_table[1:]:
                    values = data_row_to_num_list(line)
                    for value in values:
                        remaining_ndata_to_read += -1
                        current_N += N_x_increment
                        if current_N &gt; N_x_max:
                            current_N = N_x_min
                            current_Z += Z_y_increment
                        #print(&#39;Z=&#39;,current_Z,&#39;, N=&#39;,current_N)

                        if value != 0:
                            ZZZAAAM = 10000*current_Z + 10*(current_Z+current_N) + i_metastable
                            if ZZZAAAM not in ZZZAAAM_list:
                                ic = len(ZZZAAAM_list)
                                ZZZAAAM_list.append(ZZZAAAM)
                            else:
                                ic = ZZZAAAM_list.index(ZZZAAAM)
                            #print(ic, i_metastable)
                            #print(ic,value)
                            tdata[ir, iy, iz, ie, it, ia, il, ip, ic, ierr + ierr_mod] = value

                        if remaining_ndata_to_read &lt;= 0:
                            break







            elif meta[&#39;2D-type&#39;] in [1,2,3,6,7]:
                for line in data_table[1:]:
                    values = data_row_to_num_list(line)
                    #print(line)
                    for value in values:
                        exec(axis1_ivar_str + &#39; = &#39; + str(iax1), globals())
                        exec(axis2_ivar_str + &#39; = &#39; + str(iax2), globals())
                        #print(ir, iy, iz, ie, it, ia, il, ip, ic, ierr, &#39;\t&#39;, value)
                        tdata[ir, iy, iz, ie, it, ia, il, ip, ic, ierr + ierr_mod] = value
                        remaining_ndata_to_read += -1
                        #print(iax1, iax2)
                        iax1 += 1
                        if iax1 == axis1_size:
                            iax1 = 0
                            iax2 += -1
                    if remaining_ndata_to_read &lt;= 0:
                        break

            elif meta[&#39;2D-type&#39;] == 4:
                iax2 = 0
                for line in data_table[2:]:
                    values = data_row_to_num_list(line)
                    value = values[2]
                    value_err = values[3]
                    exec(axis1_ivar_str + &#39; = &#39; + str(iax1), globals())
                    exec(axis2_ivar_str + &#39; = &#39; + str(iax2), globals())
                    tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 0 + ierr_mod] = value
                    tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 1 + ierr_mod] = value_err
                    # print(ir, iy, iz, ie, it, ia, il, ip, ic, ierr,&#39;\t&#39;,value)
                    remaining_ndata_to_read += -1
                    # print(iax1, iax2)
                    iax1 += 1
                    if iax1 == axis1_size:
                        iax1 = 0
                        iax2 += 1

                    if remaining_ndata_to_read &lt;= 0:
                        break

            elif meta[&#39;2D-type&#39;] == 5:
                for line in data_table[2:]:
                    values = data_row_to_num_list(line)
                    #print(line)
                    for vi, value in enumerate(values):
                        if vi==0: continue # header column
                        exec(axis1_ivar_str + &#39; = &#39; + str(iax1), globals())
                        exec(axis2_ivar_str + &#39; = &#39; + str(iax2), globals())
                        #print(ir, iy, iz, ie, it, ia, il, ip, ic, ierr, &#39;\t&#39;, value)
                        tdata[ir, iy, iz, ie, it, ia, il, ip, ic, ierr + ierr_mod] = value
                        remaining_ndata_to_read += -1
                        # print(iax1, iax2)
                        iax1 += 1
                        if iax1 == axis1_size:
                            iax1 = 0
                            iax2 += -1
                    if remaining_ndata_to_read &lt;= 0:
                        break

            else:
                print(&#39;ERROR! unsupported 2D-type of &#39;,meta[&#39;2D-type&#39;],&#39; provided; legal values are [1,2,3,4,5,6,7]&#39;)
                sys.exit()

    else:
        print(meta.axis_dimensions,&#39;axis dimensions is unknown, ERROR!&#39;)
        sys.exit()

    if len(banked_uninterpreted_lines) != 0:
        print(&#39;The following potentially useful output lines were found but not stored anywhere:&#39;)
        for line in banked_uninterpreted_lines:
            print(&#39;\t&#39;+line)

    return_updated_metadata_too = False
    if meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39;:
        return_updated_metadata_too = True
        if meta[&#39;axis&#39;] == &#39;chart&#39;:
            meta[&#39;nuclide_ZZZAAAM_list&#39;] = ZZZAAAM_list
            meta[&#39;nuclide_isomer_list&#39;] = [ZZZAAAM_to_nuclide_plain_str(i) for i in ZZZAAAM_list]
            nc_max = len(ZZZAAAM_list) #+ 1
            meta[&#39;nc&#39;] = nc_max
            tdata = tdata[:,:,:,:,:,:,:,:,:nc_max,:]
        elif meta[&#39;axis&#39;] == &#39;charge&#39; or meta[&#39;axis&#39;] == &#39;mass&#39;:
            ic_axis_tdata_sum = tdata.sum(axis=(0,1,2,3,4,5,6,7,9))
            nc_max = np.max(np.nonzero(ic_axis_tdata_sum)) + 1
            meta[&#39;nc&#39;] = nc_max
            tdata = tdata[:, :, :, :, :, :, :, :, :nc_max, :]

    if return_updated_metadata_too:
        return tdata, meta
    else:
        return tdata

def build_tally_Pandas_dataframe(tdata,meta):
    &#39;&#39;&#39;
    Description:
        Calculates the absolute uncertainty for every value in the PHITS tally data array

    Dependencies:
        - `import pandas as pd`

    Inputs:
        - `tdata` = 10-dimensional NumPy array containing read/extracted tally results
        - `meta` = Munch object / dictionary containing tally metadata

    Outputs:
        - `tally_df` = Pandas dataframe containing the entire contents of the `tdata` array;
                note that tally_df.attrs returns values which are the same for all rows

    &#39;&#39;&#39;
    import pandas as pd
    ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max, ierr_max = np.shape(tdata)
    num_df_rows = ir_max * iy_max * iz_max * ie_max * it_max * ia_max * il_max * ip_max * ic_max
    # determine what columns to include, based on what info was specified vs left at default values
    col_names_list = []

    in_irregular_TCross_rz_mesh = False
    in_irregular_TCross_xyz_mesh = False
    ierr_mod = 0
    if meta[&#39;tally_type&#39;] == &#39;[T-Cross]&#39; and (meta.mesh == &#39;xyz&#39; or meta.mesh == &#39;r-z&#39;):
        if &#39;enclos&#39; in meta and meta[&#39;enclos&#39;] == 1:
            pass
        else:
            if meta.mesh == &#39;r-z&#39;:
                in_irregular_TCross_rz_mesh = True
                min_r_is_zero = False
                if meta[&#39;r-mesh_bin_edges&#39;][0]==0:
                    min_r_is_zero = True
                ierr_mod = int(ierr_max / 2)
            else:
                in_irregular_TCross_xyz_mesh = True


    # region columns
    if meta.mesh == &#39;reg&#39;:
        reg_cols = [&#39;ir&#39;,&#39;reg&#39;,&#39;reg#&#39;] # use meta.reg_groups and meta.reg_num
    elif meta.mesh == &#39;xyz&#39;:
        if in_irregular_TCross_xyz_mesh:
            reg_cols = [&#39;ix&#39;, &#39;iy&#39;, &#39;iz&#39;, &#39;x_mid&#39;, &#39;y_mid&#39;, &#39;z_surf&#39;]
        else:
            reg_cols = [&#39;ix&#39;,&#39;iy&#39;,&#39;iz&#39;,&#39;x_mid&#39;,&#39;y_mid&#39;,&#39;z_mid&#39;]
    elif meta.mesh == &#39;r-z&#39;:
        if in_irregular_TCross_rz_mesh:
            #reg_cols = [&#39;ir&#39;, &#39;ic&#39;, &#39;r_mid&#39;, &#39;z_surf&#39;, &#39;iy&#39;, &#39;iz&#39;, &#39;r_surf&#39;, &#39;z_mid&#39;]
            reg_cols = [&#39;ir&#39;, &#39;iz&#39;, &#39;r_mid&#39;, &#39;z_surf&#39;, &#39;r_surf&#39;, &#39;z_mid&#39;]
        else:
            reg_cols = [&#39;ir&#39;,&#39;iz&#39;,&#39;r_mid&#39;,&#39;z_mid&#39;]
    elif meta.mesh == &#39;tet&#39;:
        reg_cols = [&#39;ir&#39;,&#39;tet&#39;] #,&#39;tet#&#39;]
    elif meta.mesh == &#39;point&#39;:
        reg_cols = [&#39;ir&#39;,&#39;point#&#39;]
    elif meta.mesh == &#39;ring&#39;:
        reg_cols = [&#39;ir&#39;,&#39;ring#&#39;]
    col_names_list += reg_cols



    # Determine what other columns will be present
    ecols, tcols, acols, lcols, pcols, ccols = False, False, False, False, False, False
    single_specified_bin_axes = [] # log axes which are provided by user but only contain 1 bin
    single_bin_ranges_or_values = []
    if meta.ne != None:
        if meta.ne==1:
            single_specified_bin_axes.append(&#39;e&#39;)
            single_bin_ranges_or_values.append([&#39;Energy&#39;,meta[&#39;e-mesh_bin_edges&#39;]])
        else:
            ecols = True
            ecol_names_list = [&#39;ie&#39;,&#39;e_mid&#39;]
            col_names_list += ecol_names_list
    else:
        single_bin_ranges_or_values.append([&#39;Energy&#39;,&#39;default/all&#39;])
    if meta.nt != None:
        if meta.nt==1:
            single_specified_bin_axes.append(&#39;t&#39;)
            single_bin_ranges_or_values.append([&#39;Time&#39;,meta[&#39;t-mesh_bin_edges&#39;]])
        else:
            tcols = True
            tcol_names_list = [&#39;it&#39;, &#39;t_mid&#39;]
            col_names_list += tcol_names_list
    else:
        single_bin_ranges_or_values.append([&#39;Time&#39;,&#39;default/all&#39;])
    if meta.na != None:
        if meta.na==1:
            single_specified_bin_axes.append(&#39;a&#39;)
            single_bin_ranges_or_values.append([&#39;Angle&#39;,meta[&#39;a-mesh_bin_edges&#39;]])
        else:
            acols = True
            acol_names_list = [&#39;ia&#39;, &#39;a_mid&#39;]
            col_names_list += acol_names_list
    else:
        single_bin_ranges_or_values.append([&#39;Angle&#39;,&#39;default/all&#39;])
    if meta.nl != None:
        if meta.nl==1:
            single_specified_bin_axes.append(&#39;l&#39;)
            single_bin_ranges_or_values.append([&#39;LET&#39;,meta[&#39;l-mesh_bin_edges&#39;]])
        else:
            lcols = True
            lcol_names_list = [&#39;il&#39;, &#39;LET_mid&#39;]
            col_names_list += lcol_names_list
    else:
        single_bin_ranges_or_values.append([&#39;LET&#39;,&#39;default/all&#39;])

    if meta.nc != None:
        if meta.nc == 1:
            pass
        else:
            ccols = True
            if meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39;:
                if meta[&#39;axis&#39;] == &#39;chart&#39;:
                    ccol_names_list = [&#39;ic&#39;, &#39;nuclide&#39;, &#39;ZZZAAAM&#39;]
                    col_names_list += ccol_names_list
                elif meta[&#39;axis&#39;] == &#39;charge&#39;:
                    ccol_names_list = [&#39;ic/Z/charge&#39;]
                    col_names_list += ccol_names_list
                elif meta[&#39;axis&#39;] == &#39;mass&#39;:
                    ccol_names_list = [&#39;ic/A/mass&#39;]
                    col_names_list += ccol_names_list
            elif meta[&#39;tally_type&#39;] == &#39;[T-Deposit2]&#39;:
                pass

    if meta.npart != None: # and meta.part_groups[0]==&#39;all&#39;:
        if meta.npart==1:
            single_specified_bin_axes.append(&#39;p&#39;)
            single_bin_ranges_or_values.append([&#39;Particle&#39;,meta.part_groups[0]])
        else:
            pcols = True
            pcol_names_list = [&#39;ip&#39;, &#39;particle&#39;, &#39;kf-code&#39;]
            col_names_list += pcol_names_list
    else:
        single_bin_ranges_or_values.append([&#39;Particle&#39;,&#39;default/all&#39;])

    # HANDLE SPECIAL COLUMNS HERE (ic / ccols)


    # value columns come last
    val_names_list = [&#39;value&#39;, &#39;rel.err.&#39;]
    if ierr_max == 3 or ierr_max == 6: val_names_list += [&#39;abs.err.&#39;]
    if ierr_max &gt;= 4: val_names_list += [&#39;value2&#39;, &#39;rel.err.2&#39;]
    if ierr_max == 6: val_names_list += [&#39;abs.err.2&#39;]
    col_names_list += val_names_list

    # Initialize dictionary
    df_dict = {}
    for col in col_names_list:
        df_dict[col] = []


    # Populate dictionary
    for ir in range(ir_max):
        for iy in range(iy_max):
            for iz in range(iz_max):
                for ie in range(ie_max):
                    for it in range(it_max):
                        for ia in range(ia_max):
                            for il in range(il_max):
                                for ip in range(ip_max):
                                    for ic in range(ic_max):
                                        # Region columns
                                        if in_irregular_TCross_rz_mesh:
                                            if (ir == ir_max - 1 and iz == iz_max - 1): # only index that should be empty
                                                continue
                                            # [&#39;ir&#39;, &#39;iz&#39;, &#39;r_mid&#39;, &#39;z_surf&#39;, &#39;r_surf&#39;, &#39;z_mid&#39;]
                                            df_dict[reg_cols[0]].append(ir)
                                            df_dict[reg_cols[1]].append(iz)
                                            if ir==ir_max-1:
                                                df_dict[reg_cols[2]].append(None)
                                            else:
                                                df_dict[reg_cols[2]].append(meta[&#39;r-mesh_bin_mids&#39;][ir])
                                            df_dict[reg_cols[3]].append(meta[&#39;z-mesh_bin_edges&#39;][iz])
                                            df_dict[reg_cols[4]].append(meta[&#39;r-mesh_bin_edges&#39;][ir])
                                            if iz == iz_max - 1:
                                                df_dict[reg_cols[5]].append(None)
                                            else:
                                                df_dict[reg_cols[5]].append(meta[&#39;z-mesh_bin_mids&#39;][iz])
                                            # OLD IMPLEMENTATION IS BELOW:
                                            &#39;&#39;&#39;
                                            # skip unwritten indices
                                            # reg_cols = [&#39;ir&#39;, &#39;ic&#39;, &#39;r_mid&#39;, &#39;z_surf&#39;, &#39;iy&#39;, &#39;iz&#39;, &#39;r_surf&#39;, &#39;z_mid&#39;]
                                            if (ir==ir_max-1 and ic==ic_max-1):
                                                if (iy == iy_max - 1 or iz == iz_max - 1): continue
                                                if min_r_is_zero and iy==0: continue # surface vals not written for r=0.0
                                                df_dict[reg_cols[0]].append(None)
                                                df_dict[reg_cols[1]].append(None)
                                                df_dict[reg_cols[2]].append(None)
                                                df_dict[reg_cols[3]].append(None)
                                                df_dict[reg_cols[4]].append(iy)
                                                df_dict[reg_cols[5]].append(iz)
                                                df_dict[reg_cols[6]].append(meta[&#39;r-mesh_bin_edges&#39;][iy])
                                                df_dict[reg_cols[7]].append(meta[&#39;z-mesh_bin_mids&#39;][iz])
                                            elif (iy==iy_max-1 and iz==iz_max-1):
                                                if (ir == ir_max - 1 or ic == ic_max - 1): continue
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(ic)
                                                df_dict[reg_cols[2]].append(meta[&#39;r-mesh_bin_mids&#39;][ir])
                                                df_dict[reg_cols[3]].append(meta[&#39;z-mesh_bin_edges&#39;][ic])
                                                df_dict[reg_cols[4]].append(None)
                                                df_dict[reg_cols[5]].append(None)
                                                df_dict[reg_cols[6]].append(None)
                                                df_dict[reg_cols[7]].append(None)
                                            else: # all other indices should not have any content written into them
                                                continue
                                            &#39;&#39;&#39;
                                        else:
                                            if meta.mesh == &#39;reg&#39;: #reg_cols = [&#39;ir&#39;,&#39;reg&#39;, &#39;reg#&#39;]  # use meta.reg_groups and meta.reg_num
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(meta.reg_groups[ir])
                                                df_dict[reg_cols[2]].append(meta.reg_num[ir])
                                            elif meta.mesh == &#39;xyz&#39;:
                                                #reg_cols = [&#39;ix&#39;, &#39;iy&#39;, &#39;iz&#39;, &#39;xmid&#39;, &#39;ymid&#39;, &#39;zmid&#39;]
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(iy)
                                                df_dict[reg_cols[2]].append(iz)
                                                df_dict[reg_cols[3]].append(meta[&#39;x-mesh_bin_mids&#39;][ir])
                                                df_dict[reg_cols[4]].append(meta[&#39;y-mesh_bin_mids&#39;][iy])
                                                if in_irregular_TCross_xyz_mesh:
                                                    df_dict[reg_cols[5]].append(meta[&#39;z-mesh_bin_edges&#39;][iz])
                                                else:
                                                    df_dict[reg_cols[5]].append(meta[&#39;z-mesh_bin_mids&#39;][iz])
                                            elif meta.mesh == &#39;r-z&#39;:
                                                #reg_cols = [&#39;ir&#39;, &#39;iz&#39;, &#39;rmid&#39;, &#39;zmid&#39;]
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(iz)
                                                df_dict[reg_cols[2]].append(meta[&#39;r-mesh_bin_mids&#39;][ir])
                                                df_dict[reg_cols[3]].append(meta[&#39;z-mesh_bin_mids&#39;][iz])
                                            elif meta.mesh == &#39;tet&#39;:
                                                #reg_cols = [&#39;ir&#39;,&#39;tet&#39;]
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(meta.tet_num[ir])
                                            elif meta.mesh == &#39;point&#39;:
                                                #reg_cols = [&#39;ir&#39;,&#39;point#&#39;]
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(str(ir+1))
                                            elif meta.mesh == &#39;ring&#39;:
                                                #reg_cols = [&#39;ir&#39;,&#39;ring#&#39;]
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(str(ir+1))

                                        #ecols, tcols, acols, lcols, pcols, ccols
                                        if pcols: # pcol_names_list = [&#39;ip&#39;, &#39;particle&#39;, &#39;kf-code&#39;]
                                            df_dict[pcol_names_list[0]].append(ip)
                                            df_dict[pcol_names_list[1]].append(meta.part_groups[ip])
                                            df_dict[pcol_names_list[2]].append(meta.kf_groups[ip])

                                        if ecols: # ecol_names_list = [&#39;ie&#39;,&#39;e_mid&#39;]
                                            df_dict[ecol_names_list[0]].append(ie)
                                            df_dict[ecol_names_list[1]].append(meta[&#39;e-mesh_bin_mids&#39;][ie])
                                        if tcols: # tcol_names_list = [&#39;it&#39;,&#39;t_mid&#39;]
                                            df_dict[tcol_names_list[0]].append(it)
                                            df_dict[tcol_names_list[1]].append(meta[&#39;t-mesh_bin_mids&#39;][it])
                                        if acols: # acol_names_list = [&#39;ia&#39;,&#39;a_mid&#39;]
                                            df_dict[acol_names_list[0]].append(ia)
                                            df_dict[acol_names_list[1]].append(meta[&#39;a-mesh_bin_mids&#39;][ia])
                                        if lcols: # lcol_names_list = [&#39;il&#39;,&#39;LET_mid&#39;]
                                            df_dict[lcol_names_list[0]].append(il)
                                            df_dict[lcol_names_list[1]].append(meta[&#39;l-mesh_bin_mids&#39;][il])

                                        if ccols:
                                            if meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39;:
                                                if meta[&#39;axis&#39;] == &#39;chart&#39;:
                                                    #ccol_names_list = [&#39;ic&#39;, &#39;nuclide&#39;, &#39;ZZZAAAM&#39;]
                                                    df_dict[ccol_names_list[0]].append(ic)
                                                    df_dict[ccol_names_list[1]].append(meta[&#39;nuclide_isomer_list&#39;][ic])
                                                    df_dict[ccol_names_list[2]].append(meta[&#39;nuclide_ZZZAAAM_list&#39;][ic])
                                                elif meta[&#39;axis&#39;] == &#39;charge&#39;:
                                                    #ccol_names_list = [&#39;ic/Z/charge&#39;]
                                                    df_dict[ccol_names_list[0]].append(ic)
                                                elif meta[&#39;axis&#39;] == &#39;mass&#39;:
                                                    #ccol_names_list = [&#39;ic/A/mass&#39;]
                                                    df_dict[ccol_names_list[0]].append(ic)

                                        # Value columns
                                        #val_names_list = [&#39;value&#39;, &#39;rel.err.&#39;,&#39;abs.err.&#39;]
                                        df_dict[val_names_list[0]].append(tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 0])
                                        df_dict[val_names_list[1]].append(tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 1])
                                        if ierr_max == 3 or ierr_max == 6:
                                            df_dict[val_names_list[2]].append(tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 2])
                                        if in_irregular_TCross_rz_mesh:
                                            df_dict[val_names_list[0+ierr_mod]].append(tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 0+ierr_mod])
                                            df_dict[val_names_list[1+ierr_mod]].append(tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 1+ierr_mod])
                                            if ierr_max == 6:
                                                df_dict[val_names_list[2+ierr_mod]].append(tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 2 + ierr_mod])


    # Convert dictionary to Pandas dataframe
    #for key in df_dict.keys():
    #    print(key,len(df_dict[key]))
    #sys.exit()
    tally_df = pd.DataFrame(df_dict)

    # store information on settings provided by user that are different from default but same for all rows
    if len(single_bin_ranges_or_values) &gt; 0:
        for i in single_bin_ranges_or_values:
            col, val = i
            tally_df.attrs[col] = val

    #with pd.option_context(&#39;display.max_rows&#39;, None, &#39;display.max_columns&#39;, None): print(tally_df)
    if in_debug_mode:
        #print(tally_df.to_string())
        print(tally_df.attrs)
    return tally_df

def search_for_dump_parameters(output_file):
    &#39;&#39;&#39;
    Description:
        Try to determine the dump settings used for a dump file by searching for the same file without &#34;_dmp&#34; and parsing
        its header for the &#34;dump = &#34; line and subsequent line specifying the column ordering.

    Dependencies:
        - `from pathlib import Path`

    Inputs:
        - `output_file` = a file/filepath (string or Path object) to be judged

    Outputs:
        - `dump_data_number` = value following &#34;dump = &#34; in the PHITS tally (integer from -20 to 20, excluding 0) (D=`None`)
        - `dump_data_sequence` = list of integers specifying the order and meaning of the dump file columns (D=`None`)
    &#39;&#39;&#39;
    dump_data_number, dump_data_sequence = None, None
    output_file = Path(output_file)
    origin_tally_file = Path(output_file.parent, output_file.stem.replace(&#39;_dmp&#39;,&#39;&#39;) + output_file.suffix)
    PHITS_file_type = determine_PHITS_output_file_type(origin_tally_file)
    if PHITS_file_type[&#39;file_does_not_exist&#39;]:
        print(&#34;Could not find this dump file&#39;s companion original standard tally output file&#34;,origin_tally_file)
        return dump_data_number, dump_data_sequence
    elif not PHITS_file_type[&#39;is_standard_tally_output&#39;]:
        print(&#34;Found dump file&#39;s suspected companion original standard tally output file, but it does not seem to actually be formatted as a standard tally output file&#34;,origin_tally_file)
        return dump_data_number, dump_data_sequence
    tally_header, tally_content = split_into_header_and_content(origin_tally_file)
    for li, line in enumerate(tally_header):
        if &#34;dump =&#34; in line:
            if line[0] == &#39;#&#39;:  # commented line
                key, value = extract_data_from_header_line(line[1:])
            else:
                key, value = extract_data_from_header_line(line)
            dump_data_number = int(value)
            dump_data_sequence_str_list = tally_header[li+1].strip().split()
            dump_data_sequence = [int(i) for i in dump_data_sequence_str_list]
            break
    if dump_data_number == None and dump_data_sequence == None:
        print(&#39;Was unable to locate dump specification information in tally output file&#39;,origin_tally_file)
    return dump_data_number, dump_data_sequence

def determine_PHITS_output_file_type(output_file):
    &#39;&#39;&#39;
    Description:
        Determine what kind of PHITS file is being hanlded (tally standard output, binary tally dump, ASCII tally dump, etc.)

    Dependencies:
        - `from pathlib import Path`

    Inputs:
        - `output_file` = a file/filepath (string or Path object) to be judged

    Outputs:
        - `PHITS_file_type` = a dictionary of Booleans detailing what kind of file `output_file` is (and isn&#39;t) with
            the following keys (each with a value set to `True` or `False`):
            `&#39;is_standard_tally_output&#39;`, `&#39;is_binary_tally_dump&#39;`, `&#39;is_ASCII_tally_dump&#39;`,
            `&#39;is_unknown_file_type&#39;`, and `&#39;file_does_not_exist&#39;`.  By default, all are set to `False` except for
            `&#39;is_unknown_file_type&#39;` which is `True` by default.
    &#39;&#39;&#39;
    PHITS_file_type = {&#39;is_standard_tally_output&#39;: False,
                       &#39;is_binary_tally_dump&#39;: False,
                       &#39;is_ASCII_tally_dump&#39;: False,
                       &#39;is_unknown_file_type&#39;: True,
                       &#39;file_does_not_exist&#39;: False
                       }
    output_file = Path(output_file)
    if not output_file.is_file():
        print(&#39;Provided output file&#39;,output_file,&#39;was determined to not be a file!&#39;)
        PHITS_file_type[&#39;is_unknown_file_type&#39;] = False
        PHITS_file_type[&#39;file_does_not_exist&#39;] = True
        return PHITS_file_type
    with open(output_file) as f:
        try:
            first_line = f.readline().strip()
        except:  # triggered if encountering binary / non ASCII or UTF-8 file
            if &#39;_dmp&#39; in output_file.stem:
                PHITS_file_type[&#39;is_binary_tally_dump&#39;] = True
                PHITS_file_type[&#39;is_unknown_file_type&#39;] = False
                return PHITS_file_type
        if first_line[0] == &#39;[&#39;:
            PHITS_file_type[&#39;is_standard_tally_output&#39;] = True
            PHITS_file_type[&#39;is_unknown_file_type&#39;] = False
        elif &#39;_dmp&#39; in output_file.stem:
            PHITS_file_type[&#39;is_ASCII_tally_dump&#39;] = True
            PHITS_file_type[&#39;is_unknown_file_type&#39;] = False
    return PHITS_file_type













if run_with_CLI_inputs:
    def validate_file(arg):
        if (file := Path(arg)).is_file():
            return file
        else:
            raise FileNotFoundError(arg)
    parser = argparse.ArgumentParser()
    parser.add_argument(&#34;file&#34;, type=validate_file, help=&#34;path to PHITS output file to parse or directory containing files to parse (relative or absolute path)&#34;)
    # Flags for standard output files
    parser.add_argument(&#34;-np&#34;, &#34;--disable_PandasDF&#34;, help=&#34;[standard output] disable automatic creation of Pandas DataFrame of PHITS output&#34;, action=&#34;store_true&#34;)
    parser.add_argument(&#34;-na&#34;, &#34;--disable_abs_err_calc&#34;, help=&#34;[standard output] disable automatic calculation of absolute errors&#34;, action=&#34;store_true&#34;)
    # Not going to add below option. Why would you ever run this in CLI if not trying to generate the pickle file?
    # parser.add_argument(&#34;-ns&#34;, &#34;--disable_saving_pickle&#34;, help=&#34;disable saving of pickle of of PHITS output&#34;, action=&#34;store_true&#34;)
    # Flags for dump files
    parser.add_argument(&#34;-d&#34;, &#34;--is_dump_file&#34;, action=&#34;store_true&#34;, help=&#34;add this flag if the file is a dump file, omit if standard PHITS tally output; if inputting a directory path to &#39;file&#39;, this flag specifies that dump files will be read too (by default, they will be skipped), and if so the below flags will be applied to the settings used when parsing them&#34;)
    parser.add_argument(&#39;-dvals&#39;, &#39;--dump_data_sequence&#39;, nargs=&#39;+&#39;, type=int, help=&#39;[dump output] provide a series of integers separated by spaces that match the line after &#34;dump = &#34; in the tally whose dump file is being parsed, detailing how the columns of the dump file are to be interpreted. (REQUIRED for dump files, but an attempt to assign automatically will be made first if left unspecified)&#39;)
    parser.add_argument(&#34;-dbin&#34;, &#34;--dump_file_is_binary&#34;, action=&#34;store_true&#34;, help=&#34;[dump output] specify that the provided dump file is binary; otherwise it is assumed to be ASCII (REQUIRED for dump files, but an attempt to assign automatically will be made first if left unspecified)&#34;)
    parser.add_argument(&#34;-dnmax&#34;, &#34;--dump_max_entries_read&#34;, type=int, help=&#34;[dump output] specify maximum integer number of entries to read (read all by default)&#34;)
    parser.add_argument(&#34;-ddir&#34;, &#34;--dump_return_directional_info&#34;, action=&#34;store_true&#34;, help=&#34;[dump output] return extra directional information: radial distance r from the origin in cm, radial distance rho from the z-axis in cm, polar angle theta between the direction vector and z-axis in radians [0,pi] (or degrees), and azimuthal angle phi of the direction vector in radians [-pi,pi] (or degrees). Note: This option requires all position and direction values [x,y,z,u,v,w] to be included in the dump file.&#34;)
    parser.add_argument(&#34;-ddeg&#34;, &#34;--dump_use_degrees&#34;, action=&#34;store_true&#34;, help=&#34;[dump output] anular quantities will be in degrees instead of radians&#34;)
    parser.add_argument(&#34;-dnsl&#34;, &#34;--dump_no_save_namedtuple_list&#34;, action=&#34;store_true&#34;, help=&#34;[dump output] do NOT save parsed dump file info to list of namedtuples to dill file (-dnsl and -dnsp cannot both be enabled if parsing a dump file)&#34;)
    parser.add_argument(&#34;-dnsp&#34;, &#34;--dump_no_save_Pandas_dataframe&#34;, action=&#34;store_true&#34;, help=&#34;[dump output] do NOT save parsed dump file info to Pandas DataFrame to pickle file (-dnsl and -dnsp cannot both be enabled if parsing a dump file)&#34;)
    # Flags for processing files in a directory
    parser.add_argument(&#34;-r&#34;, &#34;--recursive_search&#34;, action=&#34;store_true&#34;, help=&#34;[directory parsing] If the provided &#39;file&#39; is a directory, also recursively search subdirectories for files to process.&#34;)
    parser.add_argument(&#34;-fpre&#34;, &#34;--file_prefix&#34;, default=&#39;&#39;, help=&#34;[directory parsing] A string specifying what characters processed filenames (including the file extension) must begin with to be included. This condition is not enforced if set to an empty string (default).&#34;)
    parser.add_argument(&#34;-fsuf&#34;, &#34;--file_suffix&#34;, default=&#39;.out&#39;, help=&#34;[directory parsing] A string specifying what characters processed filenames (including the file extension) must end in to be included. This condition is not enforced if set to an empty string. This is &#39;.out&#39; by deault.&#34;)
    parser.add_argument(&#34;-fstr&#34;, &#34;--file_required_string&#34;, default=&#39;&#39;, help=&#34;[directory parsing] A string which must be present anywhere within processed filenames (including the file extension) to be included. This condition is not enforced if set to an empty string (default).&#34;)

    args = parser.parse_args()

    output_file_path = Path(args.file)
    is_dump_file = args.is_dump_file

    is_path_a_dir = output_file_path.is_dir()
    is_path_a_file = output_file_path.is_file()

    if not is_path_a_file and not is_path_a_dir:
        print(&#34;ERROR! The inputted filepath is neither a recognized file nor directory.&#34;)
        sys.exit()

    # directory options
    recursive_search = args.recursive_search
    file_suffix = args.file_suffix
    file_prefix = args.file_prefix
    file_reqstr = args.file_required_string

    # Standard output options
    make_PandasDF = not args.disable_PandasDF
    calculate_absolute_errors = not args.disable_abs_err_calc

    # Dump output options
    dump_data_sequence = args.dump_data_sequence
    if dump_data_sequence != None:
        dump_data_number = len(dump_data_sequence)
        if not args.dump_file_is_binary:
            dump_data_number = -1 * dump_data_number
    else:
        dump_data_number = None
    return_namedtuple_list = False
    return_Pandas_dataframe = False
    max_entries_read = args.dump_max_entries_read
    return_directional_info = args.dump_return_directional_info
    use_degrees = args.dump_use_degrees
    no_save_namedtuple_list = args.dump_no_save_namedtuple_list
    no_save_Pandas_dataframe = args.dump_no_save_Pandas_dataframe
    save_namedtuple_list = not no_save_namedtuple_list
    save_Pandas_dataframe = not no_save_Pandas_dataframe

    if is_path_a_dir:
        parse_all_tally_output_in_dir(output_file_path, output_file_suffix=file_suffix, output_file_prefix=file_prefix,
                                      output_file_required_string=file_reqstr, include_subdirectories=recursive_search,
                                      return_tally_output=False,
                                      make_PandasDF=make_PandasDF, calculate_absolute_errors=calculate_absolute_errors,
                                      save_output_pickle=True, prefer_reading_existing_pickle=False,
                                      include_dump_files=is_dump_file,
                                      dump_data_number=dump_data_number, dump_data_sequence=dump_data_sequence,
                                      dump_return_directional_info=return_directional_info, dump_use_degrees=use_degrees,
                                      dump_max_entries_read=max_entries_read,
                                      dump_save_namedtuple_list=save_namedtuple_list,
                                      dump_save_Pandas_dataframe=save_Pandas_dataframe
                                      )
    else: # if is_path_a_file
        if is_dump_file:
            if dump_data_number == None:
                dump_data_number, dump_data_sequence = search_for_dump_parameters(output_file_path)
                if dump_data_number == None or dump_data_sequence == None:
                    print(&#39;You MUST provide a space-delimited list of integers to the -dvals / --dump_data_sequence input specifying &#39; +
                          &#39;how the data columns in the dump file are to be interpreted, the same as the line following &#34;dump = &#34; in your PHITS tally input. &#39; +
                          &#39;An attempt was made to automatically find these values, but it failed (thus, manual specification is required).&#39;)
                    sys.exit()
            if no_save_namedtuple_list and no_save_Pandas_dataframe:
                print(&#39;You MUST select how the dump file data is to be saved by disabling either or both of the following flags:&#39; +
                      &#39; -dsl / --dump_save_namedtuple_list AND/OR -dsp / --dump_save_Pandas_dataframe&#39;)
                sys.exit()
            parse_tally_dump_file(output_file_path, dump_data_number, dump_data_sequence,
                                  return_directional_info=return_directional_info, use_degrees=use_degrees,
                                  max_entries_read=max_entries_read,
                                  return_namedtuple_list=return_namedtuple_list,
                                  return_Pandas_dataframe=return_Pandas_dataframe,
                                  save_namedtuple_list=save_namedtuple_list,
                                  save_Pandas_dataframe=save_Pandas_dataframe)
        else:
            parse_tally_output_file(output_file_path, make_PandasDF=make_PandasDF,
                                    calculate_absolute_errors=calculate_absolute_errors,
                                    save_output_pickle=True, prefer_reading_existing_pickle=False)

elif launch_GUI:
    pass






elif in_debug_mode:
    base_path = r&#39;G:\Cloud\OneDrive\work\PHITS\test_tallies\tally\\&#39;
    #output_file_path = Path(base_path + &#39;t-deposit\deposit_reg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit\deposit_eng_sp-reg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-track\\track_reg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-track\\track_r-z.out&#39;)
    #output_file_path = Path(base_path + &#39;t-track\\track_xyz-xy.out&#39;)
    #output_file_path = Path(base_path + r&#39;t-track\track_r-z_axis-rad.out&#39;)
    #output_file_path = Path(base_path + r&#39;t-track\track_r-z_axis-deg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit\deposit_r-z.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit\deposit_r-z_2dtype4.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit\deposit_r-z_2dtype5.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit\deposit_xyz_2dtype5.out&#39;)
    #output_file_path = Path(base_path + &#39;tet_test\deposit-tet_axis-tet.out&#39;)
    #output_file_path = Path(base_path + &#39;tet_test\deposit-tet_axis-eng.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\cross_reg_axis-eng.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\cross_reg_axis-reg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\cross_xyz_axis-eng.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\cross_xyz_axis-eng_enclosed.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\cross_xyz_axis-reg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\cross_xyz_axis-xy.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\cross-r-z_axis-eng.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\cross-r-z_axis-eng_0r.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\cross-r-z_axis-eng_enclosed.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\complex\proton_in_hist_rz.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\complex\\neutron_yield_rz-e-a-mesh.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\complex\\neutron_yield.out&#39;)
    #output_file_path = Path(base_path + &#39;t-cross\complex\\xtra_neutron_yield_EvsTheta_whole-target.out&#39;)
    #output_file_path = Path(base_path + &#39;t-dpa\dpa_reg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-dpa\dpa_xyz.out&#39;)
    #output_file_path = Path(base_path + &#39;t-dpa\dpa_r-z.out&#39;)
    #output_file_path = Path(base_path + &#39;samepage\\proton_in_hist_rz_axis-eng_samepage-z.out&#39;)
    #output_file_path = Path(base_path + &#39;samepage\\proton_in_hist_rz_reduced.out&#39;) # has NULL characters in it
    #output_file_path = Path(base_path + &#39;samepage\\proton_in_hist_rz_sp-eng.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit2\deposit2_reg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit2\deposit2_reg_axis-e21.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit2\deposit2_reg_axis-t-e1.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit2\deposit2_reg_axis-t-e2.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit2\deposit2_reg_axis-e1-t.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit2\deposit2_reg_axis-e2-t.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit2\deposit2_reg_axis-eng1.out&#39;)
    #output_file_path = Path(base_path + &#39;t-deposit2\deposit2_reg_axis-eng2.out&#39;)
    #output_file_path = Path(base_path + &#39;t-heat\heat_reg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-heat\heat_xyz.out&#39;)
    #output_file_path = Path(base_path + &#39;t-interact\interact_reg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-interact\interact_xyz.out&#39;)
    #output_file_path = Path(base_path + &#39;t-let\let-distribution_reg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-let\let-distribution_r-z.out&#39;)
    #output_file_path = Path(base_path + r&#39;t-point\point.out&#39;)
    #output_file_path = Path(base_path + r&#39;t-point\ring.out&#39;)
    #output_file_path = Path(base_path + &#39;t-product\product_reg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-sed\y-distribution_reg.out&#39;)
    #output_file_path = Path(base_path + &#39;t-sed\y-distribution_xyz.out&#39;)
    #output_file_path = Path(base_path + r&#39;t-time\time_reg.out&#39;)
    #output_file_path = Path(base_path + r&#39;t-time\time_xyz.out&#39;)
    #output_file_path = Path(base_path + r&#39;t-yield\yield_reg_axis-charge.out&#39;)
    #output_file_path = Path(base_path + r&#39;t-yield\yield_reg_axis-mass.out&#39;)
    output_file_path = Path(base_path + r&#39;t-yield\yield_reg_axis-chart.out&#39;)
    #output_file_path = Path(base_path + r&#39;t-yield\yield_xyz_axis-chart.out&#39;)

    test_parsing_of_dir = False #True
    if test_parsing_of_dir:
        dir_path = output_file_path = Path(base_path + &#39;t-cross\complex\proton_in_hist_rz.out&#39;)
        dir_output_list = parse_all_tally_output_in_dir(dir_path)
        print(dir_output_list)
        sys.exit()


    test_dump_file = False
    if test_dump_file:
        dump_file_path = Path(base_path + &#39;t-cross\complex\\neutron_yield_dmp.out&#39;)
        dump_control_str = &#39;2   3   4   5   6   7   8  10&#39;
        #nt_list, df = parse_tally_dump_file(dump_file_path,8,dump_control_str, save_namedtuple_list=True, save_Pandas_dataframe=True)
        # test automatic finding of dump parameters
        nt_list, df = parse_tally_dump_file(dump_file_path, save_namedtuple_list=True, save_Pandas_dataframe=True)

        # test dill of namedtuple list
        import dill
        path_to_pickle_file = Path(base_path + &#39;t-cross\complex\\neutron_yield_dmp_namedtuple_list.dill&#39;)
        with open(path_to_pickle_file, &#39;rb&#39;) as handle:
            nt_list_dill = dill.load(handle)

        if nt_list==nt_list_dill: print(&#39;It works!&#39;)

        sys.exit()



    tally_output_filepath = output_file_path
    tally_output = parse_tally_output_file(tally_output_filepath, make_PandasDF=True, calculate_absolute_errors=True,
                                           save_output_pickle=True)
    tally_data = tally_output[&#39;tally_data&#39;]
    tally_metadata = tally_output[&#39;tally_metadata&#39;]

    #pprint.pp(dict(tally_metadata))
    #                ir, iy, iz, ie, it, ia, il, ip, ic, ierr
    print(tally_data[ :,  0,  0,  :,  0,  0,  0,  0,  0, 0])
    print(tally_data[ :,  0,  0,  :,  0,  0,  0,  0,  0, 1])
    print(np.shape(tally_data))

    #print(tally_data[ 1,  0,  0,  0,  0,  0,  0,  0,  :, 0])
    #print(tally_metadata[&#39;nuclide_ZZZAAAM_list&#39;])
    #print(tally_metadata[&#39;nuclide_isomer_list&#39;])

    #ic = tally_metadata[&#39;nuclide_ZZZAAAM_list&#39;].index(10020)
    #print(tally_data[1, 0, 0, 0, 0, 0, 0, 0, ic, 0])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="PHITS_tools.parse_tally_output_file"><code class="name flex">
<span>def <span class="ident">parse_tally_output_file</span></span>(<span>tally_output_filepath, make_PandasDF=True, calculate_absolute_errors=True, save_output_pickle=True, prefer_reading_existing_pickle=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Parse any PHITS tally output file, returning tally metadata and an array of its values (and optionally
this data inside of a Pandas dataframe too).
Note the separate <code><a title="PHITS_tools.parse_tally_dump_file" href="#PHITS_tools.parse_tally_dump_file">parse_tally_dump_file()</a></code> function for
parsing PHITS dump files.</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code>import numpy as np</code></li>
<li><code>import pandas as pd</code> (if <code>make_PandasDF = True</code>)</li>
<li><code>import pickle</code> (if <code>save_output_pickle = True</code>)</li>
<li><code>from munch import *</code></li>
<li><code>from pathlib import Path</code></li>
</ul>
<h2 id="inputs">Inputs</h2>
<p>(required)</p>
<ul>
<li><code>tally_output_filepath</code> = file or filepath to the tally output file to be parsed</li>
</ul>
<h2 id="inputs_1">Inputs</h2>
<p>(optional)</p>
<ul>
<li><code>make_PandasDF</code> = A Boolean determining whether a Pandas dataframe of the tally data array will be made (D=<code>True</code>)</li>
<li><code>calculate_absolute_errors</code> = A Boolean determining whether the absolute uncertainty of each tally output value
is to be calculated (simply as the product of the value and relative error); if <code>False</code>, the final
dimension of <code>tally_data</code>, <code>ierr</code>, will be of length-2 rather than length-3 (D=<code>True</code>)</li>
<li><code>save_output_pickle</code> = A Boolean determining whether the <code>tally_output</code> dictionary object is saved as a pickle file;
if <code>True</code>, the file will be saved with the same path and name as the provided PHITS tally output file
but with the .pickle extension. (D=<code>True</code>)</li>
<li><code>prefer_reading_existing_pickle</code> = A Boolean determining what this function does if the pickle file this function
seeks to generate already exists.
If <code>False</code> (default behavior), this function will parse the PHITS
output files as usual and overwrite the existing pickle file.
If <code>True</code>, this function will instead
simply just read the existing found pickle file and return its stored <code>tally_output</code> contents. (D=<code>False</code>)</li>
</ul>
<h2 id="output">Output</h2>
<ul>
<li><code>tally_output</code> = a dictionary object with the below keys and values:<ul>
<li><code>'tally_data'</code> = a 10-dimensional NumPy array containing all tally results, explained in more detail below</li>
<li><code>'tally_metadata'</code> = a dictionary/Munch object with various data extracted from the tally output file, such as axis binning and units</li>
<li><code>'tally_dataframe'</code> = (optionally included if setting <code>make_PandasDF = True</code>) a Pandas dataframe version of <code>tally_data</code></li>
</ul>
</li>
</ul>
<h2 id="notes">Notes</h2>
<p>Many quantities can be scored across the various tallies in the PHITS code.
This function outputs a "universal"
array <code>tally_data</code> that can accomodate all of the different scoring geometry meshes, physical quantities with
assigned meshes, and output axes provided within PHITS.
This is achieved with a 10-dimensional array accessible as</p>
<p><code>tally_data[ ir, iy, iz, ie, it, ia, il, ip, ic, ierr ]</code>, with indices explained below:</p>
<p>Tally data indices and corresponding mesh/axis:</p>
<ul>
<li><code>0</code> | <code>ir</code>, Geometry mesh: <code>reg</code> / <code>x</code> / <code>r</code> / <code>tet</code> ([T-Cross] <code>ir surf</code> if <code>mesh=r-z</code> with <code>enclos=0</code>)</li>
<li><code>1</code> | <code>iy</code>, Geometry mesh:
<code>1</code> / <code>y</code> / <code>1</code></li>
<li><code>2</code> | <code>iz</code>, Geometry mesh:
<code>1</code> / <code>z</code> / <code>z</code> ([T-Cross] <code>iz surf</code> if <code>mesh=xyz</code> or <code>mesh=r-z</code> with <code>enclos=0</code>)</li>
<li><code>3</code> | <code>ie</code>, Energy mesh: <code>eng</code> ([T-Deposit2] <code>eng1</code>)</li>
<li><code>4</code> | <code>it</code>, Time mesh</li>
<li><code>5</code> | <code>ia</code>, Angle mesh</li>
<li><code>6</code> | <code>il</code>, LET mesh</li>
<li><code>7</code> | <code>ip</code>, Particle type (<code>part =</code>)</li>
<li><code>8</code> | <code>ic</code>, Special: [T-Deposit2] <code>eng2</code>; [T-Yield] <code>mass</code>, <code>charge</code>, <code>chart</code></li>
<li><code>9</code> | <code>ierr = 0/1/2</code>, Value / relative uncertainty / absolute uncertainty (expanded to <code>3/4/5</code>, or <code>2/3</code> if
<code>calculate_absolute_errors = False</code>, for [T-Cross] <code>mesh=r-z</code> with <code>enclos=0</code> case; see notes further below)</li>
</ul>
<hr>
<p>By default, all array dimensions are length-1 (except <code>ierr</code>, which is length-3).
These dimensions are set/corrected
automatically when parsing the tally output file.
Thus, for very simple tallies, most of these indices will be
set to 0 when accessing tally results, e.g. <code>tally_data[2,0,0,:,0,0,0,:,0,:]</code> to access the full energy spectrum
in the third region for all scored particles / particle groups with the values and uncertainties.</p>
<p>The output <code>tally_metadata</code> dictionary contains all information needed to identify every bin along every
dimension: region numbers/groups, particle names/groups, bin edges and midpoints for all mesh types
(x, y, z, r, energy, angle, time, and LET) used in the tally.</p>
<p>The <code>tally_dataframe</code> Pandas dataframe output functions as normal.
Note that a dictionary containing supplemental
information that is common to all rows of the dataframe can be accessed with <code>tally_dataframe.attrs</code>.</p>
<hr>
<p>At present, the following tallies are NOT supported by this function: [T-WWG], [T-WWBG], [T-Volume],
[T-Userdefined], [T-Gshow], [T-Rshow], [T-3Dshow], [T-4Dtrack], and [T-Dchain].</p>
<p>For [T-Dchain] or [T-Yield] with <code>axis = dchain</code>, please use the separate suite of parsing functions included in
the <a href="https://github.com/Lindt8/DCHAIN-Tools">DCHAIN Tools</a> module.</p>
<hr>
<p>The [T-Cross] tally is unique (scoring across region boundaries rather than within regions), creating some
additional challenges.
In the <code>mesh = reg</code> case, much is the same except each region number is composed of the <code>r-from</code> and <code>r-to</code> values, e.g. <code>'100 - 101'</code>.</p>
<p>For <code>xyz</code> and <code>r-z</code> meshes, an additional parameter is at play: <code>enclos</code>.
By default, <code>enclos=0</code>.
In the event <code>enclos=1</code> is set, the total number of geometric regions is still either <code>nx*ny*nz</code> or <code>nr*nz</code> for
<code>xyz</code> and <code>r-z</code> meshes, respectively.
For <code>enclos=0</code> in the <code>mesh = xyz</code> case, the length of the z dimension (<code>iz</code> index) is instead equal to <code>nzsurf</code>,
which is simply one greater than <code>nz</code> (# regions = <code>nx*ny*(nz+1)</code>).</p>
<p>For <code>enclos=0</code> in the <code>mesh = r-z</code> case, this is much more complicated as PHITS will output every combination of
<code>nr*nzsurf</code> AND <code>nrsurf*nz</code>, noting <code>nzsurf=nz+1</code> and <code>nrsurf=nr+1</code> (or <code>nrsurf=nr</code> if the first radius bin edge
is <code>r=0.0</code>).
The solution implemented here is to, for only this circumstance (in only the <code>enclos=0 mesh=r-z</code> case),
set the length of the <code>ir</code> and <code>iz</code> dimensions to <code>nrsurf</code> and <code>nzsurf</code>, respectively, and also
to expand the length of the final dimension of <code>tally_data</code> from 3 to 6 (or from 2 to 4 if <code>calculate_absolute_errors=False</code>), where:</p>
<ul>
<li><code>ierr = 0/1/2</code> refer to the combinations of <code>nr</code> and <code>nzsurf</code> (or <code>0/1</code> if <code>calculate_absolute_errors=False</code>)</li>
<li><code>ierr = 3/4/5</code> refer to the combinations of <code>nrsurf</code> and <code>nz</code> (or <code>2/3</code> if <code>calculate_absolute_errors=False</code>)</li>
</ul>
<p>In this case, the Pandas dataframe, if enabled, will contain 3 (or 2) extra columns <code>value2</code> and <code>rel.err.2</code> [and <code>abs.err.2</code>],
which correspond to the combinations of <code>nrsurf</code> and <code>nz</code> (while the original columns without the "2" refer to
values for combinations of and <code>nr</code> and <code>nzsurf</code>).</p>
<hr>
<p>[T-Yield] is also a bit exceptional.
When setting the <code>axis</code> parameter equal to <code>charge</code>, <code>mass</code>, or <code>chart</code>,
the <code>ic</code> dimension of <code>tally_data</code> is used for each entry of charge (proton number, Z), mass (A), or
isotope/isomer, respectively.</p>
<p>In the case of <code>axis = charge</code> or <code>axis = mass</code>, the value of <code>ic</code> refers to the actual charge/proton number Z
or mass number A when accessing <code>tally_data</code>; for instance, <code>tally_data[:,:,:,:,:,:,:,:,28,:]</code>
references results from nuclei with Z=28 if <code>axis = charge</code> or A=28 if <code>axis = mass</code>.
The length of the <code>ic</code>
dimension is initialized as 130 or 320 but is later reduced to only just include the highest charge or mass value.</p>
<p>In the case of <code>axis = chart</code>, the length of the <code>ic</code> dimension is initially set equal to the <code>mxnuclei</code> parameter
in the [T-Yield] tally.
If <code>mxnuclei = 0</code> is set, then the length of the <code>ic</code> dimension is initially set to 10,000.
This <code>ic</code> dimension length is later reduced to the total number of unique nuclides found in the output.
Owing to the huge number of possible nuclides, a list of found nuclides with nonzero yield is assembled and
added to <code>tally_metadata</code> under the keys <code>nuclide_ZZZAAAM_list</code> and <code>nuclide_isomer_list</code>, i.e.
<code>tally_metadata['nuclide_ZZZAAAM_list']</code> and <code>tally_metadata['nuclide_isomer_list']</code>.
These lists should be referenced to see what nuclide each of index <code>ic</code> refers to.
The entries of the ZZZAAAM list are intergers calculated with the formula 10000*Z + 10*A + M, where M is the
metastable state of the isomer (0 = ground state, 1 = 1st metastable/isomeric state, etc.).
The entries
of the isomer list are these same nuclides in the same order but written as plaintext strings, e.g. <code>'Al-28'</code> and <code>'Xe-133m1'</code>.
The lists are ordered in the same order nuclides are encountered while parsing the output file.
Thus, to sensibly access the yield of a specific nuclide, one must first find its index <code>ic</code> in one of the two
metadata lists of ZZZAAAM values or isomer names and then use that to access <code>tally_data</code>.
For example, to get
the yield results of production of carbon-14 (C-14), one would use the following code:</p>
<p><code>ic = tally_metadata['nuclide_ZZZAAAM_list'].index(60140)</code></p>
<p>OR</p>
<p><code>ic = tally_metadata['nuclide_isomer_list'].index('C-14')</code></p>
<p>then</p>
<p><code>my_yield_values = tally_data[:,:,:,:,:,:,:,:,ic,:]</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_tally_output_file(tally_output_filepath, make_PandasDF = True, calculate_absolute_errors = True,
                            save_output_pickle = True, prefer_reading_existing_pickle = False):
    &#39;&#39;&#39;
    Description:
        Parse any PHITS tally output file, returning tally metadata and an array of its values (and optionally
        this data inside of a Pandas dataframe too).  Note the separate `parse_tally_dump_file` function for
        parsing PHITS dump files.

    Dependencies:
        - `import numpy as np`
        - `import pandas as pd` (if `make_PandasDF = True`)
        - `import pickle` (if `save_output_pickle = True`)
        - `from munch import *`
        - `from pathlib import Path`

    Inputs:
       (required)

        - `tally_output_filepath` = file or filepath to the tally output file to be parsed

    Inputs:
       (optional)

       - `make_PandasDF` = A Boolean determining whether a Pandas dataframe of the tally data array will be made (D=`True`)
       - `calculate_absolute_errors` = A Boolean determining whether the absolute uncertainty of each tally output value
                      is to be calculated (simply as the product of the value and relative error); if `False`, the final
                      dimension of `tally_data`, `ierr`, will be of length-2 rather than length-3 (D=`True`)
       - `save_output_pickle` = A Boolean determining whether the `tally_output` dictionary object is saved as a pickle file;
                      if `True`, the file will be saved with the same path and name as the provided PHITS tally output file
                      but with the .pickle extension. (D=`True`)
       - `prefer_reading_existing_pickle` = A Boolean determining what this function does if the pickle file this function
                      seeks to generate already exists.  If `False` (default behavior), this function will parse the PHITS
                      output files as usual and overwrite the existing pickle file.  If `True`, this function will instead
                      simply just read the existing found pickle file and return its stored `tally_output` contents. (D=`False`)

    Output:
        - `tally_output` = a dictionary object with the below keys and values:
            - `&#39;tally_data&#39;` = a 10-dimensional NumPy array containing all tally results, explained in more detail below
            - `&#39;tally_metadata&#39;` = a dictionary/Munch object with various data extracted from the tally output file, such as axis binning and units
            - `&#39;tally_dataframe&#39;` = (optionally included if setting `make_PandasDF = True`) a Pandas dataframe version of `tally_data`


    Notes:

       Many quantities can be scored across the various tallies in the PHITS code.  This function outputs a &#34;universal&#34;
       array `tally_data` that can accomodate all of the different scoring geometry meshes, physical quantities with
       assigned meshes, and output axes provided within PHITS.  This is achieved with a 10-dimensional array accessible as

       `tally_data[ ir, iy, iz, ie, it, ia, il, ip, ic, ierr ]`, with indices explained below:

       Tally data indices and corresponding mesh/axis:

        - `0` | `ir`, Geometry mesh: `reg` / `x` / `r` / `tet` ([T-Cross] `ir surf` if `mesh=r-z` with `enclos=0`)
        - `1` | `iy`, Geometry mesh:  `1` / `y` / `1`
        - `2` | `iz`, Geometry mesh:  `1` / `z` / `z` ([T-Cross] `iz surf` if `mesh=xyz` or `mesh=r-z` with `enclos=0`)
        - `3` | `ie`, Energy mesh: `eng` ([T-Deposit2] `eng1`)
        - `4` | `it`, Time mesh
        - `5` | `ia`, Angle mesh
        - `6` | `il`, LET mesh
        - `7` | `ip`, Particle type (`part = `)
        - `8` | `ic`, Special: [T-Deposit2] `eng2`; [T-Yield] `mass`, `charge`, `chart`
        - `9` | `ierr = 0/1/2`, Value / relative uncertainty / absolute uncertainty (expanded to `3/4/5`, or `2/3` if
        `calculate_absolute_errors = False`, for [T-Cross] `mesh=r-z` with `enclos=0` case; see notes further below)

       -----

       By default, all array dimensions are length-1 (except `ierr`, which is length-3).  These dimensions are set/corrected
       automatically when parsing the tally output file.  Thus, for very simple tallies, most of these indices will be
       set to 0 when accessing tally results, e.g. `tally_data[2,0,0,:,0,0,0,:,0,:]` to access the full energy spectrum
       in the third region for all scored particles / particle groups with the values and uncertainties.

       The output `tally_metadata` dictionary contains all information needed to identify every bin along every
       dimension: region numbers/groups, particle names/groups, bin edges and midpoints for all mesh types
       (x, y, z, r, energy, angle, time, and LET) used in the tally.

       The `tally_dataframe` Pandas dataframe output functions as normal.  Note that a dictionary containing supplemental
       information that is common to all rows of the dataframe can be accessed with `tally_dataframe.attrs`.

       -----

       At present, the following tallies are NOT supported by this function: [T-WWG], [T-WWBG], [T-Volume],
       [T-Userdefined], [T-Gshow], [T-Rshow], [T-3Dshow], [T-4Dtrack], and [T-Dchain].

       For [T-Dchain] or [T-Yield] with `axis = dchain`, please use the separate suite of parsing functions included in
       the [DCHAIN Tools](https://github.com/Lindt8/DCHAIN-Tools) module.

       -----

       The [T-Cross] tally is unique (scoring across region boundaries rather than within regions), creating some
       additional challenges.
       In the `mesh = reg` case, much is the same except each region number is composed of the `r-from` and `r-to` values, e.g. `&#39;100 - 101&#39;`.

       For `xyz` and `r-z` meshes, an additional parameter is at play: `enclos`.
       By default, `enclos=0`.
       In the event `enclos=1` is set, the total number of geometric regions is still either `nx*ny*nz` or `nr*nz` for
       `xyz` and `r-z` meshes, respectively.
       For `enclos=0` in the `mesh = xyz` case, the length of the z dimension (`iz` index) is instead equal to `nzsurf`,
       which is simply one greater than `nz` (# regions = `nx*ny*(nz+1)`).

       For `enclos=0` in the `mesh = r-z` case, this is much more complicated as PHITS will output every combination of
       `nr*nzsurf` AND `nrsurf*nz`, noting `nzsurf=nz+1` and `nrsurf=nr+1` (or `nrsurf=nr` if the first radius bin edge
       is `r=0.0`).
       The solution implemented here is to, for only this circumstance (in only the `enclos=0 mesh=r-z` case),
       set the length of the `ir` and `iz` dimensions to `nrsurf` and `nzsurf`, respectively, and also
       to expand the length of the final dimension of `tally_data` from 3 to 6 (or from 2 to 4 if `calculate_absolute_errors=False`), where:

        - `ierr = 0/1/2` refer to the combinations of `nr` and `nzsurf` (or `0/1` if `calculate_absolute_errors=False`)
        - `ierr = 3/4/5` refer to the combinations of `nrsurf` and `nz` (or `2/3` if `calculate_absolute_errors=False`)

       In this case, the Pandas dataframe, if enabled, will contain 3 (or 2) extra columns `value2` and `rel.err.2` [and `abs.err.2`],
       which correspond to the combinations of `nrsurf` and `nz` (while the original columns without the &#34;2&#34; refer to
       values for combinations of and `nr` and `nzsurf`).

       -----

       [T-Yield] is also a bit exceptional.  When setting the `axis` parameter equal to `charge`, `mass`, or `chart`,
       the `ic` dimension of `tally_data` is used for each entry of charge (proton number, Z), mass (A), or
       isotope/isomer, respectively.

       In the case of `axis = charge` or `axis = mass`, the value of `ic` refers to the actual charge/proton number Z
       or mass number A when accessing `tally_data`; for instance, `tally_data[:,:,:,:,:,:,:,:,28,:]`
       references results from nuclei with Z=28 if `axis = charge` or A=28 if `axis = mass`.  The length of the `ic`
       dimension is initialized as 130 or 320 but is later reduced to only just include the highest charge or mass value.

       In the case of `axis = chart`, the length of the `ic` dimension is initially set equal to the `mxnuclei` parameter
       in the [T-Yield] tally.  If `mxnuclei = 0` is set, then the length of the `ic` dimension is initially set to 10,000.
       This `ic` dimension length is later reduced to the total number of unique nuclides found in the output.
       Owing to the huge number of possible nuclides, a list of found nuclides with nonzero yield is assembled and
       added to `tally_metadata` under the keys `nuclide_ZZZAAAM_list` and `nuclide_isomer_list`, i.e.
       `tally_metadata[&#39;nuclide_ZZZAAAM_list&#39;]` and `tally_metadata[&#39;nuclide_isomer_list&#39;]`.
       These lists should be referenced to see what nuclide each of index `ic` refers to.
       The entries of the ZZZAAAM list are intergers calculated with the formula 10000\*Z + 10\*A + M, where M is the
       metastable state of the isomer (0 = ground state, 1 = 1st metastable/isomeric state, etc.).  The entries
       of the isomer list are these same nuclides in the same order but written as plaintext strings, e.g. `&#39;Al-28&#39;` and `&#39;Xe-133m1&#39;`.
       The lists are ordered in the same order nuclides are encountered while parsing the output file.
       Thus, to sensibly access the yield of a specific nuclide, one must first find its index `ic` in one of the two
       metadata lists of ZZZAAAM values or isomer names and then use that to access `tally_data`.  For example, to get
       the yield results of production of carbon-14 (C-14), one would use the following code:

       `ic = tally_metadata[&#39;nuclide_ZZZAAAM_list&#39;].index(60140)`

       OR

       `ic = tally_metadata[&#39;nuclide_isomer_list&#39;].index(&#39;C-14&#39;)`

       then

       `my_yield_values = tally_data[:,:,:,:,:,:,:,:,ic,:]`


    &#39;&#39;&#39;

    &#39;&#39;&#39;
    The old [T-Cross] mesh=r-z enclos=0 solution is written below:
        The solution implemented here uses `ir` to iterate `nr`, `iy` to iterate `nrsurf`, `iz` to
        iterate `nz`, and `ic` to iterate `nzsurf`.  Since only `rsurf*z [iy,iz]` and `r*zsurf [ir,ic]` pairs exist,
        when one pair is being written, the other will be `[-1,-1]`, thus the lengths of these dimensions for the array
        are increased by an extra 1 to prevent an overlap in the data written.
    &#39;&#39;&#39;
    pickle_filepath = Path(tally_output_filepath.parent, tally_output_filepath.stem + &#39;.pickle&#39;)
    if prefer_reading_existing_pickle and os.path.isfile(pickle_filepath):
        import pickle
        print(&#39;Reading found pickle file: &#39;, pickle_filepath)
        with open(pickle_filepath, &#39;rb&#39;) as handle:
            tally_output = pickle.load(handle)
        return tally_output

    # main toggled settings
    #calculate_absolute_errors = True
    construct_Pandas_frame_from_array = make_PandasDF
    #process_all_tally_out_files_in_directory = False
    save_pickle_files_of_output = save_output_pickle  # save metadata, array, and Pandas frame in a pickled dictionary object

    if construct_Pandas_frame_from_array: import pandas as pd

    # Check if is _err or _dmp file (or normal value file)
    is_val_file = False
    is_err_file = False
    is_dmp_file = False
    if tally_output_filepath.stem[-4:] == &#39;_err&#39;:
        is_err_file = True
    elif tally_output_filepath.stem[-4:] == &#39;_dmp&#39;:
        is_dmp_file = True
    else:
        is_val_file = True

    if is_dmp_file:
        print(&#39;ERROR: The provided file is a &#34;dump&#34; output file. Use the function titled &#34;parse_tally_dump_file&#34; to process it instead.&#39;)
        return None

    if is_err_file:
        print(&#39;WARNING: Provided file contains just relative uncertainties.&#39;,str(tally_output_filepath))
        potential_val_file = Path(tally_output_filepath.parent, tally_output_filepath.stem.replace(&#39;_err&#39;,&#39;&#39;) + tally_output_filepath.suffix)
        if potential_val_file.is_file():
            print(&#39;\t Instead, both it and the file with tally values will be parsed.&#39;)
            potential_err_file = tally_output_filepath
            tally_output_filepath = potential_val_file
            is_val_file = True
            is_err_file = False
        else:
            print(&#39;\t The corresponding file with tally values could not be found, so only these uncertainties will be parsed.&#39;)

    # Split content of output file into header and content
    if in_debug_mode: print(&#34;\nSplitting output into header and content...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    tally_header, tally_content = split_into_header_and_content(tally_output_filepath)
    if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    # print(len(tally_content))

    # Check if *_err file exists
    potential_err_file = Path(tally_output_filepath.parent, tally_output_filepath.stem + &#39;_err&#39; + tally_output_filepath.suffix)
    is_err_in_separate_file = potential_err_file.is_file()  # for some tallies/meshes, uncertainties are stored in a separate identically-formatted file

    # Extract tally metadata
    if in_debug_mode: print(&#34;\nExtracting tally metadata...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    tally_metadata = parse_tally_header(tally_header, tally_content)
    if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    if in_debug_mode: pprint.pp(dict(tally_metadata))
    # Check if tally_type is among those supported.
    unsupported_tally_types = [&#39;[T-WWG]&#39;, &#39;[T-WWBG]&#39;, &#39;[T-Volume]&#39;, &#39;[T-Userdefined]&#39;, &#39;[T-Gshow]&#39;, &#39;[T-Rshow]&#39;,
                               &#39;[T-3Dshow]&#39;, &#39;[T-4Dtrack]&#39;, &#39;[T-Dchain]&#39;]
    if tally_metadata[&#39;tally_type&#39;] in unsupported_tally_types:
        print(&#39;ERROR! tally type&#39;,tally_metadata[&#39;tally_type&#39;],&#39;is not supported by this function!&#39;)
        if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Dchain]&#39;:
            dchain_tools_url = &#39;github.com/Lindt8/DCHAIN-Tools&#39;
            print(&#39;However, the DCHAIN Tools module (&#39;,dchain_tools_url,&#39;) is capable of parsing all DCHAIN-related output.&#39;)
        return None
    if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Yield]&#39; and tally_metadata[&#39;axis&#39;] == &#39;dchain&#39;:
        dchain_tools_url = &#39;github.com/Lindt8/DCHAIN-Tools&#39;
        print(&#39;This function does not support [T-Yield] with setting &#34;axis = dchain&#34;.&#39;)
        print(&#39;However, the DCHAIN Tools module (&#39;, dchain_tools_url, &#39;) is capable of parsing all DCHAIN-related output.&#39;)
        return None

    # Initialize tally data array with zeros
    tally_data = initialize_tally_array(tally_metadata, include_abs_err=calculate_absolute_errors)

    # Parse tally data
    if is_val_file:
        err_mode = False
    else: # if is_err_file
        err_mode = True
    if in_debug_mode: print(&#34;\nParsing tally data...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    if tally_metadata[&#39;tally_type&#39;]==&#39;[T-Yield]&#39; and tally_metadata[&#39;axis&#39;] in [&#39;chart&#39;,&#39;charge&#39;,&#39;mass&#39;]: # need to update metadata too
        tally_data, tally_metadata = parse_tally_content(tally_data, tally_metadata, tally_content, is_err_in_separate_file, err_mode=err_mode)
    else:
        tally_data = parse_tally_content(tally_data, tally_metadata, tally_content, is_err_in_separate_file, err_mode=err_mode)
    if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    err_data_found = True
    if tally_metadata[&#39;axis_dimensions&#39;] == 2 and tally_metadata[&#39;2D-type&#39;] != 4:
        if is_err_file:
            err_data_found = False
        elif is_err_in_separate_file:
            err_tally_header, err_tally_content = split_into_header_and_content(potential_err_file)
            if in_debug_mode: print(&#34;\nParsing tally error...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
            if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Yield]&#39; and tally_metadata[&#39;axis&#39;] in [&#39;chart&#39;,&#39;charge&#39;,&#39;mass&#39;]:  # need to update metadata too
                tally_data, tally_metadata = parse_tally_content(tally_data, tally_metadata, err_tally_content, is_err_in_separate_file,err_mode=True)
            else:
                tally_data = parse_tally_content(tally_data, tally_metadata, err_tally_content, is_err_in_separate_file, err_mode=True)
            if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
        else:
            print(&#39;WARNING: A separate file ending in &#34;_err&#34; containing uncertainties should exist but was not found.&#39;)
            err_data_found = False
    if calculate_absolute_errors:
        if err_data_found:
            if in_debug_mode: print(&#34;\nCalculating absolute errors...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
            tally_data = calculate_tally_absolute_errors(tally_data)
            if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
        elif is_err_file:
            print(&#39;WARNING: Absolute errors not calculated since the main tally values file was not found.&#39;)
        else:
            print(&#39;WARNING: Absolute errors not calculated since the _err file was not found.&#39;)
    # Generate Pandas dataframe of tally results
    if construct_Pandas_frame_from_array:
        if in_debug_mode: print(&#34;\nConstructing Pandas dataframe...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
        tally_Pandas_df = build_tally_Pandas_dataframe(tally_data, tally_metadata)
        if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
    else:
        tally_Pandas_df = None

    tally_output = {
        &#39;tally_data&#39;: tally_data,
        &#39;tally_metadata&#39;: tally_metadata,
        &#39;tally_dataframe&#39;: tally_Pandas_df,
    }

    if save_output_pickle:
        import pickle
        path_to_pickle_file = Path(tally_output_filepath.parent, tally_output_filepath.stem + &#39;.pickle&#39;)
        if in_debug_mode: print(&#34;\nWriting output to pickle file...   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))
        with open(path_to_pickle_file, &#39;wb&#39;) as handle:
            pickle.dump(tally_output, handle, protocol=pickle.HIGHEST_PROTOCOL)
            print(&#39;Pickle file written:&#39;, path_to_pickle_file, &#39;\n&#39;)
        if in_debug_mode: print(&#34;\tComplete!   ({:0.2f} seconds elapsed)&#34;.format(time.time() - start))

    return tally_output</code></pre>
</details>
</dd>
<dt id="PHITS_tools.parse_tally_dump_file"><code class="name flex">
<span>def <span class="ident">parse_tally_dump_file</span></span>(<span>path_to_dump_file, dump_data_number=None, dump_data_sequence=None, return_directional_info=False, use_degrees=False, max_entries_read=None, return_namedtuple_list=True, return_Pandas_dataframe=True, save_namedtuple_list=False, save_Pandas_dataframe=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Parses the dump file of a [T-Cross], [T-Product], or [T-Time] tally generated by PHITS, in ASCII or binary format.</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code>from collections import namedtuple</code></li>
<li><code>from scipy.io import FortranFile</code></li>
<li><code>import pandas as pd</code> (if <code>return_Pandas_dataframe = True</code>)</li>
<li><code>import dill</code> (if <code>save_namedtuple_list = True</code>)</li>
</ul>
<h2 id="inputs">Inputs</h2>
<p>(required)</p>
<ul>
<li><code>path_to_dump_file</code> = string or Path object denoting the path to the dump tally output file to be parsed</li>
<li><code>dump_data_number</code> = integer number of data per row in dump file, binary if &gt;0 and ASCII if &lt;0.
This should match the value following <code>dump=</code> in the tally creating the dump file. (D=<code>None</code>)
If not specified, the search_for_dump_parameters() function will attempt to find it automatically.</li>
<li><code>dump_data_sequence</code> = string or list of integers with the same number of entries as <code>dump_data_number</code>,
mapping each column in the dump file to their physical quantities.
(D=<code>None</code>)
This should match the line following the <code>dump=</code> line in the tally creating the dump file.
See PHITS manual section "6.7.22 dump parameter" for further explanations of these values.
If not specified, the search_for_dump_parameters() function will attempt to find it automatically.</li>
</ul>
<h2 id="inputs_1">Inputs</h2>
<p>(optional)</p>
<ul>
<li><code>return_directional_info</code> = (optional, D=<code>False</code>) Boolean designating whether extra directional information
should be calculated and returned; these include: radial distance <code>r</code> from the origin in cm,
radial distance <code>rho</code> from the z-axis in cm,
polar angle <code>theta</code> between the direction vector and z-axis in radians [0,pi] (or degrees), and
azimuthal angle <code>phi</code> of the direction vector in radians [-pi,pi] (or degrees).
Note: This option requires all position and direction values [x,y,z,u,v,w] to be included in the dump file.</li>
<li><code>use_degrees</code> = (optional, D=<code>False</code>) Boolean designating whether angles <code>theta</code> and <code>phi</code> are returned
in units of degrees. Default setting is to return angles in radians.</li>
<li><code>max_entries_read</code> = (optional, D=<code>None</code>) integer number specifying the maximum number of entries/records
of the dump file to be read.
By default, all records in the dump file are read.</li>
<li><code>return_namedtuple_list</code> = (optional, D=<code>True</code>) Boolean designating whether <code>dump_data_list</code> is returned.</li>
<li><code>return_Pandas_dataframe</code> = (optional, D=<code>True</code>) Boolean designating whether <code>dump_data_frame</code> is returned.</li>
<li><code>save_namedtuple_list</code> = (optional, D=<code>False</code>) Boolean designating whether <code>dump_data_list</code> is saved to a dill file
(for complicated reasons, objects containing namedtuples cannot be easily saved with pickle but can with dill).</li>
<li><code>save_Pandas_dataframe</code> = (optional, D=<code>False</code>) Boolean designating whether <code>dump_data_frame</code> is saved to a pickle
file (via Pandas .to_pickle()).</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>dump_data_list</code> = List of length equal to the number of records contained in the file. Each entry in the list
is a namedtuple containing all of the physical information in the dump file for a given particle event,
in the same order as specified in <code>dump_data_sequence</code> and using the same naming conventions for keys as
described in the PHITS manual section "6.7.22 dump parameter". If <code>return_directional_info = True</code>,
<code>r</code>, <code>rho</code>, <code>theta</code>, and <code>phi</code> are appended to the end of this namedtuple, in that order.</li>
<li><code>dump_data_frame</code> = A Pandas dataframe created from <code>dump_data_list</code> with columns for each physical quantity
and rows for each record included in the dump file.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_tally_dump_file(path_to_dump_file, dump_data_number=None , dump_data_sequence=None, return_directional_info=False,
                          use_degrees=False,max_entries_read=None,return_namedtuple_list=True,
                          return_Pandas_dataframe=True, save_namedtuple_list=False, save_Pandas_dataframe=False):
    &#39;&#39;&#39;
    Description:
        Parses the dump file of a [T-Cross], [T-Product], or [T-Time] tally generated by PHITS, in ASCII or binary format.

    Dependencies:
        - `from collections import namedtuple`
        - `from scipy.io import FortranFile`
        - `import pandas as pd` (if `return_Pandas_dataframe = True`)
        - `import dill` (if `save_namedtuple_list = True`)

    Inputs:
       (required)

        - `path_to_dump_file` = string or Path object denoting the path to the dump tally output file to be parsed
        - `dump_data_number` = integer number of data per row in dump file, binary if &gt;0 and ASCII if &lt;0.
                 This should match the value following `dump=` in the tally creating the dump file. (D=`None`)
                 If not specified, the search_for_dump_parameters() function will attempt to find it automatically.
        - `dump_data_sequence` = string or list of integers with the same number of entries as `dump_data_number`,
                 mapping each column in the dump file to their physical quantities.  (D=`None`)
                 This should match the line following the `dump=` line in the tally creating the dump file.
                 See PHITS manual section &#34;6.7.22 dump parameter&#34; for further explanations of these values.
                 If not specified, the search_for_dump_parameters() function will attempt to find it automatically.

    Inputs:
       (optional)

        - `return_directional_info` = (optional, D=`False`) Boolean designating whether extra directional information
                 should be calculated and returned; these include: radial distance `r` from the origin in cm,
                 radial distance `rho` from the z-axis in cm,
                 polar angle `theta` between the direction vector and z-axis in radians [0,pi] (or degrees), and
                 azimuthal angle `phi` of the direction vector in radians [-pi,pi] (or degrees).
                 Note: This option requires all position and direction values [x,y,z,u,v,w] to be included in the dump file.
        - `use_degrees` = (optional, D=`False`) Boolean designating whether angles `theta` and `phi` are returned
                 in units of degrees. Default setting is to return angles in radians.
        - `max_entries_read` = (optional, D=`None`) integer number specifying the maximum number of entries/records
                 of the dump file to be read.  By default, all records in the dump file are read.
        - `return_namedtuple_list` = (optional, D=`True`) Boolean designating whether `dump_data_list` is returned.
        - `return_Pandas_dataframe` = (optional, D=`True`) Boolean designating whether `dump_data_frame` is returned.
        - `save_namedtuple_list` = (optional, D=`False`) Boolean designating whether `dump_data_list` is saved to a dill file
                (for complicated reasons, objects containing namedtuples cannot be easily saved with pickle but can with dill).
        - `save_Pandas_dataframe` = (optional, D=`False`) Boolean designating whether `dump_data_frame` is saved to a pickle
                file (via Pandas .to_pickle()).

    Outputs:
        - `dump_data_list` = List of length equal to the number of records contained in the file. Each entry in the list
                 is a namedtuple containing all of the physical information in the dump file for a given particle event,
                 in the same order as specified in `dump_data_sequence` and using the same naming conventions for keys as
                 described in the PHITS manual section &#34;6.7.22 dump parameter&#34;. If `return_directional_info = True`,
                 `r`, `rho`, `theta`, and `phi` are appended to the end of this namedtuple, in that order.
        - `dump_data_frame` = A Pandas dataframe created from `dump_data_list` with columns for each physical quantity
                 and rows for each record included in the dump file.
    &#39;&#39;&#39;

    from collections import namedtuple
    from typing import NamedTuple
    from scipy.io import FortranFile
    if return_Pandas_dataframe:
        import pandas as pd
    if save_Pandas_dataframe or save_namedtuple_list:
        #import pickle
        import dill

    if not return_namedtuple_list and not return_Pandas_dataframe and not save_namedtuple_list and not save_Pandas_dataframe:
        print(&#39;ERROR: All &#34;return_namedtuple_list&#34;, &#34;return_Pandas_dataframe&#34;, &#34;save_namedtuple_list&#34;, and &#34;save_Pandas_dataframe&#34; are False. Enable at least one to use this function.&#39;)
        sys.exit()

    if dump_data_number == None or dump_data_sequence == None:
        dump_data_number, dump_data_sequence = search_for_dump_parameters(path_to_dump_file)
    if dump_data_number == None or dump_data_sequence == None:
        print(&#34;Please manually specify &#39;dump_data_number&#39; and &#39;dump_data_sequence&#39;; these were not inputted and could not be automatically found from an origin tally standard output file.&#34;)
        return None

    if isinstance(dump_data_sequence, str):
        dump_data_sequence = dump_data_sequence.split()
        dump_data_sequence = [int(i) for i in dump_data_sequence]
    dump_file_is_binary = True if (dump_data_number &gt; 0) else False  # if not binary, file will be ASCII
    data_values_per_line = abs(dump_data_number)
    if data_values_per_line != len(dump_data_sequence):
        print(&#39;ERROR: Number of values in &#34;dump_data_sequence&#34; is not equal to &#34;dump_data_number&#34;&#39;)
        sys.exit()

    # Generate NamedTuple for storing record information
    # See PHITS manual section &#34;6.7.22 dump parameter&#34; for descriptions of these values
    dump_quantities = [&#39;kf&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;e&#39;, &#39;wt&#39;, &#39;time&#39;, &#39;c1&#39;, &#39;c2&#39;, &#39;c3&#39;, &#39;sx&#39;, &#39;sy&#39;, &#39;sz&#39;,
                       &#39;name&#39;, &#39;nocas&#39;, &#39;nobch&#39;, &#39;no&#39;]
    ordered_record_entries_list = [dump_quantities[i - 1] for i in dump_data_sequence]
    rawRecord = namedtuple(&#39;rawRecord&#39;, ordered_record_entries_list)
    if return_directional_info:
        ordered_record_entries_list += [&#39;r&#39;, &#39;rho&#39;, &#39;theta&#39;, &#39;phi&#39;]
        angle_units_mult = 1
        if use_degrees: angle_units_mult = 180 / np.pi
    Record = namedtuple(&#39;Record&#39;, ordered_record_entries_list)

    records_list = []
    if dump_file_is_binary:
        # Read binary dump file; extract each record (particle)
        file_size_bytes = os.path.getsize(path_to_dump_file)
        record_size_bytes = (data_values_per_line + 1) * 8  # each record has 8 bytes per data value plus an 8-byte record end
        num_records = int(file_size_bytes / record_size_bytes)
        if max_entries_read != None:
            if max_entries_read &lt; num_records:
                num_records = max_entries_read
        # print(num_records)
        current_record_count = 0
        if return_directional_info:
            with FortranFile(path_to_dump_file, &#39;r&#39;) as f:
                while current_record_count &lt; num_records:
                    current_record_count += 1
                    raw_values = f.read_reals(float)
                    rawrecord = rawRecord(*raw_values)
                    # calculate r, rho, theta (w.r.t. z-axis), and phi (w.r.t. x axis)
                    r = np.sqrt(rawrecord.x ** 2 + rawrecord.y ** 2 + rawrecord.z ** 2)
                    rho = np.sqrt(rawrecord.x ** 2 + rawrecord.y ** 2)
                    dir_vector = [rawrecord.u, rawrecord.v, rawrecord.w]
                    theta = np.arccos(np.clip(np.dot(dir_vector, [0, 0, 1]), -1.0, 1.0)) * angle_units_mult
                    phi = np.arctan2(rawrecord.y, rawrecord.x) * angle_units_mult
                    record = Record(*raw_values, r, rho, theta, phi)
                    records_list.append(record)
        else: # just return data in dump file
            with FortranFile(path_to_dump_file, &#39;r&#39;) as f:
                while current_record_count &lt; num_records:
                    current_record_count += 1
                    raw_values = f.read_reals(float)
                    record = Record(*raw_values)
                    records_list.append(record)
    else: # file is ASCII
        if max_entries_read == None:
            max_entries_read = np.inf
        if return_directional_info:
            with open(path_to_dump_file, &#39;r&#39;) as f:
                current_record_count = 0
                for line in f:
                    current_record_count += 1
                    if current_record_count &gt; max_entries_read: break
                    line_str_values = line.replace(&#39;D&#39;, &#39;E&#39;).split()
                    raw_values = [float(i) for i in line_str_values]
                    rawrecord = rawRecord(*raw_values)
                    # calculate r, rho, theta (w.r.t. z-axis), and phi (w.r.t. x axis)
                    r = np.sqrt(rawrecord.x ** 2 + rawrecord.y ** 2 + rawrecord.z ** 2)
                    rho = np.sqrt(rawrecord.x ** 2 + rawrecord.y ** 2)
                    dir_vector = [rawrecord.u, rawrecord.v, rawrecord.w]
                    theta = np.arccos(np.clip(np.dot(dir_vector, [0, 0, 1]), -1.0, 1.0)) * angle_units_mult
                    phi = np.arctan2(rawrecord.y, rawrecord.x) * angle_units_mult
                    record = Record(*raw_values, r, theta, phi)
                    records_list.append(record)
        else: # just return data in dump file
            with open(path_to_dump_file, &#39;r&#39;) as f:
                current_record_count = 0
                for line in f:
                    current_record_count += 1
                    if current_record_count &gt; max_entries_read: break
                    line_str_values = line.replace(&#39;D&#39;, &#39;E&#39;).split()
                    raw_values = [float(i) for i in line_str_values]
                    record = Record(*raw_values)
                    records_list.append(record)
    #print(record)

    if save_namedtuple_list:
        path_to_dump_file = Path(path_to_dump_file)
        pickle_path = Path(path_to_dump_file.parent, path_to_dump_file.stem + &#39;_namedtuple_list.dill&#39;)
        with open(pickle_path, &#39;wb&#39;) as handle:
            dill.dump(records_list, handle, protocol=dill.HIGHEST_PROTOCOL)
            print(&#39;Pickle file written:&#39;, pickle_path, &#39;\n&#39;)

    if return_Pandas_dataframe or save_Pandas_dataframe:
        # Make Pandas dataframe from list of records
        records_df = pd.DataFrame(records_list, columns=Record._fields)
        if save_Pandas_dataframe:
            path_to_dump_file= Path(path_to_dump_file)
            pickle_path = Path(path_to_dump_file.parent, path_to_dump_file.stem + &#39;_Pandas_df.pickle&#39;)
            records_df.to_pickle(pickle_path)
            #with open(pickle_path, &#39;wb&#39;) as handle:
            #    pickle.dump(records_df, handle, protocol=pickle.HIGHEST_PROTOCOL)
            #    print(&#39;Pickle file written:&#39;, pickle_path, &#39;\n&#39;)

    if return_namedtuple_list and return_Pandas_dataframe:
        return records_list, records_df
    elif return_namedtuple_list:
        return records_list
    elif return_Pandas_dataframe:
        return records_df
    else:
        return None</code></pre>
</details>
</dd>
<dt id="PHITS_tools.parse_all_tally_output_in_dir"><code class="name flex">
<span>def <span class="ident">parse_all_tally_output_in_dir</span></span>(<span>tally_output_dirpath, output_file_suffix='.out', output_file_prefix='', output_file_required_string='', include_subdirectories=False, return_tally_output=False, make_PandasDF=True, calculate_absolute_errors=True, save_output_pickle=True, prefer_reading_existing_pickle=False, include_dump_files=False, dump_data_number=None, dump_data_sequence=None, dump_return_directional_info=False, dump_use_degrees=False, dump_max_entries_read=None, dump_save_namedtuple_list=True, dump_save_Pandas_dataframe=True)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Parse all standard PHITS tally output files in a directory, returning either a list of dictionaries containing
tally metadata and an array of values from each tally output (and optionally this data inside of a Pandas dataframe too)
or a list of filepaths to pickle files containing these dictionaries, as created with the <code><a title="PHITS_tools.parse_tally_output_file" href="#PHITS_tools.parse_tally_output_file">parse_tally_output_file()</a></code> function.
This function allows selective processing of files in the directory by specification of strings which must
appear at the start, end, and/or anywhere within each filename.
Even if a file satisfies all of these naming criteria, the function will also check the first line of the file
to determine if it is a valid tally output file (meaning, it will skip files such as phits.out and batch.out).
It will also skip over "_err" uncertainty files as these are automatically found by the <code><a title="PHITS_tools.parse_tally_output_file" href="#PHITS_tools.parse_tally_output_file">parse_tally_output_file()</a></code>
function after it processes that tally's main output file.
This function will mainly process standard tally output files, but it can optionally process tally "dump" files too,
though it can only save the dump outputs to its dill/pickle files and not return the (quite large) dump data objects.
The filenames of saved dump data will not be included in the returned list.</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code>import os</code></li>
<li><code>import numpy as np</code></li>
<li><code>import pandas as pd</code> (if <code>make_PandasDF = True</code>)</li>
<li><code>import pickle</code> (if <code>save_output_pickle = True</code>)</li>
<li><code>from munch import *</code></li>
<li><code>from pathlib import Path</code></li>
</ul>
<h2 id="inputs">Inputs</h2>
<p>(required)</p>
<ul>
<li><code>tally_output_dirpath</code> = Path (string or path object) to the tally output directory to be searched and parsed</li>
</ul>
<h2 id="inputs_1">Inputs</h2>
<p>(optional)</p>
<ul>
<li><code>output_file_suffix</code> = A string specifying what characters processed filenames (including the file extension)
must end in to be included.
This condition is not enforced if set to an empty string <code>''</code>. (D=<code>'.out'</code>)</li>
<li><code>output_file_prefix</code> = A string specifying what characters processed filenames (including the file extension)
must begin with to be included.
This condition is not enforced if set to an empty string <code>''</code>. (D=<code>''</code>)</li>
<li><code>output_file_required_string</code> = A string which must be present anywhere within processed filenames (including the
file extension) to be included.
This condition is not enforced if set to an empty string <code>''</code>. (D=<code>''</code>)</li>
<li><code>include_subdirectories</code> = A Boolean determining whether this function searches and processes all included
tally output files in this directory AND deeper subdirectories if set to <code>True</code>
or only the files directly within the provided directory <code>tally_output_dirpath</code> if set to <code>False</code> (D=<code>False</code>)</li>
<li><code>return_tally_output</code> = A Boolean determining whether this function returns a list of <code>tally_output</code> dictionaries
if set to <code>True</code> or just a list of filepaths to the pickle files containing these dictionaries
if set to <code>False</code> (D=<code>False</code>)</li>
<li><code>include_dump_files</code> = A Boolean determining whether dump files will be processed too or skipped. (D=<code>False</code>)
Settings to be applied to all encountered dump files can be specified per the optional inputs
detailed below which are simply passed to the <code><a title="PHITS_tools.parse_tally_dump_file" href="#PHITS_tools.parse_tally_dump_file">parse_tally_dump_file()</a></code> function.
Note that parameters
<code>return_namedtuple_list</code> and <code>return_Pandas_dataframe</code> will always be <code>False</code> when dump files are
processed in a directory with this function; instead, <code>save_namedtuple_list</code> and <code>save_Pandas_dataframe</code>
are by default set to <code>True</code> when parsing dump files in a directory with this function.
(Be warned,
if the dump file is large, the produced files from parsing them will be too.)</li>
</ul>
<h2 id="inputs_2">Inputs</h2>
<p>(optional, the same as in and directly passed to the <code><a title="PHITS_tools.parse_tally_output_file" href="#PHITS_tools.parse_tally_output_file">parse_tally_output_file()</a></code> function)</p>
<ul>
<li><code>make_PandasDF</code> = A Boolean determining whether a Pandas dataframe of the tally data array will be made (D=<code>True</code>)</li>
<li><code>calculate_absolute_errors</code> = A Boolean determining whether the absolute uncertainty of each tally output value
is to be calculated (simply as the product of the value and relative error); if <code>False</code>, the final
dimension of <code>tally_data</code>, <code>ierr</code>, will be of length-2 rather than length-3 (D=<code>True</code>)</li>
<li><code>save_output_pickle</code> = A Boolean determining whether the <code>tally_output</code> dictionary object is saved as a pickle file;
if <code>True</code>, the file will be saved with the same path and name as the provided PHITS tally output file
but with the .pickle extension. (D=<code>True</code>)</li>
<li><code>prefer_reading_existing_pickle</code> = A Boolean determining what this function does if the pickle file this function
seeks to generate already exists.
If <code>False</code> (default behavior), this function will parse the PHITS
output files as usual and overwrite the existing pickle file.
If <code>True</code>, this function will instead
simply just read the existing found pickle file and return its stored <code>tally_output</code> contents. (D=<code>False</code>)</li>
</ul>
<h2 id="inputs_3">Inputs</h2>
<p>(optional, the same as in and directly passed to the <code><a title="PHITS_tools.parse_tally_dump_file" href="#PHITS_tools.parse_tally_dump_file">parse_tally_dump_file()</a></code> function)</p>
<ul>
<li><code>dump_data_number</code> = integer number of data per row in dump file, binary if &gt;0 and ASCII if &lt;0.
This should match the value following <code>dump=</code> in the tally creating the dump file. (D=<code>None</code>)
If not specified, the search_for_dump_parameters() function will attempt to find it automatically.</li>
<li><code>dump_data_sequence</code> = string or list of integers with the same number of entries as <code>dump_data_number</code>,
mapping each column in the dump file to their physical quantities.
(D=<code>None</code>)
This should match the line following the <code>dump=</code> line in the tally creating the dump file.
See PHITS manual section "6.7.22 dump parameter" for further explanations of these values.
If not specified, the search_for_dump_parameters() function will attempt to find it automatically.</li>
<li><code>dump_return_directional_info</code> = (optional, D=<code>False</code>) Boolean designating whether extra directional information
should be calculated and returned; these include: radial distance <code>r</code> from the origin in cm,
radial distance <code>rho</code> from the z-axis in cm,
polar angle <code>theta</code> between the direction vector and z-axis in radians [0,pi] (or degrees), and
azimuthal angle <code>phi</code> of the direction vector in radians [-pi,pi] (or degrees).
Note: This option requires all position and direction values [x,y,z,u,v,w] to be included in the dump file.</li>
<li><code>dump_use_degrees</code> = (optional, D=<code>False</code>) Boolean designating whether angles <code>theta</code> and <code>phi</code> are returned
in units of degrees. Default setting is to return angles in radians.</li>
<li><code>dump_max_entries_read</code> = (optional, D=<code>None</code>) integer number specifying the maximum number of entries/records
of the dump file to be read.
By default, all records in the dump file are read.</li>
<li><code>dump_save_namedtuple_list</code> = (optional, D=<code>True</code>) Boolean designating whether <code>dump_data_list</code> is saved to a dill file
(for complicated reasons, objects containing namedtuples cannot be easily saved with pickle but can with dill).</li>
<li><code>dump_save_Pandas_dataframe</code> = (optional, D=<code>True</code>) Boolean designating whether <code>dump_data_frame</code> is saved to a pickle
file (via Pandas .to_pickle()).</li>
</ul>
<h2 id="output">Output</h2>
<ul>
<li><code>tally_output_list</code> = a list of <code>tally_output</code> dictionary objects with the below keys and values / a list of
file paths to pickle files containing <code>tally_output</code> dictionary objects:<ul>
<li><code>'tally_data'</code> = a 10-dimensional NumPy array containing all tally results, explained in more detail below</li>
<li><code>'tally_metadata'</code> = a dictionary/Munch object with various data extracted from the tally output file, such as axis binning and units</li>
<li><code>'tally_dataframe'</code> = (optionally included if setting <code>make_PandasDF = True</code>) a Pandas dataframe version of <code>tally_data</code></li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_all_tally_output_in_dir(tally_output_dirpath, output_file_suffix = &#39;.out&#39;, output_file_prefix = &#39;&#39;,
                                  output_file_required_string=&#39;&#39;, include_subdirectories=False,  return_tally_output=False,
                                  make_PandasDF=True, calculate_absolute_errors=True,
                                  save_output_pickle=True, prefer_reading_existing_pickle=False,
                                  include_dump_files=False,
                                  dump_data_number=None , dump_data_sequence=None,
                                  dump_return_directional_info=False, dump_use_degrees=False,
                                  dump_max_entries_read=None,
                                  dump_save_namedtuple_list=True, dump_save_Pandas_dataframe=True
                                  ):
    &#39;&#39;&#39;
    Description:
        Parse all standard PHITS tally output files in a directory, returning either a list of dictionaries containing
        tally metadata and an array of values from each tally output (and optionally this data inside of a Pandas dataframe too)
        or a list of filepaths to pickle files containing these dictionaries, as created with the `parse_tally_output_file()` function.
        This function allows selective processing of files in the directory by specification of strings which must
        appear at the start, end, and/or anywhere within each filename.
        Even if a file satisfies all of these naming criteria, the function will also check the first line of the file
        to determine if it is a valid tally output file (meaning, it will skip files such as phits.out and batch.out).
        It will also skip over &#34;_err&#34; uncertainty files as these are automatically found by the `parse_tally_output_file()`
        function after it processes that tally&#39;s main output file.
        This function will mainly process standard tally output files, but it can optionally process tally &#34;dump&#34; files too,
        though it can only save the dump outputs to its dill/pickle files and not return the (quite large) dump data objects.
        The filenames of saved dump data will not be included in the returned list.

    Dependencies:
        - `import os`
        - `import numpy as np`
        - `import pandas as pd` (if `make_PandasDF = True`)
        - `import pickle` (if `save_output_pickle = True`)
        - `from munch import *`
        - `from pathlib import Path`

    Inputs:
       (required)

        - `tally_output_dirpath` = Path (string or path object) to the tally output directory to be searched and parsed

    Inputs:
       (optional)

       - `output_file_suffix` = A string specifying what characters processed filenames (including the file extension)
                      must end in to be included.  This condition is not enforced if set to an empty string `&#39;&#39;`. (D=`&#39;.out&#39;`)
       - `output_file_prefix` = A string specifying what characters processed filenames (including the file extension)
                      must begin with to be included.  This condition is not enforced if set to an empty string `&#39;&#39;`. (D=`&#39;&#39;`)
       - `output_file_required_string` = A string which must be present anywhere within processed filenames (including the
                      file extension) to be included.  This condition is not enforced if set to an empty string `&#39;&#39;`. (D=`&#39;&#39;`)
       - `include_subdirectories` = A Boolean determining whether this function searches and processes all included
                      tally output files in this directory AND deeper subdirectories if set to `True`
                      or only the files directly within the provided directory `tally_output_dirpath` if set to `False` (D=`False`)
       - `return_tally_output` = A Boolean determining whether this function returns a list of `tally_output` dictionaries
                      if set to `True` or just a list of filepaths to the pickle files containing these dictionaries
                      if set to `False` (D=`False`)
       - `include_dump_files` = A Boolean determining whether dump files will be processed too or skipped. (D=`False`)
                      Settings to be applied to all encountered dump files can be specified per the optional inputs
                      detailed below which are simply passed to the `parse_tally_dump_file()` function.  Note that parameters
                      `return_namedtuple_list` and `return_Pandas_dataframe` will always be `False` when dump files are
                      processed in a directory with this function; instead, `save_namedtuple_list` and `save_Pandas_dataframe`
                      are by default set to `True` when parsing dump files in a directory with this function.  (Be warned,
                      if the dump file is large, the produced files from parsing them will be too.)

    Inputs:
       (optional, the same as in and directly passed to the `parse_tally_output_file()` function)

       - `make_PandasDF` = A Boolean determining whether a Pandas dataframe of the tally data array will be made (D=`True`)
       - `calculate_absolute_errors` = A Boolean determining whether the absolute uncertainty of each tally output value
                      is to be calculated (simply as the product of the value and relative error); if `False`, the final
                      dimension of `tally_data`, `ierr`, will be of length-2 rather than length-3 (D=`True`)
       - `save_output_pickle` = A Boolean determining whether the `tally_output` dictionary object is saved as a pickle file;
                      if `True`, the file will be saved with the same path and name as the provided PHITS tally output file
                      but with the .pickle extension. (D=`True`)
       - `prefer_reading_existing_pickle` = A Boolean determining what this function does if the pickle file this function
                      seeks to generate already exists.  If `False` (default behavior), this function will parse the PHITS
                      output files as usual and overwrite the existing pickle file.  If `True`, this function will instead
                      simply just read the existing found pickle file and return its stored `tally_output` contents. (D=`False`)

    Inputs:
       (optional, the same as in and directly passed to the `parse_tally_dump_file()` function)

       - `dump_data_number` = integer number of data per row in dump file, binary if &gt;0 and ASCII if &lt;0.
                This should match the value following `dump=` in the tally creating the dump file. (D=`None`)
                If not specified, the search_for_dump_parameters() function will attempt to find it automatically.
       - `dump_data_sequence` = string or list of integers with the same number of entries as `dump_data_number`,
                mapping each column in the dump file to their physical quantities.  (D=`None`)
                This should match the line following the `dump=` line in the tally creating the dump file.
                See PHITS manual section &#34;6.7.22 dump parameter&#34; for further explanations of these values.
                If not specified, the search_for_dump_parameters() function will attempt to find it automatically.
       - `dump_return_directional_info` = (optional, D=`False`) Boolean designating whether extra directional information
                should be calculated and returned; these include: radial distance `r` from the origin in cm,
                radial distance `rho` from the z-axis in cm,
                polar angle `theta` between the direction vector and z-axis in radians [0,pi] (or degrees), and
                azimuthal angle `phi` of the direction vector in radians [-pi,pi] (or degrees).
                Note: This option requires all position and direction values [x,y,z,u,v,w] to be included in the dump file.
       - `dump_use_degrees` = (optional, D=`False`) Boolean designating whether angles `theta` and `phi` are returned
                in units of degrees. Default setting is to return angles in radians.
       - `dump_max_entries_read` = (optional, D=`None`) integer number specifying the maximum number of entries/records
                of the dump file to be read.  By default, all records in the dump file are read.
       - `dump_save_namedtuple_list` = (optional, D=`True`) Boolean designating whether `dump_data_list` is saved to a dill file
               (for complicated reasons, objects containing namedtuples cannot be easily saved with pickle but can with dill).
       - `dump_save_Pandas_dataframe` = (optional, D=`True`) Boolean designating whether `dump_data_frame` is saved to a pickle
               file (via Pandas .to_pickle()).

    Output:
        - `tally_output_list` = a list of `tally_output` dictionary objects with the below keys and values / a list of
             file paths to pickle files containing `tally_output` dictionary objects:
            - `&#39;tally_data&#39;` = a 10-dimensional NumPy array containing all tally results, explained in more detail below
            - `&#39;tally_metadata&#39;` = a dictionary/Munch object with various data extracted from the tally output file, such as axis binning and units
            - `&#39;tally_dataframe&#39;` = (optionally included if setting `make_PandasDF = True`) a Pandas dataframe version of `tally_data`

    &#39;&#39;&#39;
    import os

    if not os.path.isdir(tally_output_dirpath):
        print(&#39;The provided path to &#34;tally_output_dir&#34; is not a directory:&#39;,tally_output_dirpath)
        if os.path.isfile(tally_output_dirpath):
            head, tail = os.path.split(tally_output_dirpath)
            tally_output_dirpath = head
            print(&#39;However, it is a valid path to a file; thus, its parent directory will be used:&#39;,tally_output_dirpath)
        else:
            print(&#39;Nor is it a valid path to a file. ERROR! Aborting...&#39;)
            return None

    if include_subdirectories:
        # Get paths to all files in this dir and subdirs
        files_in_dir = []
        for path, subdirs, files in os.walk(tally_output_dirpath):
            for name in files:
                files_in_dir.append(os.path.join(path, name))
    else:
        # Just get paths to files in this dir
        files_in_dir = [os.path.join(tally_output_dirpath, f) for f in os.listdir(tally_output_dirpath) if os.path.isfile(os.path.join(tally_output_dirpath, f))]

    # Determine which files should be parsed
    filepaths_to_process = []
    dump_filepaths_to_process = []
    len_suffix = len(output_file_suffix)
    len_prefix = len(output_file_prefix)
    len_reqstr = len(output_file_required_string)
    for f in files_in_dir:
        head, tail = os.path.split(f)
        if len_suffix &gt; 0 and tail[-len_suffix:] != output_file_suffix: continue
        if len_prefix &gt; 0 and tail[:len_prefix] != output_file_prefix: continue
        if len_reqstr &gt; 0 and output_file_required_string not in tail: continue
        if tail[(-4-len_suffix):] == &#39;_err&#39; + output_file_suffix: continue
        with open(f) as ff:
            try:
                first_line = ff.readline().strip()
            except: # triggered if encountering binary / non ASCII or UTF-8 file
                if include_dump_files and tail[(-4-len_suffix):] == &#39;_dmp&#39; + output_file_suffix:
                    dump_filepaths_to_process.append(f)
                continue
            if len(first_line) == 0: continue
            if first_line[0] != &#39;[&#39; :
                if include_dump_files and tail[(-4-len_suffix):] == &#39;_dmp&#39; + output_file_suffix:
                    dump_filepaths_to_process.append(f)
                continue
        filepaths_to_process.append(f)

    tally_output_pickle_path_list = []
    tally_output_list = []
    for f in filepaths_to_process:
        f = Path(f)
        path_to_pickle_file = Path(f.parent, f.stem + &#39;.pickle&#39;)
        tally_output_pickle_path_list.append(path_to_pickle_file)
        tally_output = parse_tally_output_file(f, make_PandasDF=make_PandasDF,
                                               calculate_absolute_errors=calculate_absolute_errors,
                                               save_output_pickle=save_output_pickle,
                                               prefer_reading_existing_pickle=prefer_reading_existing_pickle)
        if return_tally_output: tally_output_list.append(tally_output)

    if include_dump_files:
        for f in dump_filepaths_to_process:
            f = Path(f)
            parse_tally_dump_file(f, dump_data_number=dump_data_number, dump_data_sequence=dump_data_number,
                                  return_directional_info=dump_return_directional_info, use_degrees=dump_use_degrees,
                                  max_entries_read=dump_max_entries_read,
                                  return_namedtuple_list=False, return_Pandas_dataframe=False,
                                  save_namedtuple_list=dump_save_namedtuple_list,
                                  save_Pandas_dataframe=dump_save_Pandas_dataframe)

    if return_tally_output:
        return tally_output_list
    else:
        return tally_output_pickle_path_list</code></pre>
</details>
</dd>
<dt id="PHITS_tools.is_number"><code class="name flex">
<span>def <span class="ident">is_number</span></span>(<span>n)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Determine if a string is that of a number or not.</p>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>n</code> = string to be tested</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>True</code> if value is a number (can be converted to float() without an error)</li>
<li><code>False</code> otherwise</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_number(n):
    &#39;&#39;&#39;
    Description:
        Determine if a string is that of a number or not.

    Inputs:
        - `n` = string to be tested

    Outputs:
        - `True` if value is a number (can be converted to float() without an error)
        - `False` otherwise
    &#39;&#39;&#39;
    try:
        float(n)
    except ValueError:
        return False
    return True</code></pre>
</details>
</dd>
<dt id="PHITS_tools.ZZZAAAM_to_nuclide_plain_str"><code class="name flex">
<span>def <span class="ident">ZZZAAAM_to_nuclide_plain_str</span></span>(<span>ZZZAAAM, include_Z=False, ZZZAAA=False, delimiter='-')</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Converts a plaintext string of a nuclide to an integer ZZZAAAM = 10000*Z + 10*A + M</p>
<h2 id="dependencies">Dependencies</h2>
<p><code><a title="PHITS_tools.Element_Z_to_Sym" href="#PHITS_tools.Element_Z_to_Sym">Element_Z_to_Sym()</a></code> (function within the "Hunter's tools" package)</p>
<h2 id="input">Input</h2>
<ul>
<li><code>ZZZAAAM</code> = integer equal to 10000<em>Z + 10</em>A + M, where M designates the metastable state (0=ground)</li>
<li><code>include_Z</code> = Boolean denoting whether the Z number should be included in the output string (D=<code>False</code>)</li>
<li><code>ZZZAAA</code> = Boolean denoting whether the input should be interpreted as a ZZZAAA value (1000Z+A) instead (D=<code>False</code>)</li>
<li><code>delimiter</code> = string which will be used to separate elements of the output string (D=<code>-</code>)</li>
</ul>
<h2 id="output">Output</h2>
<ul>
<li><code>nuc_str</code> = string describing the input nuclide formatted as [Z]-[Symbol]-[A][m]</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ZZZAAAM_to_nuclide_plain_str(ZZZAAAM,include_Z=False,ZZZAAA=False,delimiter=&#39;-&#39;):
    &#39;&#39;&#39;
    Description:
        Converts a plaintext string of a nuclide to an integer ZZZAAAM = 10000\*Z + 10\*A + M

    Dependencies:
        `Element_Z_to_Sym` (function within the &#34;Hunter&#39;s tools&#34; package)

    Input:
       - `ZZZAAAM` = integer equal to 10000*Z + 10*A + M, where M designates the metastable state (0=ground)
       - `include_Z` = Boolean denoting whether the Z number should be included in the output string (D=`False`)
       - `ZZZAAA` = Boolean denoting whether the input should be interpreted as a ZZZAAA value (1000Z+A) instead (D=`False`)
       - `delimiter` = string which will be used to separate elements of the output string (D=`-`)

    Output:
       - `nuc_str` = string describing the input nuclide formatted as [Z]-[Symbol]-[A][m]
    &#39;&#39;&#39;
    ZZZAAAM = int(ZZZAAAM)
    if ZZZAAA:
        ZZZAAAM = ZZZAAAM*10
    m = ZZZAAAM % 10
    A = (ZZZAAAM % 10000) // 10
    Z = ZZZAAAM // 10000
    symbol = Element_Z_to_Sym(Z)

    m_str = &#39;&#39;
    if m&gt;0:
        m_str = &#39;m&#39; + str(m)

    nuc_str = &#39;&#39;
    if include_Z:
        nuc_str += str(Z) + delimiter
    nuc_str += symbol + delimiter + str(A) + m_str

    return nuc_str</code></pre>
</details>
</dd>
<dt id="PHITS_tools.Element_Z_to_Sym"><code class="name flex">
<span>def <span class="ident">Element_Z_to_Sym</span></span>(<span>Z)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Returns elemental symbol for a provided atomic number Z</p>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>Z</code> = atomic number</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>sym</code> = string of elemental symbol for element of atomic number Z</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Element_Z_to_Sym(Z):
    &#39;&#39;&#39;
    Description:
        Returns elemental symbol for a provided atomic number Z

    Inputs:
        - `Z` = atomic number

    Outputs:
        - `sym` = string of elemental symbol for element of atomic number Z
    &#39;&#39;&#39;
    elms = [&#34;n &#34;,\
            &#34;H &#34;,&#34;He&#34;,&#34;Li&#34;,&#34;Be&#34;,&#34;B &#34;,&#34;C &#34;,&#34;N &#34;,&#34;O &#34;,&#34;F &#34;,&#34;Ne&#34;,\
            &#34;Na&#34;,&#34;Mg&#34;,&#34;Al&#34;,&#34;Si&#34;,&#34;P &#34;,&#34;S &#34;,&#34;Cl&#34;,&#34;Ar&#34;,&#34;K &#34;,&#34;Ca&#34;,\
            &#34;Sc&#34;,&#34;Ti&#34;,&#34;V &#34;,&#34;Cr&#34;,&#34;Mn&#34;,&#34;Fe&#34;,&#34;Co&#34;,&#34;Ni&#34;,&#34;Cu&#34;,&#34;Zn&#34;,\
            &#34;Ga&#34;,&#34;Ge&#34;,&#34;As&#34;,&#34;Se&#34;,&#34;Br&#34;,&#34;Kr&#34;,&#34;Rb&#34;,&#34;Sr&#34;,&#34;Y &#34;,&#34;Zr&#34;,\
            &#34;Nb&#34;,&#34;Mo&#34;,&#34;Tc&#34;,&#34;Ru&#34;,&#34;Rh&#34;,&#34;Pd&#34;,&#34;Ag&#34;,&#34;Cd&#34;,&#34;In&#34;,&#34;Sn&#34;,\
            &#34;Sb&#34;,&#34;Te&#34;,&#34;I &#34;,&#34;Xe&#34;,&#34;Cs&#34;,&#34;Ba&#34;,&#34;La&#34;,&#34;Ce&#34;,&#34;Pr&#34;,&#34;Nd&#34;,\
            &#34;Pm&#34;,&#34;Sm&#34;,&#34;Eu&#34;,&#34;Gd&#34;,&#34;Tb&#34;,&#34;Dy&#34;,&#34;Ho&#34;,&#34;Er&#34;,&#34;Tm&#34;,&#34;Yb&#34;,\
            &#34;Lu&#34;,&#34;Hf&#34;,&#34;Ta&#34;,&#34;W &#34;,&#34;Re&#34;,&#34;Os&#34;,&#34;Ir&#34;,&#34;Pt&#34;,&#34;Au&#34;,&#34;Hg&#34;,\
            &#34;Tl&#34;,&#34;Pb&#34;,&#34;Bi&#34;,&#34;Po&#34;,&#34;At&#34;,&#34;Rn&#34;,&#34;Fr&#34;,&#34;Ra&#34;,&#34;Ac&#34;,&#34;Th&#34;,\
            &#34;Pa&#34;,&#34;U &#34;,&#34;Np&#34;,&#34;Pu&#34;,&#34;Am&#34;,&#34;Cm&#34;,&#34;Bk&#34;,&#34;Cf&#34;,&#34;Es&#34;,&#34;Fm&#34;,\
            &#34;Md&#34;,&#34;No&#34;,&#34;Lr&#34;,&#34;Rf&#34;,&#34;Db&#34;,&#34;Sg&#34;,&#34;Bh&#34;,&#34;Hs&#34;,&#34;Mt&#34;,&#34;Ds&#34;,\
            &#34;Rg&#34;,&#34;Cn&#34;,&#34;Nh&#34;,&#34;Fl&#34;,&#34;Mc&#34;,&#34;Lv&#34;,&#34;Ts&#34;,&#34;Og&#34;]
    i = int(Z)
    if i &lt; 0 or i &gt; len(elms):
        print(&#39;Z={} is not valid, please select a number from 0 to 118 (inclusive).&#39;.format(str(Z)))
        return None
    return elms[i].strip()</code></pre>
</details>
</dd>
<dt id="PHITS_tools.split_into_header_and_content"><code class="name flex">
<span>def <span class="ident">split_into_header_and_content</span></span>(<span>output_file_path)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Initial parsing of a PHITS tally output file to isolate its header section (containing metadata) and main
tally results "content" section for later processing.</p>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>output_file_path</code> = path to a PHITS tally output file</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>header</code> = list of lines belonging to the tally output's header section</li>
<li><code>content</code> = list of lists of remaining lines after the tally output's header section; the top level list is
broken into "blocks" ("newpage:"-separated) which are lists of lines belonging to each block/page.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_into_header_and_content(output_file_path):
    &#39;&#39;&#39;
    Description:
        Initial parsing of a PHITS tally output file to isolate its header section (containing metadata) and main
        tally results &#34;content&#34; section for later processing.

    Inputs:
        - `output_file_path` = path to a PHITS tally output file

    Outputs:
        - `header` = list of lines belonging to the tally output&#39;s header section
        - `content` = list of lists of remaining lines after the tally output&#39;s header section; the top level list is
                broken into &#34;blocks&#34; (&#34;newpage:&#34;-separated) which are lists of lines belonging to each block/page.

    &#39;&#39;&#39;
    in_content = False
    header, content = [], [[]]
    with open(output_file_path, mode=&#39;rb&#39;) as f:
        for line in f:
            if b&#39;\x00&#39; in line:
                line = line.replace(b&#34;\x00&#34;, b&#34;&#34;)
            line = line.decode()
            #if &#34;\x00&#34; in line: line = line.replace(&#34;\x00&#34;, &#34;&#34;)
            if &#39;#newpage:&#39; in line:
                in_content = True
                continue
            if in_content:
                if &#39;newpage:&#39; in line:
                    content.append([])
                    continue
                content[-1].append(line.strip())
            else:
                header.append(line.strip())
    # add &#34;footer&#34; to peel off last bit of &#34;content&#34; section?
    return header, content</code></pre>
</details>
</dd>
<dt id="PHITS_tools.extract_data_from_header_line"><code class="name flex">
<span>def <span class="ident">extract_data_from_header_line</span></span>(<span>line)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Extract a "key" and its corresponding value from a PHITS tally output header line</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code><a title="PHITS_tools.is_number" href="#PHITS_tools.is_number">is_number()</a></code> (function within the "PHITS tools" package)</li>
</ul>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>line</code> = string to be processed</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>key</code> = a string "key" to become a key in the metadata dictionary</li>
<li><code>value</code> = corresponding value they "key" is equal to; dtype is string, int, or float</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_data_from_header_line(line):
    &#39;&#39;&#39;
    Description:
        Extract a &#34;key&#34; and its corresponding value from a PHITS tally output header line

    Dependencies:
        - `is_number` (function within the &#34;PHITS tools&#34; package)

    Inputs:
        - `line` = string to be processed

    Outputs:
        - `key` = a string &#34;key&#34; to become a key in the metadata dictionary
        - `value` = corresponding value they &#34;key&#34; is equal to; dtype is string, int, or float
    &#39;&#39;&#39;
    if &#39;#&#39; in line:
        info, trash = line.split(&#39;#&#39;,1)
    else:
        info = line
    key, value = info.split(&#39;=&#39;)
    key = key.strip()
    value = value.strip()
    if is_number(value):
        if &#39;.&#39; in value:
            value = float(value)
        else:
            value = int(value)
    return key, value</code></pre>
</details>
</dd>
<dt id="PHITS_tools.data_row_to_num_list"><code class="name flex">
<span>def <span class="ident">data_row_to_num_list</span></span>(<span>line)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Extract numeric values from line of text from PHITS tally output content section</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code><a title="PHITS_tools.is_number" href="#PHITS_tools.is_number">is_number()</a></code> (function within the "PHITS tools" package)</li>
</ul>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>line</code> = string to be processed</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>values</code> = a list of ints and/or floats of numeric values in <code>line</code></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data_row_to_num_list(line):
    &#39;&#39;&#39;
    Description:
        Extract numeric values from line of text from PHITS tally output content section

    Dependencies:
        - `is_number` (function within the &#34;PHITS tools&#34; package)

    Inputs:
        - `line` = string to be processed

    Outputs:
        - `values` = a list of ints and/or floats of numeric values in `line`
    &#39;&#39;&#39;
    value_strs = line.strip().split()
    values = []
    for value in value_strs:
        if is_number(value):
            if &#39;.&#39; in value:
                value = float(value)
            else:
                value = int(value)
        values.append(value)
    return values</code></pre>
</details>
</dd>
<dt id="PHITS_tools.parse_group_string"><code class="name flex">
<span>def <span class="ident">parse_group_string</span></span>(<span>text)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Separate "groups" in a string, wherein a group is a standalone value or a series of values inside parentheses.</p>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>text</code> = string to be processed</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>groups</code> = a list of strings extracted from <code>text</code></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_group_string(text):
    &#39;&#39;&#39;
    Description:
        Separate &#34;groups&#34; in a string, wherein a group is a standalone value or a series of values inside parentheses.

    Inputs:
        - `text` = string to be processed

    Outputs:
        - `groups` = a list of strings extracted from `text`
    &#39;&#39;&#39;
    # returns list of items from PHITS-formatted string, e.g. w/ ()
    parts = text.strip().split()
    #print(parts)
    groups = []
    curly_vals = []
    in_brackets_group = False
    in_curly_brace_group = False
    num_group_members = 0
    for i in parts:
        if &#39;(&#39; in i and &#39;)&#39; in i:
            in_brackets_group = False
            groups.append(i)
        elif &#39;(&#39; in i:
            in_brackets_group = True
            groups.append(i)
        elif &#39;)&#39; in i:
            in_brackets_group = False
            num_group_members = 0
            groups[-1] += i
        elif &#39;{&#39; in i:
            in_curly_brace_group = True
            curly_vals = []
        elif &#39;}&#39; in i:
            in_curly_brace_group = False
            curly_int_strs = [str(j) for j in range(int(curly_vals[0]), int(curly_vals[-1])+1)]
            curly_vals = []
            groups += curly_int_strs
        else:
            if in_brackets_group:
                if num_group_members&gt;0: groups[-1] += &#39; &#39;
                groups[-1] += i
                num_group_members += 1
            elif in_curly_brace_group:
                if i != &#39;-&#39;:
                    curly_vals.append(i)
            else:
                groups.append(i)
    #print(groups)
    return groups</code></pre>
</details>
</dd>
<dt id="PHITS_tools.parse_tally_header"><code class="name flex">
<span>def <span class="ident">parse_tally_header</span></span>(<span>tally_header, tally_content)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Extracts metadata from PHITS tally output header (and some extra info from its contents section)</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code><a title="PHITS_tools.extract_data_from_header_line" href="#PHITS_tools.extract_data_from_header_line">extract_data_from_header_line()</a></code> (function within the "PHITS tools" package)</li>
<li><code><a title="PHITS_tools.parse_group_string" href="#PHITS_tools.parse_group_string">parse_group_string()</a></code> (function within the "PHITS tools" package)</li>
</ul>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>tally_header</code> = list of lines belonging to the tally output's header section</li>
<li><code>tally_content</code> = list of lists of remaining lines after the tally output's header section; the top level list is
broken into "blocks" ("newpage:"-separated) which are lists of lines belonging to each block/page.</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>meta</code> = Munch object / dictionary containing tally metadata</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_tally_header(tally_header,tally_content):
    &#39;&#39;&#39;
    Description:
        Extracts metadata from PHITS tally output header (and some extra info from its contents section)

    Dependencies:
        - `extract_data_from_header_line` (function within the &#34;PHITS tools&#34; package)
        - `parse_group_string` (function within the &#34;PHITS tools&#34; package)

    Inputs:
        - `tally_header` = list of lines belonging to the tally output&#39;s header section
        - `tally_content` = list of lists of remaining lines after the tally output&#39;s header section; the top level list is
                broken into &#34;blocks&#34; (&#34;newpage:&#34;-separated) which are lists of lines belonging to each block/page.

    Outputs:
        - `meta` = Munch object / dictionary containing tally metadata

    &#39;&#39;&#39;
    nlines = len(tally_header)
    tally_type = tally_header[0].replace(&#39; &#39;,&#39;&#39;)
    meta = Munch({})
    meta.tally_type = tally_type
    # Initialize variables for possible array
    mesh_types = [&#39;e&#39;,&#39;t&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;,&#39;r&#39;,&#39;a&#39;,&#39;l&#39;]
    for m in mesh_types: meta[&#39;n&#39;+m] = None
    meta[&#39;reg&#39;] = None
    meta[&#39;part&#39;] = None
    meta[&#39;npart&#39;] = None
    meta[&#39;nc&#39;] = None
    meta[&#39;samepage&#39;] = &#39;part&#39;
    found_mesh_kinds = []

    reading_axis_data = False
    reading_regions = False
    in_exceptional_mesh_kind = False
    for li, line in enumerate(tally_header):
        #if line[0]==&#39;#&#39;: # commented line
        if &#39;data =&#39; in line: # data section to parse
            reading_axis_data = True
            n_values_to_read = meta[&#39;n&#39;+current_data_mesh_kind] + 1
            remaining_n_values_to_read = n_values_to_read
            data_values = []
            in_exceptional_mesh_kind = False
            #print(&#39;read &#39;,n_values_to_read,current_data_mesh_kind,&#39; values&#39;)
            continue
        elif &#39;=&#39; in line:
            if line[0] == &#39;#&#39;:  # commented line
                key, value = extract_data_from_header_line(line[1:])
            else:
                key, value = extract_data_from_header_line(line)
            if in_exceptional_mesh_kind:
                if key[0]==&#39;e&#39;:
                    key = current_data_mesh_kind + key[1:]
                elif key==&#39;ne&#39;:
                    key = &#39;n&#39; + current_data_mesh_kind
            meta[key] = value

            if &#39;type&#39; in key:
                current_data_mesh_kind = key.replace(&#39;-type&#39;,&#39;&#39;)
                if current_data_mesh_kind == &#39;se&#39;: current_data_mesh_kind = &#39;e&#39;
                current_data_mesh_type = value
                found_mesh_kinds.append(current_data_mesh_kind)
                if current_data_mesh_kind in [&#39;e1&#39;,&#39;e2&#39;]:
                    in_exceptional_mesh_kind = True
                #print(current_data_mesh_kind,current_data_mesh_type)
            if key==&#39;part&#39;:
                part_groups = parse_group_string(str(value))
                kf_groups = parse_group_string(tally_header[li + 1].split(&#39;:&#39;)[1])
                meta[&#39;part_groups&#39;] = part_groups
                meta[&#39;kf_groups&#39;] = kf_groups
                meta[&#39;npart&#39;] = len(part_groups)
                meta[&#39;part_serial_groups&#39;] = [&#39;p&#39;+str(gi+1)+&#39;-group&#39; for gi in range(len(part_groups))]
            if key==&#39;reg&#39;:
                if meta[&#39;tally_type&#39;]==&#39;[T-Cross]&#39;:
                    num_regs = value
                    meta[&#39;num_reg_groups&#39;] = num_regs
                    meta[&#39;reg_groups&#39;] = []
                    # manually read in reg groups
                    li_start = li+2
                    li_stop = li_start + num_regs
                    for lii in range(li_start,li_stop):
                        non, rfrom, rto, area = tally_header[lii].split()
                        meta[&#39;reg_groups&#39;].append(rfrom+&#39; - &#39;+rto)
                else:
                    reg_groups = parse_group_string(str(value))
                    meta[&#39;reg_groups&#39;] = reg_groups
                    meta[&#39;num_reg_groups&#39;] = len(reg_groups)
            if key == &#39;point&#39;:
                num_regs = value
                meta[&#39;point_detectors&#39;] = {&#39;non&#39;:[], &#39;x&#39;:[], &#39;y&#39;:[], &#39;z&#39;:[], &#39;r0&#39;:[]} # [T-Point] points
                li_start = li + 2
                li_stop = li_start + num_regs
                for lii in range(li_start, li_stop):
                    non, tppx, tppy, tppz, tppr0 = tally_header[lii].split()
                    meta[&#39;point_detectors&#39;][&#39;non&#39;].append(non)
                    meta[&#39;point_detectors&#39;][&#39;x&#39;].append(tppx)
                    meta[&#39;point_detectors&#39;][&#39;y&#39;].append(tppy)
                    meta[&#39;point_detectors&#39;][&#39;z&#39;].append(tppz)
                    meta[&#39;point_detectors&#39;][&#39;r0&#39;].append(tppr0)
            if key == &#39;ring&#39;:
                num_regs = value
                meta[&#39;point_detectors&#39;] = {&#39;non&#39;:[], &#39;axis&#39;:[], &#39;ar&#39;:[], &#39;rr&#39;:[], &#39;r0&#39;:[]} # [T-Point] points
                li_start = li + 2
                li_stop = li_start + num_regs
                for lii in range(li_start, li_stop):
                    non, tppx, tppy, tppz, tppr0 = tally_header[lii].split()
                    meta[&#39;point_detectors&#39;][&#39;non&#39;].append(non)
                    meta[&#39;point_detectors&#39;][&#39;axis&#39;].append(tppx)
                    meta[&#39;point_detectors&#39;][&#39;ar&#39;].append(tppy)
                    meta[&#39;point_detectors&#39;][&#39;rr&#39;].append(tppz)
                    meta[&#39;point_detectors&#39;][&#39;r0&#39;].append(tppr0)
        elif reading_axis_data:
            values = line.replace(&#39;#&#39;,&#39;&#39;).strip().split()
            for val in values:
                data_values.append(float(val))
                remaining_n_values_to_read += -1
            if remaining_n_values_to_read &lt;= 0:
                reading_axis_data = False
                data_values = np.array(data_values)
                meta[current_data_mesh_kind+&#39;-mesh_bin_edges&#39;] = data_values
                meta[current_data_mesh_kind+&#39;-mesh_bin_mids&#39;] = 0.5*(data_values[1:]+data_values[:-1])
                #meta[current_data_mesh_kind+&#39;-mesh_bin_mids_log&#39;] = np.sqrt(data_values[1:]*data_values[:-1])
                # generate log-centered bin mids
                bin_mids_log = []
                for i in range(len(data_values)-1):
                    if data_values[i+1]&lt;=0 or data_values[i]&lt;=0: # if one or both edges &lt;= 0
                        if data_values[i+1]&lt;0 and data_values[i]&lt;0: # both values are negative
                            bin_mids_log.append(-1*np.sqrt(data_values[i]*data_values[i+1]))
                        elif data_values[i+1]==0 or data_values[i]==0: # one value is zero
                            # use linear center instead...
                            bin_mids_log.append(0.5*(data_values[i]+data_values[i+1]))
                        elif data_values[i+1]&lt;0 or data_values[i]&lt;0: # bin straddles zero
                            # use linear center instead...
                            bin_mids_log.append(0.5*(data_values[i]+data_values[i+1]))
                        else:
                            print(&#39;unknown binning encountered, skipping generation of log-scale bin mids for &#39;+current_data_mesh_kind+&#39;-mesh&#39;)
                            break
                    else:
                        bin_mids_log.append(np.sqrt(data_values[i]*data_values[i+1]))
                meta[current_data_mesh_kind+&#39;-mesh_bin_mids_log&#39;] = np.array(bin_mids_log)
            continue
        else:
            continue

    meta[&#39;found_mesh_kinds&#39;] = found_mesh_kinds

    if meta[&#39;tally_type&#39;]==&#39;[T-Cross]&#39;:
        if meta[&#39;mesh&#39;]==&#39;xyz&#39;:
            if &#39;enclos&#39; in meta and meta[&#39;enclos&#39;]==1:
                pass # total items remains nx*ny*nz
            else:
                meta[&#39;nz_original&#39;] = meta[&#39;nz&#39;]
                meta[&#39;nz&#39;] += 1 # zmesh surfaces are scored, making array nx*ny*(nz+1)
        elif meta[&#39;mesh&#39;]==&#39;r-z&#39;:
            if &#39;enclos&#39; in meta and meta[&#39;enclos&#39;]==1:
                pass # total items remains nr*nz
            else:
                # Current solution addresses this by expanding the ierr axis
                meta[&#39;nr_original&#39;] = meta[&#39;nr&#39;]
                meta[&#39;nz_original&#39;] = meta[&#39;nz&#39;]
                meta[&#39;nr&#39;] = meta[&#39;nr&#39;] + 1
                meta[&#39;nz&#39;] = meta[&#39;nz&#39;] + 1
                # OLD SOLUTION IMPLEMENTED IS BELOW
                # max total num of pages = nrsurf*nz + nzsurf*nr = (nr+1)*nz + nr*(nz+1) = 2*nr*nz + nr + nz
                # if one radius is 0, this becomes = nr*nz + nr*(nz+1) = 2*nr*nz + nr
                # Solution used here:
                # use ir to iterate nr, use iy to iterate nrsurf, use iz to iterate nz, use ic to iterate nzsurf
                # since only rsurf*z [iy,iz] and r*zsurf [ir,ic] pairs exist, when one pair is being written
                # the other will be [-1,-1], hence the dimensions for the array are increased by an extra 1 to prevent overlap
                #meta[&#39;nr_original&#39;] = meta[&#39;nr&#39;]
                #meta[&#39;nz_original&#39;] = meta[&#39;nz&#39;]
                #meta[&#39;ny_original&#39;] = meta[&#39;ny&#39;]
                ##meta[&#39;nc_original&#39;] = meta[&#39;nc&#39;]
                #meta[&#39;ny&#39;] = meta[&#39;nr&#39;] + 1 + 1
                #meta[&#39;nc&#39;] = meta[&#39;nz&#39;] + 1 + 1
                #meta[&#39;nr&#39;] = meta[&#39;nr&#39;] + 1
                #meta[&#39;nz&#39;] = meta[&#39;nz&#39;] + 1

    if meta[&#39;tally_type&#39;] == &#39;[T-Point]&#39;:
        if &#39;mesh&#39; not in meta:
            if &#39;point&#39; in meta:
                meta[&#39;mesh&#39;] = &#39;point&#39;
                meta[&#39;nreg&#39;] = meta[&#39;point&#39;]
            elif &#39;ring&#39; in meta:
                meta[&#39;mesh&#39;] = &#39;ring&#39;
                meta[&#39;nreg&#39;] = meta[&#39;ring&#39;]


    axes_1D = [&#39;eng&#39;,&#39;reg&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;,&#39;r&#39;,&#39;t&#39;,&#39;cos&#39;,&#39;the&#39;,&#39;mass&#39;,&#39;charge&#39;,&#39;let&#39;,&#39;tet&#39;,&#39;eng1&#39;,&#39;eng2&#39;,&#39;sed&#39;,&#39;rad&#39;,&#39;deg&#39;]
    axes_2D = [&#39;xy&#39;,&#39;yz&#39;,&#39;zx&#39;,&#39;rz&#39;,&#39;chart&#39;,&#39;dchain&#39;,&#39;t-eng&#39;,&#39;eng-t&#39;,&#39;t-e1&#39;,&#39;e1-t&#39;,&#39;t-e2&#39;,&#39;e2-t&#39;,&#39;e12&#39;,&#39;e21&#39;,&#39;xz&#39;,&#39;yx&#39;,&#39;zy&#39;,&#39;zr&#39;]

    axes_ital_1D = [3,   0,  0,  1,  2,  0,  4,    5,    5,     8,       8,    6,    0,     3,     8,    3,    5,    5]
    axes_ital_2D = [ [0,1],[1,2],[2,0],[0,2],[None,None],[None,None],[4,3],[3,4],[4,3],[3,4],[4,8],[8,4],[3,8],[8,3],[0,2],[1,0],[2,1],[2,0]]


    if meta[&#39;axis&#39;] in axes_1D:
        meta[&#39;axis_dimensions&#39;] = 1
        meta[&#39;axis_index_of_tally_array&#39;] = axes_ital_1D[axes_1D.index(meta[&#39;axis&#39;])]
    elif meta[&#39;axis&#39;] in axes_2D:
        meta[&#39;axis_dimensions&#39;] = 2
        meta[&#39;axis_index_of_tally_array&#39;] = axes_ital_2D[axes_2D.index(meta[&#39;axis&#39;])]
    else:
        print(&#34;WARNING: axis value of &#34;,meta[&#39;axis&#39;],&#34; is not in list of known/registered values&#34;)
        meta[&#39;axis_dimensions&#39;] = None
        meta[&#39;axis_index_of_tally_array&#39;] = None




    # Now extract portion of metadata only available from tally content

    if meta[&#39;mesh&#39;] == &#39;reg&#39; or meta[&#39;mesh&#39;] == &#39;tet&#39;:
        num, reg, vol = [], [], []
        if meta[&#39;axis&#39;]==&#39;reg&#39; or meta[&#39;axis&#39;]==&#39;tet&#39;:  # get number of regions and region data from first block of tally content
            outblock = tally_content[0]
            in_reg_list = False
            for line in outblock:
                if &#39;#&#39; in line and &#39; num &#39; in line:
                    cols = line[1:].split()
                    #print(cols)
                    in_reg_list = True
                    continue
                if len(line.split()) == 0 or &#39;{&#39; in line:
                    in_reg_list = False
                if in_reg_list:
                    vals = line.split()
                    if meta[&#39;tally_type&#39;] == &#39;[T-Cross]&#39;:
                        num.append(vals[0])
                        reg.append(vals[0])
                        vol.append(vals[1])
                    else:
                        num.append(vals[0])
                        reg.append(vals[1])
                        vol.append(vals[2])
        else: # scan output for region numbers:
            regcount = 0
            for outblock in tally_content:
                for line in outblock:
                    if &#39;reg =&#39; in line or &#39;reg  =&#39; in line:
                        eq_strs = split_str_of_equalities(line[1:])
                        reg_eq_str = &#39;&#39;
                        for eqsi in eq_strs:
                            if &#39;reg&#39; in eqsi:
                                reg_eq_str = eqsi
                                break
                        regnum = reg_eq_str.split(&#39;=&#39;)[1].strip()
                        #regnum = line.strip().split(&#39;reg =&#39;)[1].strip().replace(&#34;&#39;&#34;,&#39;&#39;)
                        if regnum not in reg:
                            regcount += 1
                            num.append(regcount)
                            reg.append(regnum)
                            vol.append(None)
                        continue
        if meta[&#39;mesh&#39;] == &#39;reg&#39;:
            meta.reg_serial_num = num
            meta.reg_num = reg
            if meta[&#39;tally_type&#39;] == &#39;[T-Cross]&#39;:
                meta.reg_area = vol
            else:
                meta.reg_volume = vol
            meta.nreg = len(reg)
        elif meta[&#39;mesh&#39;] == &#39;tet&#39;:
            meta.tet_serial_num = num
            meta.tet_num = reg
            meta.reg_num = reg
            #meta.tet_volume = vol
            if meta[&#39;tally_type&#39;] == &#39;[T-Cross]&#39;:
                meta.tet_area = vol
            else:
                meta.tet_volume = vol
            meta.ntet = len(reg)

        #if meta[&#39;tally_type&#39;] == &#39;[T-Cross]&#39;:
        #    meta[&#39;reg_groups&#39;] = reg



    elif meta[&#39;mesh&#39;] == &#39;tet&#39;:
        num, reg, vol = [], [], []
        if meta[&#39;axis&#39;] == &#39;tet&#39;:
            pass
        else:
            pass
        print(&#39;mesh=tet has not been tested!&#39;)
        meta.ntet = 0

    axis1_label = &#39;&#39;
    axis2_label = &#39;&#39;
    value_label = &#39;&#39;
    hc_passed = False # passed colorbar definition line
    outblock = tally_content[0]
    for line in outblock:
        if len(line) == 0: continue
        if line[:2] == &#39;x:&#39;:
            axis1_label = line[2:].strip()
        if line[:2] == &#39;y:&#39;:
            if meta.axis_dimensions == 1:
                value_label = line[2:].strip()
                #break
            elif meta.axis_dimensions == 2:
                if hc_passed: # second instance of y:
                    value_label = line[2:].strip()
                    #break
                else: # first instance of y:
                    axis2_label = line[2:].strip()
                    hc_passed = True
        #if line[:3] == &#39;hc:&#39;:
        #    hc_passed = True
        h_line_str = &#39;&#39;
        if line[0] == &#39;h&#39; and (line[1] == &#39;:&#39; or line[2] == &#39;:&#39;):
            if meta[&#39;axis_dimensions&#39;] == 1:
                ndatacol = line.count(&#39;y&#39;)
                if ndatacol != 1:  # multiple columns are present &#34;samepage&#34;
                    # get first string with y
                    col_groups = parse_group_string(line)
                    first_data_col_header = col_groups[3][2:]
                    for m in mesh_types:
                        if first_data_col_header[0] == m:
                            if m == &#39;e&#39;:
                                meta[&#39;samepage&#39;] = &#39;eng&#39;
                            elif m == &#39;r&#39;:
                                if first_data_col_header[:3] == &#39;reg&#39;:
                                    meta[&#39;samepage&#39;] = &#39;reg&#39;
                                else:
                                    meta[&#39;samepage&#39;] = m
                            elif m == &#39;l&#39;:
                                meta[&#39;samepage&#39;] = &#39;let&#39;
                            elif m == &#39;a&#39;:
                                meta[&#39;samepage&#39;] = &#39;the&#39; # or cos
                            else:
                                meta[&#39;samepage&#39;] = m
                    if meta[&#39;samepage&#39;] == &#39;part&#39;:  # still is default value
                        # double check to see if it could be region numbers vs particle names
                        if ndatacol != meta[&#39;npart&#39;]:
                            if ndatacol == meta[&#39;num_reg_groups&#39;]:
                                meta[&#39;samepage&#39;] = &#39;reg&#39;
                            else:
                                print(&#39;&#34;samepage&#34; was not correctly identified; needs to be implemented&#39;)
                    if meta[&#39;samepage&#39;] == &#39;reg&#39;:
                        hcols = parse_group_string(line[3:])
                        num, reg, vol = [], [], []
                        reg_ser_num = 1
                        for hcol in hcols:
                            if hcol[0] == &#39;y&#39;:
                                num.append(reg_ser_num)
                                reg_ser_num += 1
                                reg.append(hcol.split(&#39;)&#39;)[0].replace(&#39;y(reg&#39;,&#39;&#39;))
                                vol.append(None)
                        meta.reg_serial_num = num
                        meta.reg_num = reg
                        meta.reg_volume = vol
                        meta.nreg = len(reg)

            break
    meta.axis1_label = axis1_label
    meta.axis2_label = axis2_label
    meta.value_label = value_label

    # Now do any final overrides for specific tallies / circumstances

    if meta[&#39;tally_type&#39;] == &#39;[T-Deposit2]&#39;:
        meta[&#39;nreg&#39;] = 1
        meta[&#39;reg_serial_num&#39;] = [1]
        meta[&#39;reg_num&#39;] = [&#39;1&#39;]
        meta[&#39;reg_volume&#39;] = [None]
        if meta[&#39;num_reg_groups&#39;] &gt; 1:
            meta[&#39;num_reg_groups&#39;] = 1
            meta[&#39;reg_groups&#39;] = [meta[&#39;reg_groups&#39;][0] + &#39; &#39; + meta[&#39;reg_groups&#39;][1]]

    if meta[&#39;tally_type&#39;] == &#39;[T-Heat]&#39;:
        if &#39;npart&#39; not in meta or meta[&#39;npart&#39;] == None: meta[&#39;npart&#39;] = 1
        if &#39;part_groups&#39; not in meta: meta[&#39;part_groups&#39;] = [&#39;all&#39;]

    return meta</code></pre>
</details>
</dd>
<dt id="PHITS_tools.initialize_tally_array"><code class="name flex">
<span>def <span class="ident">initialize_tally_array</span></span>(<span>tally_metadata, include_abs_err=True)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Initializes main tally data array in which tally results will be stored when read</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code>import numpy as np</code></li>
</ul>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>tally_metadata</code> = Munch object / dictionary containing tally metadata</li>
<li><code>include_abs_err</code> = a Boolean (D=<code>True</code>) on whether absolute error will be calculated; the final dimension of <code>tdata</code> is
<code>3/2</code> if this value is <code>True/False</code></li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>tdata</code> = 10-dimensional NumPy array of zeros of correct size for holding tally results</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_tally_array(tally_metadata,include_abs_err=True):
    &#39;&#39;&#39;
    Description:
        Initializes main tally data array in which tally results will be stored when read

    Dependencies:
        - `import numpy as np`

    Inputs:
        - `tally_metadata` = Munch object / dictionary containing tally metadata
        - `include_abs_err` = a Boolean (D=`True`) on whether absolute error will be calculated; the final dimension of `tdata` is
                `3/2` if this value is `True/False`

    Outputs:
        - `tdata` = 10-dimensional NumPy array of zeros of correct size for holding tally results

    &#39;&#39;&#39;
    ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max = 1, 1, 1, 1, 1, 1, 1, 1, 1
    if include_abs_err:
        ierr_max = 3
    else:
        ierr_max = 2
    if tally_metadata[&#39;mesh&#39;] == &#39;reg&#39;:
        ir_max = tally_metadata.nreg
    elif tally_metadata[&#39;mesh&#39;] == &#39;xyz&#39;:
        ir_max = tally_metadata.nx
        iy_max = tally_metadata.ny
        iz_max = tally_metadata.nz
    elif tally_metadata[&#39;mesh&#39;] == &#39;r-z&#39;:
        ir_max = tally_metadata.nr
        iz_max = tally_metadata.nz
        if &#39;ny&#39; in tally_metadata and tally_metadata.ny != None: iy_max = tally_metadata.ny
        if &#39;nc&#39; in tally_metadata and tally_metadata.nc != None: ic_max = tally_metadata.nc
    elif tally_metadata[&#39;mesh&#39;] == &#39;tet&#39;:
        ir_max = tally_metadata.ntet
    elif tally_metadata[&#39;mesh&#39;] == &#39;point&#39; or tally_metadata[&#39;mesh&#39;] == &#39;ring&#39;:
        ir_max = tally_metadata.nreg
    else:
        print(&#39;ERROR! Unknown geometry mesh:&#39;, tally_metadata[&#39;mesh&#39;])
        sys.exit()

    if tally_metadata.na != None: ia_max = tally_metadata.na
    if tally_metadata.nt != None: it_max = tally_metadata.nt
    if tally_metadata.nl != None: il_max = tally_metadata.nl
    if &#39;nc&#39; in tally_metadata and tally_metadata.nc != None: ic_max = tally_metadata.nc
    #if &#39;npart&#39; in tally_metadata and tally_metadata.npart != None: ip_max = tally_metadata.np

    if tally_metadata.ne == None:
        if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Deposit2]&#39;:
            if &#39;ne1&#39; in tally_metadata:
                ie_max = tally_metadata.ne1
            if &#39;ne2&#39; in tally_metadata:
                ic_max = tally_metadata.ne2
        elif &#39;e1&#39; in tally_metadata.axis or &#39;e2&#39; in tally_metadata.axis:  # This should now be redundant?
            if tally_metadata.axis == &#39;e12&#39;:
                ie_max = tally_metadata.ne1
                ic_max = tally_metadata.ne2
            elif tally_metadata.axis == &#39;e21&#39;:
                ie_max = tally_metadata.ne1
                ic_max = tally_metadata.ne2
            elif &#39;e1&#39; in tally_metadata.axis or &#39;eng1&#39; in tally_metadata.axis:
                ie_max = tally_metadata.ne1
                if &#39;ne2&#39; in tally_metadata:
                    ic_max = tally_metadata.ne2
            elif &#39;e2&#39; in tally_metadata.axis or &#39;eng2&#39; in tally_metadata.axis:
                ic_max = tally_metadata.ne2
                if &#39;ne1&#39; in tally_metadata:
                    ie_max = tally_metadata.ne1
            else:
                if &#39;ne1&#39; in tally_metadata:
                    ie_max = tally_metadata.ne1
                if &#39;ne2&#39; in tally_metadata:
                    ic_max = tally_metadata.ne2

    else:
        ie_max = tally_metadata.ne

    ip_max = tally_metadata.npart

    if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Cross]&#39; and tally_metadata.mesh == &#39;r-z&#39;:
        if &#39;enclos&#39; in tally_metadata and tally_metadata[&#39;enclos&#39;] == 1:
            pass
        else: # enclos = 0 case
            ierr_max = 2*ierr_max

    if tally_metadata[&#39;tally_type&#39;] == &#39;[T-Yield]&#39;:
        if tally_metadata.axis == &#39;charge&#39;:
            ic_max = 130
        elif tally_metadata.axis == &#39;mass&#39;:
            ic_max = 320
        elif tally_metadata.axis == &#39;chart&#39;:
            if int(tally_metadata.mxnuclei) == 0:
                ic_max = 10000
            else:
                ic_max = int(tally_metadata.mxnuclei)

    if in_debug_mode:
        dims_str = &#39;tally dims: nr={:g}, ny={:g}, nz={:g}, ne={:g}, nt={:g}, na={:g}, nl={:g}, np={:g}, nc={:g}, nerr={:g}&#39;
        print(dims_str.format(ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max, ierr_max))
    tally_data = np.zeros((ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max, ierr_max))
    return tally_data</code></pre>
</details>
</dd>
<dt id="PHITS_tools.calculate_tally_absolute_errors"><code class="name flex">
<span>def <span class="ident">calculate_tally_absolute_errors</span></span>(<span>tdata)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Calculates the absolute uncertainty for every value in the PHITS tally data array</p>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>tdata</code> = 10-dimensional NumPy array containing read/extracted tally results</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>tdata</code> = updated <code>tdata</code> array now with absolute uncertainties in <code>ierr = 2</code> index</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_tally_absolute_errors(tdata):
    &#39;&#39;&#39;
    Description:
        Calculates the absolute uncertainty for every value in the PHITS tally data array

    Inputs:
        - `tdata` = 10-dimensional NumPy array containing read/extracted tally results

    Outputs:
        - `tdata` = updated `tdata` array now with absolute uncertainties in `ierr = 2` index

    &#39;&#39;&#39;

    ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max, ierr_max = np.shape(tdata)
    for ir in range(ir_max):
        for iy in range(iy_max):
            for iz in range(iz_max):
                for ie in range(ie_max):
                    for it in range(it_max):
                        for ia in range(ia_max):
                            for il in range(il_max):
                                for ip in range(ip_max):
                                    for ic in range(ic_max):
                                        tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 2] = \
                                            tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 0] * \
                                            tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 1]
    if ierr_max==6:
        for ir in range(ir_max):
            for iy in range(iy_max):
                for iz in range(iz_max):
                    for ie in range(ie_max):
                        for it in range(it_max):
                            for ia in range(ia_max):
                                for il in range(il_max):
                                    for ip in range(ip_max):
                                        for ic in range(ic_max):
                                            tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 5] = \
                                                tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 3] * \
                                                tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 4]

    return tdata</code></pre>
</details>
</dd>
<dt id="PHITS_tools.split_str_of_equalities"><code class="name flex">
<span>def <span class="ident">split_str_of_equalities</span></span>(<span>text)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Extract relevant regions, indices, etc. from somewhat inconsistently formatted lines in PHITS tally output content section.</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code><a title="PHITS_tools.is_number" href="#PHITS_tools.is_number">is_number()</a></code> (function within the "PHITS tools" package)</li>
</ul>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>text</code> = string to be processed</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>equalities_str_list</code> = list of strings of equalities each of the format "key = value"</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_str_of_equalities(text):
    &#39;&#39;&#39;
    Description:
        Extract relevant regions, indices, etc. from somewhat inconsistently formatted lines in PHITS tally output content section.

    Dependencies:
        - `is_number` (function within the &#34;PHITS tools&#34; package)

    Inputs:
        - `text` = string to be processed

    Outputs:
        - `equalities_str_list` = list of strings of equalities each of the format &#34;key = value&#34;

    &#39;&#39;&#39;
    equalities_str_list = []
    original_text = text
    #if text[0] == &#34;&#39;&#34;: # more loosely formatted text
    #    problem_strs = [&#39;tot DPA&#39;]
    text = text.replace(&#34;&#39;&#34;,&#39;&#39;).replace(&#39;,&#39;,&#39; &#39;).replace(&#39;#&#39;,&#39;&#39;).replace(&#39;=&#39;,&#39; = &#39;)
    text_pieces = text.split()
    #i_equal_sign = [i for i, x in enumerate(text_pieces) if x == &#34;=&#34;]
    is_i_equal_sign = [x==&#39;=&#39; for x in text_pieces]
    #i_is_number = [i for i, x in enumerate(text_pieces) if is_number(x)]
    is_i_number = [is_number(x) for x in text_pieces]
    #num_equalities = len(i_equal_sign)
    #remaining_equalities = num_equalities
    equality_str = &#39;&#39;
    # the only condition enforced is that the last item in each value be numeric or )
    current_equality_contains_equalsign = False
    for i in reversed(range(len(text_pieces))): # easiest to build from right to left
        equality_str = text_pieces[i] + &#39; &#39; + equality_str
        if is_i_equal_sign[i]:
            current_equality_contains_equalsign = True
        elif current_equality_contains_equalsign: # looking to terminate if next item is numeric
            if i==0 or (is_i_number[i-1] or text_pieces[i-1][-1]==&#39;)&#39;): # either final equality completed or next item belongs to next equality
                equalities_str_list.insert(0,equality_str.strip())
                equality_str = &#39;&#39;
                current_equality_contains_equalsign = False
    if &#39;(&#39; in text: # need to break up potential (ia,ib) pairs
        new_eq_str_list = []
        for x in equalities_str_list:
            if &#39;(&#39; in x:
                keys, values = x.split(&#39;=&#39;)
                keys = keys.strip().replace(&#39;(&#39;,&#39;&#39;).replace(&#39;)&#39;,&#39;&#39;).split()
                values = values.strip().replace(&#39;(&#39;,&#39;&#39;).replace(&#39;)&#39;,&#39;&#39;).split()
                for i in range(len(keys)):
                    new_eq_str = keys[i].strip() + &#39; = &#39; + values[i].strip()
                    new_eq_str_list.append(new_eq_str)
            else:
                new_eq_str_list.append(x)
        equalities_str_list = new_eq_str_list
    #print(equalities_str_list)
    return equalities_str_list</code></pre>
</details>
</dd>
<dt id="PHITS_tools.parse_tally_content"><code class="name flex">
<span>def <span class="ident">parse_tally_content</span></span>(<span>tdata, meta, tally_blocks, is_err_in_separate_file, err_mode=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Parses the PHITS tally output content section and extract its results</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code><a title="PHITS_tools.split_str_of_equalities" href="#PHITS_tools.split_str_of_equalities">split_str_of_equalities()</a></code> (function within the "PHITS tools" package)</li>
<li><code><a title="PHITS_tools.parse_group_string" href="#PHITS_tools.parse_group_string">parse_group_string()</a></code> (function within the "PHITS tools" package)</li>
<li><code><a title="PHITS_tools.data_row_to_num_list" href="#PHITS_tools.data_row_to_num_list">data_row_to_num_list()</a></code> (function within the "PHITS tools" package)</li>
</ul>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>tdata</code> = 10-dimensional NumPy array of zeros of correct size to hold tally output/results</li>
<li><code>meta</code> = Munch object / dictionary containing tally metadata</li>
<li><code>tally_blocks</code> = blocks of tally output as outputted by the <code><a title="PHITS_tools.split_into_header_and_content" href="#PHITS_tools.split_into_header_and_content">split_into_header_and_content()</a></code> function</li>
<li><code>is_err_in_separate_file</code> = Boolean denoting whether the tally's relative errors are located in a separate file</li>
<li><code>err_mode</code> = Boolean (D=<code>False</code>) used for manually forcing all read values to be regarded as relative uncertainties
as is necessary when processing dedicated *_err files.</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>tdata</code> = updated <code>tdata</code> array containing read/extracted tally results</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_tally_content(tdata,meta,tally_blocks,is_err_in_separate_file,err_mode=False):
    &#39;&#39;&#39;
    Description:
        Parses the PHITS tally output content section and extract its results

    Dependencies:
        - `split_str_of_equalities` (function within the &#34;PHITS tools&#34; package)
        - `parse_group_string` (function within the &#34;PHITS tools&#34; package)
        - `data_row_to_num_list` (function within the &#34;PHITS tools&#34; package)

    Inputs:
        - `tdata` = 10-dimensional NumPy array of zeros of correct size to hold tally output/results
        - `meta` = Munch object / dictionary containing tally metadata
        - `tally_blocks` = blocks of tally output as outputted by the `split_into_header_and_content` function
        - `is_err_in_separate_file` = Boolean denoting whether the tally&#39;s relative errors are located in a separate file
        - `err_mode` = Boolean (D=`False`) used for manually forcing all read values to be regarded as relative uncertainties
                as is necessary when processing dedicated *_err files.

    Outputs:
        - `tdata` = updated `tdata` array containing read/extracted tally results

    &#39;&#39;&#39;
    global ir, iy, iz, ie, it, ia, il, ip, ic, ierr
    global ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max, ierr_max
    ierr = 0
    if is_err_in_separate_file and err_mode:
        ierr = 1

    mesh_kind_chars = [&#39;e&#39;, &#39;t&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;r&#39;, &#39;a&#39;, &#39;l&#39;]
    mesh_kind_iax = [3, 4, 0, 1, 2, 0, 5, 6]
    tdata_ivar_strs = [&#39;ir&#39;, &#39;iy&#39;, &#39;iz&#39;, &#39;ie&#39;, &#39;it&#39;, &#39;ia&#39;, &#39;il&#39;, &#39;ip&#39;, &#39;ic&#39;]
    ir, iy, iz, ie, it, ia, il, ip, ic = 0, 0, 0, 0, 0, 0, 0, 0, 0

    ignored_eq_strs = [&#39;axis&#39;,&#39;axs&#39;,&#39;ar&#39;,&#39;rr&#39;,&#39;m jm&#39;,&#39;Z&#39;,&#39;cmax nmax&#39;]
    replace_eq_strs_dict = {&#39;ang&#39;:&#39;a&#39;}

    ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max, ierr_max = np.shape(tdata)

    axes_1D = [&#39;eng&#39;, &#39;reg&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;r&#39;, &#39;t&#39;, &#39;cos&#39;, &#39;the&#39;, &#39;mass&#39;, &#39;charge&#39;, &#39;let&#39;, &#39;tet&#39;, &#39;eng1&#39;, &#39;eng2&#39;,
               &#39;sed&#39;, &#39;rad&#39;, &#39;deg&#39;]
    axes_2D = [&#39;xy&#39;, &#39;yz&#39;, &#39;zx&#39;, &#39;rz&#39;, &#39;chart&#39;, &#39;dchain&#39;,
               &#39;t-eng&#39;, &#39;eng-t&#39;, &#39;t-e1&#39;, &#39;e1-t&#39;, &#39;t-e2&#39;, &#39;e2-t&#39;,
               &#39;e12&#39;, &#39;e21&#39;, &#39;xz&#39;, &#39;yx&#39;, &#39;zy&#39;, &#39;zr&#39;]

    axes_ital_1D = [3, 0, 0, 1, 2, 0, 4, 5, 5, 8, 8, 6, 0, 3, 8,
                    3, 5, 5]
    axes_ital_2D = [[0, 1], [1, 2], [2, 0], [0, 2], [None, None], [None, None],
                    [4, 3], [3, 4], [4, 3], [3, 4], [4, 8], [8, 4],
                    [3, 8], [8, 3], [0, 2], [1, 0], [2, 1], [2, 0]]

    ierr_mod = 0 # add to ierr for weird [T-Cross], mesh=r-z, enclos=0 case

    banked_uninterpreted_lines = [] # store lines with equalities that may be useful but are skipped owing to being a bit exceptional
    i_metastable = 0
    ZZZAAAM_list = []

    if meta.axis_dimensions==1:
        for bi, block in enumerate(tally_blocks):
            hli, fli = 0,0
            ierr_mod = 0
            hli_found = False
            for li, line in enumerate(block):
                if len(line) == 0: continue
                if line[:2].lower() == &#39;h:&#39;:  # start of data is here
                    hli = li
                    hli_found = True
                    continue
                if hli_found and (line[:12] == &#39;#   sum over&#39; or line[:7] == &#39;#   sum&#39; or line[:5] == &#39;#----&#39; or (len(block[li-1]) == 0 and hli != 0 and li&gt;hli+2) or &#34;&#39;&#34; in line or &#39;{&#39; in line):
                    fli = li
                    if (len(block[li-1]) == 0 and hli != 0 and li&gt;hli+2): fli = li - 1 # triggered by blank line after data
                    #if &#34;&#39;&#34; in line or &#39;{&#39; in line:
                    #    fli = li-1
                    break

            data_header = block[:hli]
            data_table = block[hli:fli]
            data_footer = block[fli:]

            if bi == len(tally_blocks) - 1:
                for li, line in enumerate(data_footer):
                    if line[:37] == &#39;# Information for Restart Calculation&#39;:
                        ffli = li
                        break
                data_footer = data_footer[:ffli]

            # print(data_header)
            #print(data_table)
            # print(data_footer)

            hash_line_already_evaluated = False

            # try to get relevant indices data from header and footer blocks
            for li, line in enumerate(data_header+data_footer):
                if len(line) == 0: continue

                if &#39;=&#39; in line and (line[0] == &#34;&#39;&#34; or (line[0] == &#34;#&#34; and (&#39;no.&#39; in line or &#39;i&#39; in line or &#39;reg&#39; in line or &#39;part&#39; in line))):
                    if line[0] == &#34;#&#34;:
                        hash_line_already_evaluated = True
                    elif line[0] == &#34;&#39;&#34; and hash_line_already_evaluated:
                        if meta[&#39;samepage&#39;] == &#39;part&#39;:
                            continue  # &#39;-starting lines tend to have more problematic formatting, best skipped if possible
                        elif meta[&#39;npart&#39;] == 1:
                            continue  # can still skip if only one particle group tallied
                        else:
                            pass  # but this needs to be parsed if not using samepage = part and npart &gt; 1
                    parts = split_str_of_equalities(line)
                    #print(line)
                    for part in parts:
                        mesh_char = part.split(&#39;=&#39;)[0].strip().replace(&#39;i&#39;,&#39;&#39;)
                        #print(mesh_char)
                        if mesh_char == &#39;no.&#39;:
                            if &#39;***&#39; in part:
                                break # this is a bugged line
                            continue
                        elif mesh_char == &#39;part.&#39; or mesh_char == &#39;partcle&#39; or mesh_char == &#39;part&#39;:
                            part_grp_name = part.split(&#39;=&#39;)[1].strip()
                            if part_grp_name in meta.part_groups:
                                ip = (meta.part_groups).index(part_grp_name)
                            elif part_grp_name in meta.part_serial_groups:
                                ip = (meta.part_serial_groups).index(part_grp_name)
                            else:
                                print(&#39;ERROR! Particle &#34;&#39;,part_grp_name,&#39;&#34; could not be identified.&#39;)
                                sys.exit()
                        elif mesh_char == &#39;reg&#39;:
                            regnum = part.split(&#39;=&#39;)[1].strip()
                            ir = (meta.reg_num).index(regnum)
                        elif mesh_char == &#39;pont&#39; or mesh_char == &#39;rng&#39;: # [T-Point]
                            value_str = part.split(&#39;=&#39;)[1].strip()
                            ir = int(value_str) - 1
                        elif mesh_char == &#39;e1&#39;: # [T-Deposit2]
                            value_str = part.split(&#39;=&#39;)[1].strip()
                            ie = int(value_str) - 1
                        elif mesh_char == &#39;e2&#39;: # [T-Deposit2]
                            value_str = part.split(&#39;=&#39;)[1].strip()
                            ic = int(value_str) - 1
                        elif mesh_char in mesh_kind_chars or mesh_char in replace_eq_strs_dict:
                            if mesh_char in replace_eq_strs_dict:
                                mesh_char = replace_eq_strs_dict[mesh_char]
                            if &#39;i&#39;+mesh_char not in part: continue # only looking for indices for meshes, not values
                            imesh = mesh_kind_chars.index(mesh_char)
                            itdata_axis = mesh_kind_iax[imesh]
                            tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                            value_str = part.split(&#39;=&#39;)[1].strip()
                            if &#39; - &#39; in value_str:
                                vals = value_str.split(&#39;-&#39;)
                                if int(vals[0]) == int(vals[1]):
                                    value_str = vals[0]
                                else:  # samepage axis
                                    value_str = vals[0]  # this will be overwritten later
                            value = str(int(value_str)-1)
                            exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                        elif mesh_char in ignored_eq_strs:
                            continue
                        elif meta[&#39;tally_type&#39;]==&#39;[T-Cross]&#39;:
                            if meta[&#39;mesh&#39;] == &#39;xyz&#39; and mesh_char==&#39;z surf&#39;:
                                #imesh = mesh_kind_chars.index(&#39;z&#39;)
                                itdata_axis = 2 #mesh_kind_iax[imesh]
                                tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                                value_str = part.split(&#39;=&#39;)[1].strip()
                                value = str(int(value_str) - 1)
                                exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                            elif meta[&#39;mesh&#39;] == &#39;r-z&#39;:
                                if mesh_char==&#39;r surf&#39;:
                                    itdata_axis = 0  # mesh_kind_iax[imesh]
                                    #itdata_axis = 1  # set to iy
                                    ierr_mod = int(ierr_max/2)
                                    #ir, ic = -1, -1
                                    # imesh = mesh_kind_chars.index(&#39;y&#39;)
                                elif mesh_char == &#39;z surf&#39;:
                                    itdata_axis = 2  # mesh_kind_iax[imesh]
                                    #itdata_axis = 8  # set to ic
                                    ierr_mod = 0
                                    #iy, iz = -1, -1
                                    # imesh = mesh_kind_chars.index(&#39;c&#39;)
                                else:
                                    print(&#39;ERROR! Unregistered potential index [&#39;, part.split(&#39;=&#39;)[0].strip(),&#39;] found&#39;)
                                    sys.exit()
                                tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                                value_str = part.split(&#39;=&#39;)[1].strip()
                                if &#39; - &#39; in value_str:
                                    vals = value_str.split(&#39;-&#39;)
                                    if int(vals[0]) == int(vals[1]):
                                        value_str = vals[0]
                                    else: # samepage axis
                                        value_str = vals[0] # this will be overwritten later
                                value = str(int(value_str) - 1)
                                exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                            else:
                                print(&#39;ERROR! Unregistered potential index [&#39;, part.split(&#39;=&#39;)[0].strip(), &#39;] found&#39;)
                                sys.exit()
                        elif meta[&#39;tally_type&#39;] == &#39;[T-Heat]&#39;:
                            banked_uninterpreted_lines.append(line)
                        else:
                            print(&#39;ERROR! Unregistered potential index [&#39;,part.split(&#39;=&#39;)[0].strip(),&#39;] found&#39;)
                            sys.exit()


            # extract data from table
            # determine meaning of table rows
            row_ivar = tdata_ivar_strs[meta.axis_index_of_tally_array]
            # determine meaning of table columns
            hcols = parse_group_string(data_table[0][3:])
            col_names_line_str = data_table[1][1:]
            icol_mod = 0 # account for weirdness in column presence/absence
            if &#39;r surface position&#39; in col_names_line_str:
                icol_mod = -1
                ierr_mod = int(ierr_max / 2)
            is_col_data = np.full(len(hcols),False)
            data_col_indices = []
            is_col_err = np.full(len(hcols),False)
            err_col_indices = []
            for iii in range(len(hcols)):
                if hcols[iii][0] == &#39;y&#39;:
                    is_col_data[iii+icol_mod] = True
                    is_col_err[iii+1+icol_mod] = True
                    data_col_indices.append(iii+icol_mod)
                    err_col_indices.append(iii+1+icol_mod)
            #print(is_col_data)
            #print(is_col_err)
            cols = data_table[1][1:].strip().split()
            ncols = len(cols)
            ndata_cols = np.sum(is_col_data) # number of data values per row
            # determine what variable this corresponds to, should be val of samepage
            # by default, this is usually particles (samepage = part by default)
            if meta.samepage == &#39;part&#39;:
                if meta.npart != ndata_cols:
                    print(&#39;ERROR! samepage number of particle types (&#39;,meta.npart,&#39;) not equal to number of data columns y(part) = &#39;,ndata_cols)
                    sys.exit()
                data_ivar = &#39;ip&#39;
                data_ivar_indices = [j for j in range(ndata_cols)]
            else: # figure out what axis samepage is on
                if meta.samepage not in axes_1D:
                    print(&#39;ERROR! samepage parameter (&#39;,meta.samepage,&#39;) must be &#34;part&#34; or one of valid options for &#34;axis&#34; parameter&#39;)
                    sys.exit()
                data_ivar = tdata_ivar_strs[axes_ital_1D[axes_1D.index(meta.samepage)]]
                if ndata_cols != eval(data_ivar+&#39;_max&#39;):
                    if meta[&#39;tally_type&#39;]==&#39;[T-Cross]&#39; and ndata_cols+1 == eval(data_ivar+&#39;_max&#39;):
                        # This is fine; for T-Cross, ndata cols can be one less than max length...
                        pass
                    elif meta[&#39;tally_type&#39;]==&#39;[T-Cross]&#39; and data_ivar == &#39;ir&#39; and ndata_cols+2 == eval(data_ivar+&#39;_max&#39;):
                        # This is fine; for T-Cross, ndata cols for radius can be two less than max length if rmin=0...
                        pass
                    else:
                        print(&#39;ERROR! number of data columns (&#39;,ndata_cols,&#39;) not equal to tally array dimension for &#39;,data_ivar,&#39;, &#39;,str(eval(data_ivar+&#39;_max&#39;)))
                        sys.exit()
                data_ivar_indices = [j for j in range(ndata_cols)]
            #print(cols)
            #print(ndata_cols)
            for li, line in enumerate(data_table[2:]):
                if len(line)==0: continue
                #print(line)
                rowi = li
                exec(row_ivar + &#39;=&#39; + str(rowi),globals())
                #print(row_ivar + &#39;=&#39; + str(rowi))
                values = data_row_to_num_list(line)
                dcoli = 0
                ecoli = 0
                for vi, value in enumerate(values):
                    if is_col_data[vi]:
                        exec(data_ivar + &#39;=&#39; + str(dcoli),globals())
                        #print(data_ivar + &#39;=&#39; + str(dcoli))
                        tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 0+ierr_mod] = value
                        dcoli += 1
                    if is_col_err[vi]:
                        exec(data_ivar + &#39;=&#39; + str(ecoli),globals())
                        #print(data_ivar + &#39;=&#39; + str(ecoli))
                        tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 1+ierr_mod] = value
                        ecoli += 1





    elif meta.axis_dimensions==2:
        for bi, block in enumerate(tally_blocks):
            hli, bli = 0 , 0
            data_keyword_found = False
            for li, line in enumerate(block):
                if meta[&#39;2D-type&#39;] in [1, 2, 3, 6, 7]:
                    if len(line) == 0: continue
                    if line[:3].lower() in [&#39;hc:&#39;, &#39;h2:&#39;, &#39;hd:&#39;]:  # start of data is here
                        hli = li
                    if line[:12] == &#39;#-----------&#39;:
                        fli = li
                        #if bi != len(tally_blocks) - 1:
                        break
                elif meta[&#39;2D-type&#39;] == 4:
                    if line == &#39;&#39; and hli != 0:
                        fli = li
                        #if bi != len(tally_blocks) - 1:
                        break
                    elif line == &#39;&#39;:  # start of data is here
                        hli = li
                elif meta[&#39;2D-type&#39;] == 5:
                    if &#39;data&#39; in line:
                        hli = li + 3
                    if line == &#39;&#39; and hli != 0 and li&gt;hli+2:
                        fli = li
                        #if bi != len(tally_blocks) - 1:
                        break

            data_header = block[:hli]
            data_table = block[hli:fli]
            data_footer = block[fli:]

            #print(data_header)
            #print(data_table)
            #print(data_footer)

            hash_line_already_evaluated = False

            if bi == len(tally_blocks) - 1:
                for li, line in enumerate(data_footer):
                    if line[:37] == &#39;# Information for Restart Calculation&#39;:
                        ffli = li
                        break
                data_footer = data_footer[:ffli]

            # try to get relevant indices data from header block
            for li, line in enumerate(data_header+data_footer): # +data_footer
                if len(line) == 0: continue
                #if &#39;reg =&#39; in line:
                #    regnum = line.strip().split(&#39;reg =&#39;)[1].strip()
                #    ir = (meta.reg_num).index(regnum)
                #    # print(ir)
                if &#39;=&#39; in line and (line[0] == &#34;&#39;&#34; or (line[0] == &#34;#&#34; and (&#39;no.&#39; in line or &#39;i&#39; in line or &#39;reg&#39; in line or &#39;part&#39; in line))):
                    if line[0] == &#34;#&#34;:
                        hash_line_already_evaluated = True
                    elif line[0] == &#34;&#39;&#34; and hash_line_already_evaluated:
                        if meta[&#39;samepage&#39;] == &#39;part&#39;:
                            continue # &#39;-starting lines tend to have more problematic formatting, best skipped if possible
                        elif meta[&#39;npart&#39;] == 1:
                            continue # can still skip if only one particle group tallied
                        else:
                            pass # but this needs to be parsed if not using samepage = part and npart &gt; 1
                    parts = split_str_of_equalities(line)
                    for part in parts:
                        mesh_char = part.split(&#39;=&#39;)[0].strip().replace(&#39;i&#39;, &#39;&#39;)
                        #print(mesh_char)
                        if mesh_char == &#39;no.&#39;:
                            continue
                        elif mesh_char == &#39;part.&#39; or mesh_char == &#39;partcle&#39;:
                            part_grp_name = part.split(&#39;=&#39;)[1].strip()
                            ip = (meta.part_groups).index(part_grp_name)
                        elif mesh_char == &#39;reg&#39;: # and meta[&#39;samepage&#39;] != &#39;reg&#39;:
                            regnum = part.split(&#39;=&#39;)[1].strip()
                            ir = (meta.reg_num).index(regnum)
                        elif mesh_char == &#39;e1&#39;: # [T-Deposit2]
                            value_str = part.split(&#39;=&#39;)[1].strip()
                            ie = int(value_str) - 1
                        elif mesh_char == &#39;e2&#39;: # [T-Deposit2]
                            value_str = part.split(&#39;=&#39;)[1].strip()
                            ic = int(value_str) - 1
                        elif mesh_char in mesh_kind_chars or mesh_char in replace_eq_strs_dict:
                            if mesh_char in replace_eq_strs_dict:
                                mesh_char = replace_eq_strs_dict[mesh_char]
                            if &#39;i&#39;+mesh_char not in part: continue # only looking for indices for meshes, not values
                            imesh = mesh_kind_chars.index(mesh_char)
                            itdata_axis = mesh_kind_iax[imesh]
                            tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                            value = str(int(part.split(&#39;=&#39;)[1].strip()) - 1)
                            if mesh_char == &#39;l&#39; and meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39; and meta[&#39;axis&#39;] == &#39;chart&#39;:
                                i_metastable = int(value) + 1
                                il = 0
                            else:
                                exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                        elif mesh_char in ignored_eq_strs:
                            continue
                        elif meta[&#39;tally_type&#39;]==&#39;[T-Cross]&#39;:
                            ierr_mod = 0
                            if meta[&#39;mesh&#39;] == &#39;xyz&#39; and mesh_char==&#39;z surf&#39;:
                                #imesh = mesh_kind_chars.index(&#39;z&#39;)
                                itdata_axis = 2 #mesh_kind_iax[imesh]
                                tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                                value = str(int(part.split(&#39;=&#39;)[1].strip()) - 1)
                                exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                            elif meta[&#39;mesh&#39;] == &#39;r-z&#39;:
                                if mesh_char==&#39;r surf&#39;:
                                    # imesh = mesh_kind_chars.index(&#39;y&#39;)
                                    itdata_axis = 0 #1  # mesh_kind_iax[imesh]
                                    tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                                    value = str(int(part.split(&#39;=&#39;)[1].strip()) - 1)
                                    exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                                    #ir, ic = -1, -1
                                    ierr_mod = int(ierr_max / 2)
                                elif mesh_char==&#39;z surf&#39;:
                                    # imesh = mesh_kind_chars.index(&#39;c&#39;)
                                    itdata_axis = 2 #8  # mesh_kind_iax[imesh]
                                    tdata_ivar_str = tdata_ivar_strs[itdata_axis]
                                    value = str(int(part.split(&#39;=&#39;)[1].strip()) - 1)
                                    exec(tdata_ivar_str + &#39; = &#39; + value, globals())
                                    iy, iz = -1, -1
                                    ierr_mod = 0
                                else:
                                    print(&#39;ERROR! Unregistered potential index [&#39;, part.split(&#39;=&#39;)[0].strip(),&#39;] found&#39;)
                                    sys.exit()
                            else:
                                print(&#39;ERROR! Unregistered potential index [&#39;, part.split(&#39;=&#39;)[0].strip(), &#39;] found&#39;)
                                sys.exit()
                        else:
                            print(&#39;ERROR! Unregistered potential index [&#39;,part.split(&#39;=&#39;)[0].strip(),&#39;] found&#39;)
                            sys.exit()


            # Now read data_table, with formatting dependent on 2D-type, and can be inferred from last line of header
            axis1_ivar = meta.axis_index_of_tally_array[0]
            axis2_ivar = meta.axis_index_of_tally_array[1]
            if meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39; and meta[&#39;axis&#39;] == &#39;chart&#39;: # this setting does not respect 2D-type and uses its own formatting
                data_write_format_str = data_table[0][3:]
                Z_y_segment = data_write_format_str.split(&#39;;&#39;)[0]
                N_x_segment = data_write_format_str.split(&#39;;&#39;)[1]
                Z_y_vals = Z_y_segment.replace(&#39;=&#39;,&#39;&#39;).replace(&#39;to&#39;,&#39;&#39;).replace(&#39;by&#39;,&#39;&#39;).replace(&#39;y&#39;,&#39;&#39;).strip().split()
                N_x_vals = N_x_segment.replace(&#39;=&#39;,&#39;&#39;).replace(&#39;to&#39;,&#39;&#39;).replace(&#39;by&#39;,&#39;&#39;).replace(&#39;x&#39;,&#39;&#39;).strip().split()
                Z_y_max, Z_y_min, Z_y_increment = int(Z_y_vals[0]), int(Z_y_vals[1]), int(Z_y_vals[2])
                N_x_max, N_x_min, N_x_increment = int(N_x_vals[1]), int(N_x_vals[0]), int(N_x_vals[2])
                #print(Z_y_max, Z_y_min, Z_y_increment, N_x_max, N_x_min, N_x_increment )
            elif meta[&#39;2D-type&#39;] != 4:
                data_write_format_str = data_header[-2][1:]
                if &#39;data&#39; not in data_write_format_str:
                    for line in data_header[::-1]:
                        if &#39;data&#39; in line:
                            data_write_format_str = line[1:]
                            break
                #print(data_write_format_str)
                for dsi in data_write_format_str.split():
                    if &#39;data&#39; in dsi:
                        data_index_str = dsi
                        ax_vars = data_index_str.replace(&#39;data&#39;,&#39;&#39;).replace(&#39;(&#39;,&#39;&#39;).replace(&#39;)&#39;,&#39;&#39;)
                        #print(data_index_str)
                        #print(ax_vars)
                        ax1_ivar, ax2_ivar = ax_vars.split(&#39;,&#39;)[:2]
                        ax1_ivar = &#39;i&#39; + ax1_ivar
                        ax2_ivar = &#39;i&#39; + ax2_ivar
                #print(data_write_format_str)
            else:  # 2D-type = 4
                cols = data_table[1][1:].split()
                ax1_ivar, ax2_ivar = cols[0], cols[1]
                ax1_ivar = &#39;i&#39; + ax1_ivar
                ax2_ivar = &#39;i&#39; + ax2_ivar

            # manually fix [T-Deposit2] axes
            if meta[&#39;tally_type&#39;] == &#39;[T-Deposit2]&#39;:
                if meta[&#39;axis&#39;] == &#39;e12&#39;:
                    ax1_ivar, ax2_ivar = &#39;ie&#39;, &#39;ic&#39;
                elif meta[&#39;axis&#39;] == &#39;e21&#39;:
                    ax1_ivar, ax2_ivar = &#39;ic&#39;, &#39;ie&#39;
                elif meta[&#39;axis&#39;] == &#39;t-e1&#39;:
                    ax1_ivar, ax2_ivar = &#39;it&#39;, &#39;ie&#39;
                elif meta[&#39;axis&#39;] == &#39;t-e2&#39;:
                    ax1_ivar, ax2_ivar = &#39;it&#39;, &#39;ic&#39;
                elif meta[&#39;axis&#39;] == &#39;e1-t&#39;:
                    ax1_ivar, ax2_ivar = &#39;ie&#39;, &#39;it&#39;
                elif meta[&#39;axis&#39;] == &#39;e2-t&#39;:
                    ax1_ivar, ax2_ivar = &#39;ic&#39;, &#39;it&#39;

            if meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39; and meta[&#39;axis&#39;] == &#39;chart&#39;:
                remaining_ndata_to_read = (Z_y_max - Z_y_min + 1) * (N_x_max - N_x_min + 1)
            else:
                # check if this is one of the backwards instances
                expected_ax1_ivar = tdata_ivar_strs[axis1_ivar]
                expected_ax2_ivar = tdata_ivar_strs[axis2_ivar]
                if meta.mesh==&#39;xyz&#39;:
                    if expected_ax1_ivar == &#39;ir&#39;: expected_ax1_ivar = &#39;ix&#39;
                    if expected_ax2_ivar == &#39;ir&#39;: expected_ax1_ivar = &#39;ix&#39;
                if ax1_ivar==expected_ax1_ivar and ax2_ivar==expected_ax2_ivar:
                    pass # all is correct as is
                elif ax2_ivar == expected_ax1_ivar and ax1_ivar == expected_ax2_ivar:
                    axis1_ivar_temp = axis1_ivar
                    axis1_ivar = axis2_ivar
                    axis2_ivar = axis1_ivar_temp
                    #axis1_ivar = tdata_ivar_strs.index(ax1_ivar)
                    #axis2_ivar = tdata_ivar_strs.index(ax2_ivar)
                    #print(&#39;backwards!&#39;)
                else:
                    print(&#39;ERROR! Unknown axes (&#39;,ax1_ivar,ax2_ivar,&#39;) encountered that did not match expected axes (&#39;,
                          tdata_ivar_strs[meta.axis_index_of_tally_array[0]],tdata_ivar_strs[meta.axis_index_of_tally_array[1]],&#39;)&#39;)
                    sys.exit()

                axis1_ivar_str = tdata_ivar_strs[axis1_ivar]
                axis2_ivar_str = tdata_ivar_strs[axis2_ivar]
                axis1_size = np.shape(tdata)[axis1_ivar]
                axis2_size = np.shape(tdata)[axis2_ivar]
                ndata_to_read = axis1_size*axis2_size
                #print(axis1_ivar_str,axis2_ivar_str)
                #print(axis1_size,axis2_size,ndata_to_read)
                remaining_ndata_to_read = ndata_to_read
                iax1 = 0
                iax2 = axis2_size - 1

            if meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39; and meta[&#39;axis&#39;] == &#39;chart&#39;:
                #Z_y_max, Z_y_min, Z_y_increment # big, 1, -1
                #N_x_max, N_x_min, N_x_increment # big, 1, 1
                current_Z = Z_y_max
                current_N = N_x_min - N_x_increment
                ic = 0
                for line in data_table[1:]:
                    values = data_row_to_num_list(line)
                    for value in values:
                        remaining_ndata_to_read += -1
                        current_N += N_x_increment
                        if current_N &gt; N_x_max:
                            current_N = N_x_min
                            current_Z += Z_y_increment
                        #print(&#39;Z=&#39;,current_Z,&#39;, N=&#39;,current_N)

                        if value != 0:
                            ZZZAAAM = 10000*current_Z + 10*(current_Z+current_N) + i_metastable
                            if ZZZAAAM not in ZZZAAAM_list:
                                ic = len(ZZZAAAM_list)
                                ZZZAAAM_list.append(ZZZAAAM)
                            else:
                                ic = ZZZAAAM_list.index(ZZZAAAM)
                            #print(ic, i_metastable)
                            #print(ic,value)
                            tdata[ir, iy, iz, ie, it, ia, il, ip, ic, ierr + ierr_mod] = value

                        if remaining_ndata_to_read &lt;= 0:
                            break







            elif meta[&#39;2D-type&#39;] in [1,2,3,6,7]:
                for line in data_table[1:]:
                    values = data_row_to_num_list(line)
                    #print(line)
                    for value in values:
                        exec(axis1_ivar_str + &#39; = &#39; + str(iax1), globals())
                        exec(axis2_ivar_str + &#39; = &#39; + str(iax2), globals())
                        #print(ir, iy, iz, ie, it, ia, il, ip, ic, ierr, &#39;\t&#39;, value)
                        tdata[ir, iy, iz, ie, it, ia, il, ip, ic, ierr + ierr_mod] = value
                        remaining_ndata_to_read += -1
                        #print(iax1, iax2)
                        iax1 += 1
                        if iax1 == axis1_size:
                            iax1 = 0
                            iax2 += -1
                    if remaining_ndata_to_read &lt;= 0:
                        break

            elif meta[&#39;2D-type&#39;] == 4:
                iax2 = 0
                for line in data_table[2:]:
                    values = data_row_to_num_list(line)
                    value = values[2]
                    value_err = values[3]
                    exec(axis1_ivar_str + &#39; = &#39; + str(iax1), globals())
                    exec(axis2_ivar_str + &#39; = &#39; + str(iax2), globals())
                    tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 0 + ierr_mod] = value
                    tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 1 + ierr_mod] = value_err
                    # print(ir, iy, iz, ie, it, ia, il, ip, ic, ierr,&#39;\t&#39;,value)
                    remaining_ndata_to_read += -1
                    # print(iax1, iax2)
                    iax1 += 1
                    if iax1 == axis1_size:
                        iax1 = 0
                        iax2 += 1

                    if remaining_ndata_to_read &lt;= 0:
                        break

            elif meta[&#39;2D-type&#39;] == 5:
                for line in data_table[2:]:
                    values = data_row_to_num_list(line)
                    #print(line)
                    for vi, value in enumerate(values):
                        if vi==0: continue # header column
                        exec(axis1_ivar_str + &#39; = &#39; + str(iax1), globals())
                        exec(axis2_ivar_str + &#39; = &#39; + str(iax2), globals())
                        #print(ir, iy, iz, ie, it, ia, il, ip, ic, ierr, &#39;\t&#39;, value)
                        tdata[ir, iy, iz, ie, it, ia, il, ip, ic, ierr + ierr_mod] = value
                        remaining_ndata_to_read += -1
                        # print(iax1, iax2)
                        iax1 += 1
                        if iax1 == axis1_size:
                            iax1 = 0
                            iax2 += -1
                    if remaining_ndata_to_read &lt;= 0:
                        break

            else:
                print(&#39;ERROR! unsupported 2D-type of &#39;,meta[&#39;2D-type&#39;],&#39; provided; legal values are [1,2,3,4,5,6,7]&#39;)
                sys.exit()

    else:
        print(meta.axis_dimensions,&#39;axis dimensions is unknown, ERROR!&#39;)
        sys.exit()

    if len(banked_uninterpreted_lines) != 0:
        print(&#39;The following potentially useful output lines were found but not stored anywhere:&#39;)
        for line in banked_uninterpreted_lines:
            print(&#39;\t&#39;+line)

    return_updated_metadata_too = False
    if meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39;:
        return_updated_metadata_too = True
        if meta[&#39;axis&#39;] == &#39;chart&#39;:
            meta[&#39;nuclide_ZZZAAAM_list&#39;] = ZZZAAAM_list
            meta[&#39;nuclide_isomer_list&#39;] = [ZZZAAAM_to_nuclide_plain_str(i) for i in ZZZAAAM_list]
            nc_max = len(ZZZAAAM_list) #+ 1
            meta[&#39;nc&#39;] = nc_max
            tdata = tdata[:,:,:,:,:,:,:,:,:nc_max,:]
        elif meta[&#39;axis&#39;] == &#39;charge&#39; or meta[&#39;axis&#39;] == &#39;mass&#39;:
            ic_axis_tdata_sum = tdata.sum(axis=(0,1,2,3,4,5,6,7,9))
            nc_max = np.max(np.nonzero(ic_axis_tdata_sum)) + 1
            meta[&#39;nc&#39;] = nc_max
            tdata = tdata[:, :, :, :, :, :, :, :, :nc_max, :]

    if return_updated_metadata_too:
        return tdata, meta
    else:
        return tdata</code></pre>
</details>
</dd>
<dt id="PHITS_tools.build_tally_Pandas_dataframe"><code class="name flex">
<span>def <span class="ident">build_tally_Pandas_dataframe</span></span>(<span>tdata, meta)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Calculates the absolute uncertainty for every value in the PHITS tally data array</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code>import pandas as pd</code></li>
</ul>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>tdata</code> = 10-dimensional NumPy array containing read/extracted tally results</li>
<li><code>meta</code> = Munch object / dictionary containing tally metadata</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>tally_df</code> = Pandas dataframe containing the entire contents of the <code>tdata</code> array;
note that tally_df.attrs returns values which are the same for all rows</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_tally_Pandas_dataframe(tdata,meta):
    &#39;&#39;&#39;
    Description:
        Calculates the absolute uncertainty for every value in the PHITS tally data array

    Dependencies:
        - `import pandas as pd`

    Inputs:
        - `tdata` = 10-dimensional NumPy array containing read/extracted tally results
        - `meta` = Munch object / dictionary containing tally metadata

    Outputs:
        - `tally_df` = Pandas dataframe containing the entire contents of the `tdata` array;
                note that tally_df.attrs returns values which are the same for all rows

    &#39;&#39;&#39;
    import pandas as pd
    ir_max, iy_max, iz_max, ie_max, it_max, ia_max, il_max, ip_max, ic_max, ierr_max = np.shape(tdata)
    num_df_rows = ir_max * iy_max * iz_max * ie_max * it_max * ia_max * il_max * ip_max * ic_max
    # determine what columns to include, based on what info was specified vs left at default values
    col_names_list = []

    in_irregular_TCross_rz_mesh = False
    in_irregular_TCross_xyz_mesh = False
    ierr_mod = 0
    if meta[&#39;tally_type&#39;] == &#39;[T-Cross]&#39; and (meta.mesh == &#39;xyz&#39; or meta.mesh == &#39;r-z&#39;):
        if &#39;enclos&#39; in meta and meta[&#39;enclos&#39;] == 1:
            pass
        else:
            if meta.mesh == &#39;r-z&#39;:
                in_irregular_TCross_rz_mesh = True
                min_r_is_zero = False
                if meta[&#39;r-mesh_bin_edges&#39;][0]==0:
                    min_r_is_zero = True
                ierr_mod = int(ierr_max / 2)
            else:
                in_irregular_TCross_xyz_mesh = True


    # region columns
    if meta.mesh == &#39;reg&#39;:
        reg_cols = [&#39;ir&#39;,&#39;reg&#39;,&#39;reg#&#39;] # use meta.reg_groups and meta.reg_num
    elif meta.mesh == &#39;xyz&#39;:
        if in_irregular_TCross_xyz_mesh:
            reg_cols = [&#39;ix&#39;, &#39;iy&#39;, &#39;iz&#39;, &#39;x_mid&#39;, &#39;y_mid&#39;, &#39;z_surf&#39;]
        else:
            reg_cols = [&#39;ix&#39;,&#39;iy&#39;,&#39;iz&#39;,&#39;x_mid&#39;,&#39;y_mid&#39;,&#39;z_mid&#39;]
    elif meta.mesh == &#39;r-z&#39;:
        if in_irregular_TCross_rz_mesh:
            #reg_cols = [&#39;ir&#39;, &#39;ic&#39;, &#39;r_mid&#39;, &#39;z_surf&#39;, &#39;iy&#39;, &#39;iz&#39;, &#39;r_surf&#39;, &#39;z_mid&#39;]
            reg_cols = [&#39;ir&#39;, &#39;iz&#39;, &#39;r_mid&#39;, &#39;z_surf&#39;, &#39;r_surf&#39;, &#39;z_mid&#39;]
        else:
            reg_cols = [&#39;ir&#39;,&#39;iz&#39;,&#39;r_mid&#39;,&#39;z_mid&#39;]
    elif meta.mesh == &#39;tet&#39;:
        reg_cols = [&#39;ir&#39;,&#39;tet&#39;] #,&#39;tet#&#39;]
    elif meta.mesh == &#39;point&#39;:
        reg_cols = [&#39;ir&#39;,&#39;point#&#39;]
    elif meta.mesh == &#39;ring&#39;:
        reg_cols = [&#39;ir&#39;,&#39;ring#&#39;]
    col_names_list += reg_cols



    # Determine what other columns will be present
    ecols, tcols, acols, lcols, pcols, ccols = False, False, False, False, False, False
    single_specified_bin_axes = [] # log axes which are provided by user but only contain 1 bin
    single_bin_ranges_or_values = []
    if meta.ne != None:
        if meta.ne==1:
            single_specified_bin_axes.append(&#39;e&#39;)
            single_bin_ranges_or_values.append([&#39;Energy&#39;,meta[&#39;e-mesh_bin_edges&#39;]])
        else:
            ecols = True
            ecol_names_list = [&#39;ie&#39;,&#39;e_mid&#39;]
            col_names_list += ecol_names_list
    else:
        single_bin_ranges_or_values.append([&#39;Energy&#39;,&#39;default/all&#39;])
    if meta.nt != None:
        if meta.nt==1:
            single_specified_bin_axes.append(&#39;t&#39;)
            single_bin_ranges_or_values.append([&#39;Time&#39;,meta[&#39;t-mesh_bin_edges&#39;]])
        else:
            tcols = True
            tcol_names_list = [&#39;it&#39;, &#39;t_mid&#39;]
            col_names_list += tcol_names_list
    else:
        single_bin_ranges_or_values.append([&#39;Time&#39;,&#39;default/all&#39;])
    if meta.na != None:
        if meta.na==1:
            single_specified_bin_axes.append(&#39;a&#39;)
            single_bin_ranges_or_values.append([&#39;Angle&#39;,meta[&#39;a-mesh_bin_edges&#39;]])
        else:
            acols = True
            acol_names_list = [&#39;ia&#39;, &#39;a_mid&#39;]
            col_names_list += acol_names_list
    else:
        single_bin_ranges_or_values.append([&#39;Angle&#39;,&#39;default/all&#39;])
    if meta.nl != None:
        if meta.nl==1:
            single_specified_bin_axes.append(&#39;l&#39;)
            single_bin_ranges_or_values.append([&#39;LET&#39;,meta[&#39;l-mesh_bin_edges&#39;]])
        else:
            lcols = True
            lcol_names_list = [&#39;il&#39;, &#39;LET_mid&#39;]
            col_names_list += lcol_names_list
    else:
        single_bin_ranges_or_values.append([&#39;LET&#39;,&#39;default/all&#39;])

    if meta.nc != None:
        if meta.nc == 1:
            pass
        else:
            ccols = True
            if meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39;:
                if meta[&#39;axis&#39;] == &#39;chart&#39;:
                    ccol_names_list = [&#39;ic&#39;, &#39;nuclide&#39;, &#39;ZZZAAAM&#39;]
                    col_names_list += ccol_names_list
                elif meta[&#39;axis&#39;] == &#39;charge&#39;:
                    ccol_names_list = [&#39;ic/Z/charge&#39;]
                    col_names_list += ccol_names_list
                elif meta[&#39;axis&#39;] == &#39;mass&#39;:
                    ccol_names_list = [&#39;ic/A/mass&#39;]
                    col_names_list += ccol_names_list
            elif meta[&#39;tally_type&#39;] == &#39;[T-Deposit2]&#39;:
                pass

    if meta.npart != None: # and meta.part_groups[0]==&#39;all&#39;:
        if meta.npart==1:
            single_specified_bin_axes.append(&#39;p&#39;)
            single_bin_ranges_or_values.append([&#39;Particle&#39;,meta.part_groups[0]])
        else:
            pcols = True
            pcol_names_list = [&#39;ip&#39;, &#39;particle&#39;, &#39;kf-code&#39;]
            col_names_list += pcol_names_list
    else:
        single_bin_ranges_or_values.append([&#39;Particle&#39;,&#39;default/all&#39;])

    # HANDLE SPECIAL COLUMNS HERE (ic / ccols)


    # value columns come last
    val_names_list = [&#39;value&#39;, &#39;rel.err.&#39;]
    if ierr_max == 3 or ierr_max == 6: val_names_list += [&#39;abs.err.&#39;]
    if ierr_max &gt;= 4: val_names_list += [&#39;value2&#39;, &#39;rel.err.2&#39;]
    if ierr_max == 6: val_names_list += [&#39;abs.err.2&#39;]
    col_names_list += val_names_list

    # Initialize dictionary
    df_dict = {}
    for col in col_names_list:
        df_dict[col] = []


    # Populate dictionary
    for ir in range(ir_max):
        for iy in range(iy_max):
            for iz in range(iz_max):
                for ie in range(ie_max):
                    for it in range(it_max):
                        for ia in range(ia_max):
                            for il in range(il_max):
                                for ip in range(ip_max):
                                    for ic in range(ic_max):
                                        # Region columns
                                        if in_irregular_TCross_rz_mesh:
                                            if (ir == ir_max - 1 and iz == iz_max - 1): # only index that should be empty
                                                continue
                                            # [&#39;ir&#39;, &#39;iz&#39;, &#39;r_mid&#39;, &#39;z_surf&#39;, &#39;r_surf&#39;, &#39;z_mid&#39;]
                                            df_dict[reg_cols[0]].append(ir)
                                            df_dict[reg_cols[1]].append(iz)
                                            if ir==ir_max-1:
                                                df_dict[reg_cols[2]].append(None)
                                            else:
                                                df_dict[reg_cols[2]].append(meta[&#39;r-mesh_bin_mids&#39;][ir])
                                            df_dict[reg_cols[3]].append(meta[&#39;z-mesh_bin_edges&#39;][iz])
                                            df_dict[reg_cols[4]].append(meta[&#39;r-mesh_bin_edges&#39;][ir])
                                            if iz == iz_max - 1:
                                                df_dict[reg_cols[5]].append(None)
                                            else:
                                                df_dict[reg_cols[5]].append(meta[&#39;z-mesh_bin_mids&#39;][iz])
                                            # OLD IMPLEMENTATION IS BELOW:
                                            &#39;&#39;&#39;
                                            # skip unwritten indices
                                            # reg_cols = [&#39;ir&#39;, &#39;ic&#39;, &#39;r_mid&#39;, &#39;z_surf&#39;, &#39;iy&#39;, &#39;iz&#39;, &#39;r_surf&#39;, &#39;z_mid&#39;]
                                            if (ir==ir_max-1 and ic==ic_max-1):
                                                if (iy == iy_max - 1 or iz == iz_max - 1): continue
                                                if min_r_is_zero and iy==0: continue # surface vals not written for r=0.0
                                                df_dict[reg_cols[0]].append(None)
                                                df_dict[reg_cols[1]].append(None)
                                                df_dict[reg_cols[2]].append(None)
                                                df_dict[reg_cols[3]].append(None)
                                                df_dict[reg_cols[4]].append(iy)
                                                df_dict[reg_cols[5]].append(iz)
                                                df_dict[reg_cols[6]].append(meta[&#39;r-mesh_bin_edges&#39;][iy])
                                                df_dict[reg_cols[7]].append(meta[&#39;z-mesh_bin_mids&#39;][iz])
                                            elif (iy==iy_max-1 and iz==iz_max-1):
                                                if (ir == ir_max - 1 or ic == ic_max - 1): continue
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(ic)
                                                df_dict[reg_cols[2]].append(meta[&#39;r-mesh_bin_mids&#39;][ir])
                                                df_dict[reg_cols[3]].append(meta[&#39;z-mesh_bin_edges&#39;][ic])
                                                df_dict[reg_cols[4]].append(None)
                                                df_dict[reg_cols[5]].append(None)
                                                df_dict[reg_cols[6]].append(None)
                                                df_dict[reg_cols[7]].append(None)
                                            else: # all other indices should not have any content written into them
                                                continue
                                            &#39;&#39;&#39;
                                        else:
                                            if meta.mesh == &#39;reg&#39;: #reg_cols = [&#39;ir&#39;,&#39;reg&#39;, &#39;reg#&#39;]  # use meta.reg_groups and meta.reg_num
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(meta.reg_groups[ir])
                                                df_dict[reg_cols[2]].append(meta.reg_num[ir])
                                            elif meta.mesh == &#39;xyz&#39;:
                                                #reg_cols = [&#39;ix&#39;, &#39;iy&#39;, &#39;iz&#39;, &#39;xmid&#39;, &#39;ymid&#39;, &#39;zmid&#39;]
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(iy)
                                                df_dict[reg_cols[2]].append(iz)
                                                df_dict[reg_cols[3]].append(meta[&#39;x-mesh_bin_mids&#39;][ir])
                                                df_dict[reg_cols[4]].append(meta[&#39;y-mesh_bin_mids&#39;][iy])
                                                if in_irregular_TCross_xyz_mesh:
                                                    df_dict[reg_cols[5]].append(meta[&#39;z-mesh_bin_edges&#39;][iz])
                                                else:
                                                    df_dict[reg_cols[5]].append(meta[&#39;z-mesh_bin_mids&#39;][iz])
                                            elif meta.mesh == &#39;r-z&#39;:
                                                #reg_cols = [&#39;ir&#39;, &#39;iz&#39;, &#39;rmid&#39;, &#39;zmid&#39;]
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(iz)
                                                df_dict[reg_cols[2]].append(meta[&#39;r-mesh_bin_mids&#39;][ir])
                                                df_dict[reg_cols[3]].append(meta[&#39;z-mesh_bin_mids&#39;][iz])
                                            elif meta.mesh == &#39;tet&#39;:
                                                #reg_cols = [&#39;ir&#39;,&#39;tet&#39;]
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(meta.tet_num[ir])
                                            elif meta.mesh == &#39;point&#39;:
                                                #reg_cols = [&#39;ir&#39;,&#39;point#&#39;]
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(str(ir+1))
                                            elif meta.mesh == &#39;ring&#39;:
                                                #reg_cols = [&#39;ir&#39;,&#39;ring#&#39;]
                                                df_dict[reg_cols[0]].append(ir)
                                                df_dict[reg_cols[1]].append(str(ir+1))

                                        #ecols, tcols, acols, lcols, pcols, ccols
                                        if pcols: # pcol_names_list = [&#39;ip&#39;, &#39;particle&#39;, &#39;kf-code&#39;]
                                            df_dict[pcol_names_list[0]].append(ip)
                                            df_dict[pcol_names_list[1]].append(meta.part_groups[ip])
                                            df_dict[pcol_names_list[2]].append(meta.kf_groups[ip])

                                        if ecols: # ecol_names_list = [&#39;ie&#39;,&#39;e_mid&#39;]
                                            df_dict[ecol_names_list[0]].append(ie)
                                            df_dict[ecol_names_list[1]].append(meta[&#39;e-mesh_bin_mids&#39;][ie])
                                        if tcols: # tcol_names_list = [&#39;it&#39;,&#39;t_mid&#39;]
                                            df_dict[tcol_names_list[0]].append(it)
                                            df_dict[tcol_names_list[1]].append(meta[&#39;t-mesh_bin_mids&#39;][it])
                                        if acols: # acol_names_list = [&#39;ia&#39;,&#39;a_mid&#39;]
                                            df_dict[acol_names_list[0]].append(ia)
                                            df_dict[acol_names_list[1]].append(meta[&#39;a-mesh_bin_mids&#39;][ia])
                                        if lcols: # lcol_names_list = [&#39;il&#39;,&#39;LET_mid&#39;]
                                            df_dict[lcol_names_list[0]].append(il)
                                            df_dict[lcol_names_list[1]].append(meta[&#39;l-mesh_bin_mids&#39;][il])

                                        if ccols:
                                            if meta[&#39;tally_type&#39;] == &#39;[T-Yield]&#39;:
                                                if meta[&#39;axis&#39;] == &#39;chart&#39;:
                                                    #ccol_names_list = [&#39;ic&#39;, &#39;nuclide&#39;, &#39;ZZZAAAM&#39;]
                                                    df_dict[ccol_names_list[0]].append(ic)
                                                    df_dict[ccol_names_list[1]].append(meta[&#39;nuclide_isomer_list&#39;][ic])
                                                    df_dict[ccol_names_list[2]].append(meta[&#39;nuclide_ZZZAAAM_list&#39;][ic])
                                                elif meta[&#39;axis&#39;] == &#39;charge&#39;:
                                                    #ccol_names_list = [&#39;ic/Z/charge&#39;]
                                                    df_dict[ccol_names_list[0]].append(ic)
                                                elif meta[&#39;axis&#39;] == &#39;mass&#39;:
                                                    #ccol_names_list = [&#39;ic/A/mass&#39;]
                                                    df_dict[ccol_names_list[0]].append(ic)

                                        # Value columns
                                        #val_names_list = [&#39;value&#39;, &#39;rel.err.&#39;,&#39;abs.err.&#39;]
                                        df_dict[val_names_list[0]].append(tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 0])
                                        df_dict[val_names_list[1]].append(tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 1])
                                        if ierr_max == 3 or ierr_max == 6:
                                            df_dict[val_names_list[2]].append(tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 2])
                                        if in_irregular_TCross_rz_mesh:
                                            df_dict[val_names_list[0+ierr_mod]].append(tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 0+ierr_mod])
                                            df_dict[val_names_list[1+ierr_mod]].append(tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 1+ierr_mod])
                                            if ierr_max == 6:
                                                df_dict[val_names_list[2+ierr_mod]].append(tdata[ir, iy, iz, ie, it, ia, il, ip, ic, 2 + ierr_mod])


    # Convert dictionary to Pandas dataframe
    #for key in df_dict.keys():
    #    print(key,len(df_dict[key]))
    #sys.exit()
    tally_df = pd.DataFrame(df_dict)

    # store information on settings provided by user that are different from default but same for all rows
    if len(single_bin_ranges_or_values) &gt; 0:
        for i in single_bin_ranges_or_values:
            col, val = i
            tally_df.attrs[col] = val

    #with pd.option_context(&#39;display.max_rows&#39;, None, &#39;display.max_columns&#39;, None): print(tally_df)
    if in_debug_mode:
        #print(tally_df.to_string())
        print(tally_df.attrs)
    return tally_df</code></pre>
</details>
</dd>
<dt id="PHITS_tools.search_for_dump_parameters"><code class="name flex">
<span>def <span class="ident">search_for_dump_parameters</span></span>(<span>output_file)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Try to determine the dump settings used for a dump file by searching for the same file without "_dmp" and parsing
its header for the "dump = " line and subsequent line specifying the column ordering.</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code>from pathlib import Path</code></li>
</ul>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>output_file</code> = a file/filepath (string or Path object) to be judged</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>dump_data_number</code> = value following "dump = " in the PHITS tally (integer from -20 to 20, excluding 0) (D=<code>None</code>)</li>
<li><code>dump_data_sequence</code> = list of integers specifying the order and meaning of the dump file columns (D=<code>None</code>)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_for_dump_parameters(output_file):
    &#39;&#39;&#39;
    Description:
        Try to determine the dump settings used for a dump file by searching for the same file without &#34;_dmp&#34; and parsing
        its header for the &#34;dump = &#34; line and subsequent line specifying the column ordering.

    Dependencies:
        - `from pathlib import Path`

    Inputs:
        - `output_file` = a file/filepath (string or Path object) to be judged

    Outputs:
        - `dump_data_number` = value following &#34;dump = &#34; in the PHITS tally (integer from -20 to 20, excluding 0) (D=`None`)
        - `dump_data_sequence` = list of integers specifying the order and meaning of the dump file columns (D=`None`)
    &#39;&#39;&#39;
    dump_data_number, dump_data_sequence = None, None
    output_file = Path(output_file)
    origin_tally_file = Path(output_file.parent, output_file.stem.replace(&#39;_dmp&#39;,&#39;&#39;) + output_file.suffix)
    PHITS_file_type = determine_PHITS_output_file_type(origin_tally_file)
    if PHITS_file_type[&#39;file_does_not_exist&#39;]:
        print(&#34;Could not find this dump file&#39;s companion original standard tally output file&#34;,origin_tally_file)
        return dump_data_number, dump_data_sequence
    elif not PHITS_file_type[&#39;is_standard_tally_output&#39;]:
        print(&#34;Found dump file&#39;s suspected companion original standard tally output file, but it does not seem to actually be formatted as a standard tally output file&#34;,origin_tally_file)
        return dump_data_number, dump_data_sequence
    tally_header, tally_content = split_into_header_and_content(origin_tally_file)
    for li, line in enumerate(tally_header):
        if &#34;dump =&#34; in line:
            if line[0] == &#39;#&#39;:  # commented line
                key, value = extract_data_from_header_line(line[1:])
            else:
                key, value = extract_data_from_header_line(line)
            dump_data_number = int(value)
            dump_data_sequence_str_list = tally_header[li+1].strip().split()
            dump_data_sequence = [int(i) for i in dump_data_sequence_str_list]
            break
    if dump_data_number == None and dump_data_sequence == None:
        print(&#39;Was unable to locate dump specification information in tally output file&#39;,origin_tally_file)
    return dump_data_number, dump_data_sequence</code></pre>
</details>
</dd>
<dt id="PHITS_tools.determine_PHITS_output_file_type"><code class="name flex">
<span>def <span class="ident">determine_PHITS_output_file_type</span></span>(<span>output_file)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Determine what kind of PHITS file is being hanlded (tally standard output, binary tally dump, ASCII tally dump, etc.)</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code>from pathlib import Path</code></li>
</ul>
<h2 id="inputs">Inputs</h2>
<ul>
<li><code>output_file</code> = a file/filepath (string or Path object) to be judged</li>
</ul>
<h2 id="outputs">Outputs</h2>
<ul>
<li><code>PHITS_file_type</code> = a dictionary of Booleans detailing what kind of file <code>output_file</code> is (and isn't) with
the following keys (each with a value set to <code>True</code> or <code>False</code>):
<code>'is_standard_tally_output'</code>, <code>'is_binary_tally_dump'</code>, <code>'is_ASCII_tally_dump'</code>,
<code>'is_unknown_file_type'</code>, and <code>'file_does_not_exist'</code>.
By default, all are set to <code>False</code> except for
<code>'is_unknown_file_type'</code> which is <code>True</code> by default.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def determine_PHITS_output_file_type(output_file):
    &#39;&#39;&#39;
    Description:
        Determine what kind of PHITS file is being hanlded (tally standard output, binary tally dump, ASCII tally dump, etc.)

    Dependencies:
        - `from pathlib import Path`

    Inputs:
        - `output_file` = a file/filepath (string or Path object) to be judged

    Outputs:
        - `PHITS_file_type` = a dictionary of Booleans detailing what kind of file `output_file` is (and isn&#39;t) with
            the following keys (each with a value set to `True` or `False`):
            `&#39;is_standard_tally_output&#39;`, `&#39;is_binary_tally_dump&#39;`, `&#39;is_ASCII_tally_dump&#39;`,
            `&#39;is_unknown_file_type&#39;`, and `&#39;file_does_not_exist&#39;`.  By default, all are set to `False` except for
            `&#39;is_unknown_file_type&#39;` which is `True` by default.
    &#39;&#39;&#39;
    PHITS_file_type = {&#39;is_standard_tally_output&#39;: False,
                       &#39;is_binary_tally_dump&#39;: False,
                       &#39;is_ASCII_tally_dump&#39;: False,
                       &#39;is_unknown_file_type&#39;: True,
                       &#39;file_does_not_exist&#39;: False
                       }
    output_file = Path(output_file)
    if not output_file.is_file():
        print(&#39;Provided output file&#39;,output_file,&#39;was determined to not be a file!&#39;)
        PHITS_file_type[&#39;is_unknown_file_type&#39;] = False
        PHITS_file_type[&#39;file_does_not_exist&#39;] = True
        return PHITS_file_type
    with open(output_file) as f:
        try:
            first_line = f.readline().strip()
        except:  # triggered if encountering binary / non ASCII or UTF-8 file
            if &#39;_dmp&#39; in output_file.stem:
                PHITS_file_type[&#39;is_binary_tally_dump&#39;] = True
                PHITS_file_type[&#39;is_unknown_file_type&#39;] = False
                return PHITS_file_type
        if first_line[0] == &#39;[&#39;:
            PHITS_file_type[&#39;is_standard_tally_output&#39;] = True
            PHITS_file_type[&#39;is_unknown_file_type&#39;] = False
        elif &#39;_dmp&#39; in output_file.stem:
            PHITS_file_type[&#39;is_ASCII_tally_dump&#39;] = True
            PHITS_file_type[&#39;is_unknown_file_type&#39;] = False
    return PHITS_file_type</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#how-to-use-the-phits_toolspy-module">How to use the PHITS_tools.py module</a></li>
<li><a href="#main-phits-output-parsing-functions">Main PHITS Output Parsing Functions</a></li>
<li><a href="#general-purpose-functions">General Purpose Functions</a></li>
<li><a href="#subfunctions-for-phits-output-parsing">Subfunctions for PHITS output parsing</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="PHITS_tools.parse_tally_output_file" href="#PHITS_tools.parse_tally_output_file">parse_tally_output_file</a></code></li>
<li><code><a title="PHITS_tools.parse_tally_dump_file" href="#PHITS_tools.parse_tally_dump_file">parse_tally_dump_file</a></code></li>
<li><code><a title="PHITS_tools.parse_all_tally_output_in_dir" href="#PHITS_tools.parse_all_tally_output_in_dir">parse_all_tally_output_in_dir</a></code></li>
<li><code><a title="PHITS_tools.is_number" href="#PHITS_tools.is_number">is_number</a></code></li>
<li><code><a title="PHITS_tools.ZZZAAAM_to_nuclide_plain_str" href="#PHITS_tools.ZZZAAAM_to_nuclide_plain_str">ZZZAAAM_to_nuclide_plain_str</a></code></li>
<li><code><a title="PHITS_tools.Element_Z_to_Sym" href="#PHITS_tools.Element_Z_to_Sym">Element_Z_to_Sym</a></code></li>
<li><code><a title="PHITS_tools.split_into_header_and_content" href="#PHITS_tools.split_into_header_and_content">split_into_header_and_content</a></code></li>
<li><code><a title="PHITS_tools.extract_data_from_header_line" href="#PHITS_tools.extract_data_from_header_line">extract_data_from_header_line</a></code></li>
<li><code><a title="PHITS_tools.data_row_to_num_list" href="#PHITS_tools.data_row_to_num_list">data_row_to_num_list</a></code></li>
<li><code><a title="PHITS_tools.parse_group_string" href="#PHITS_tools.parse_group_string">parse_group_string</a></code></li>
<li><code><a title="PHITS_tools.parse_tally_header" href="#PHITS_tools.parse_tally_header">parse_tally_header</a></code></li>
<li><code><a title="PHITS_tools.initialize_tally_array" href="#PHITS_tools.initialize_tally_array">initialize_tally_array</a></code></li>
<li><code><a title="PHITS_tools.calculate_tally_absolute_errors" href="#PHITS_tools.calculate_tally_absolute_errors">calculate_tally_absolute_errors</a></code></li>
<li><code><a title="PHITS_tools.split_str_of_equalities" href="#PHITS_tools.split_str_of_equalities">split_str_of_equalities</a></code></li>
<li><code><a title="PHITS_tools.parse_tally_content" href="#PHITS_tools.parse_tally_content">parse_tally_content</a></code></li>
<li><code><a title="PHITS_tools.build_tally_Pandas_dataframe" href="#PHITS_tools.build_tally_Pandas_dataframe">build_tally_Pandas_dataframe</a></code></li>
<li><code><a title="PHITS_tools.search_for_dump_parameters" href="#PHITS_tools.search_for_dump_parameters">search_for_dump_parameters</a></code></li>
<li><code><a title="PHITS_tools.determine_PHITS_output_file_type" href="#PHITS_tools.determine_PHITS_output_file_type">determine_PHITS_output_file_type</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>